FexoApp/
- capacitor.config.ts:
import { CapacitorConfig } from '@capacitor/cli';

const config: CapacitorConfig = {
  appId: 'com.worksparkai.app',
  appName: 'Workspark AI',
  webDir: 'dist',
  server: {
    androidScheme: 'https',
    cleartext: false
  },
  android: {
    allowMixedContent: false,
    captureInput: true,
    webContentsDebuggingEnabled: true
  },
  plugins: {
    LocalNotifications: {
      smallIcon: 'ic_stat_icon_config_sample',
      iconColor: '#4285F4'
    }
  }
};

export default config;
- index.html:
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="manifest" href="/manifest.json" /> 
    <link rel="icon" type="image/svg+xml" href="/worksparkai.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Workspark AI</title>
  </head>
  <body>
    <div id="root"></div>
    <div id="portal-root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
- scripts/
- - convert-icon.js:
import sharp from 'sharp';
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import { dirname } from 'path';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// Icon sizes for Android
const sizes = {
  'mipmap-mdpi': 48,
  'mipmap-hdpi': 72,
  'mipmap-xhdpi': 96,
  'mipmap-xxhdpi': 144,
  'mipmap-xxxhdpi': 192
};

const svgPath = path.join(__dirname, '..', 'public', 'worksparkai.svg');
const androidResPath = path.join(__dirname, '..', 'android', 'app', 'src', 'main', 'res');

async function convertIcons() {
  console.log('Converting SVG to PNG icons for Android...\n');
  
  // Read SVG file
  const svgBuffer = fs.readFileSync(svgPath);
  
  for (const [folder, size] of Object.entries(sizes)) {
    const folderPath = path.join(androidResPath, folder);
    
    // Create folder if it doesn't exist
    if (!fs.existsSync(folderPath)) {
      fs.mkdirSync(folderPath, { recursive: true });
    }
    
    // Convert for regular launcher icon
    const regularIconPath = path.join(folderPath, 'ic_launcher.png');
    await sharp(svgBuffer)
      .resize(size, size)
      .png()
      .toFile(regularIconPath);
    console.log(`✓ Created ${folder}/ic_launcher.png (${size}x${size})`);
    
    // Convert for round launcher icon
    const roundIconPath = path.join(folderPath, 'ic_launcher_round.png');
    await sharp(svgBuffer)
      .resize(size, size)
      .png()
      .toFile(roundIconPath);
    console.log(`✓ Created ${folder}/ic_launcher_round.png (${size}x${size})`);
  }
  
  console.log('\n✅ All icons created successfully!');
  console.log('\nNote: The round icons are currently square. For a true round icon,');
  console.log('consider using a circular mask or redesigning the icon with a circular shape.');
}

convertIcons().catch(err => {
  console.error('Error converting icons:', err);
  process.exit(1);
});
- src/
- - App.css:
/* src/App.css */
:root {
  /* --- GLOBAL ACCENT: PURPLE --- */
  --accent-primary: #8b5cf6; /* Violet 500 */
  --accent-hover: #7c3aed;   /* Violet 600 */
  --accent-bg: rgba(139, 92, 246, 0.1);
  --accent-bg-hover: rgba(139, 92, 246, 0.2);
  --accent-text: #8b5cf6;
  
  /* --- LAYOUT & COLORS (LIGHT) --- */
  --sidebar-width: 260px;
  --sidebar-bg-color: #f9fafb; /* Slightly lighter gray for freshness */
  --main-bg-color: #ffffff;
  --input-bg-color: #ffffff;
  --primary-text-color: #111827;
  --secondary-text-color: #6b7280;
  --border-color: #e5e7eb;
  --button-hover-bg: #f3f4f6;
  --assistant-message-bg: #f9fafb;
  
  /* --- COMPONENT SPECIFIC --- */
  --tooltip-bg-color: #1f2937;
  --tooltip-text-color: #ffffff;
  --code-block-header: #f3f4f6;
  --code-block-text: #374151;
  --code-text: #1f2937;
  --overlay-scrim: rgba(0, 0, 0, 0.4);

  /* --- ANIMATIONS --- */
  --ease-spring: cubic-bezier(0.4, 0, 0.2, 1); /* Unified motion curve */
  --anim-duration: 0.3s;
}

[data-theme="dark"] {
  /* --- GLOBAL ACCENT: PURPLE (Dark Mode Adjusted) --- */
  --accent-primary: #a78bfa; /* Violet 400 - Brighter for dark bg */
  --accent-hover: #c4b5fd;   /* Violet 300 */
  --accent-bg: rgba(139, 92, 246, 0.15);
  --accent-bg-hover: rgba(139, 92, 246, 0.25);
  --accent-text: #a78bfa;

  /* --- LAYOUT & COLORS (DARK) --- */
  --sidebar-bg-color: #18181b; /* Zinc 900 */
  --main-bg-color: #27272a;    /* Zinc 800 */
  --input-bg-color: #27272a;
  --primary-text-color: #f4f4f5;
  --secondary-text-color: #a1a1aa;
  --border-color: #3f3f46;
  --button-hover-bg: #3f3f46;
  --assistant-message-bg: #27272a;
  
  /* --- COMPONENT SPECIFIC --- */
  --tooltip-bg-color: #18181b;
  --tooltip-text-color: #f4f4f5;
  --code-block-header: #18181b;
  --code-block-text: #d4d4d8;
  --overlay-scrim: rgba(0, 0, 0, 0.7);
}

body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
  background-color: var(--main-bg-color);
  color: var(--primary-text-color);
  -webkit-font-smoothing: antialiased;
  transition: background-color var(--anim-duration) var(--ease-spring), color var(--anim-duration) var(--ease-spring);
}

/* Collapse logic */
body:has(.sidebar.is-collapsed) {
  --sidebar-width: 80px;
}

.app-container {
  display: flex;
  height: 100vh;
  width: 100vw;
  background-color: var(--main-bg-color);
  overflow: hidden;
  box-sizing: border-box;
}

/* Responsive */
@media (max-width: 768px) {
  .app-container {
    padding-top: 56px;
    height: 100vh;
  }
  :root { --sidebar-width: 0px; }
}

/* --- Loading Screens --- */
.initial-loading-screen {
  position: fixed;
  inset: 0;
  background-color: var(--main-bg-color);
  z-index: 9999;
  display: flex;
  justify-content: center;
  align-items: center;
}

@keyframes bouncing-loader {
  to {
    opacity: 0.3;
    transform: translateY(-0.5rem);
  }
}

.bouncing-loader {
  display: flex;
  justify-content: center;
  gap: 0.5rem;
}

.bouncing-loader > div {
  width: 0.75rem;
  height: 0.75rem;
  background: var(--accent-primary); /* Use accent color */
  border-radius: 50%;
  animation: bouncing-loader 0.6s infinite alternate;
}

.bouncing-loader > div:nth-child(2) { animation-delay: 0.2s; }
.bouncing-loader > div:nth-child(3) { animation-delay: 0.4s; }
- - App.tsx:
// src/App.tsx
import { Routes, Route, Navigate } from 'react-router-dom';
import { lazy, Suspense } from 'react';
import './App.css';
import './css/SettingsModal.css';
import './css/Notification.css'; 
import './css/AuthPage.css';
import './css/Tooltip.css';
import './css/CodeAnalysisBlock.css';
import 'katex/dist/katex.min.css';
import './css/PricingPage.css'; // Import new CSS

import PrivateRoute from './routing/PrivateRoute';
import MainAppLayout from './pages/MainAppLayout';
import AuthPage from './pages/AuthPage';
import { useSettings } from './contexts/SettingsContext';

// --- Lazily load page components ---
const ChatPage = lazy(() => import('./pages/ChatPage'));
const LandingPage = lazy(() => import('./pages/LandingPage'));
const PricingPage = lazy(() => import('./pages/PricingPage')); // <-- Add this
const ForgotPasswordPage = lazy(() => import('./pages/ForgotPasswordPage'));
const ResetPasswordPage = lazy(() => import('./pages/ResetPasswordPage'));

// --- Full screen loader for suspense fallback ---
const FullScreenLoader = () => (
  <div className="initial-loading-screen">
    <div className="bouncing-loader">
      <div></div>
      <div></div>
      <div></div>
    </div>
  </div>
);


function App() {
  const { isAuthenticated } = useSettings();

  return (
    <Suspense fallback={<FullScreenLoader />}>
      <Routes>
        {/* --- Public Routes --- */}
        <Route 
          path="/"
          element={isAuthenticated ? <Navigate to="/app" /> : <LandingPage />} 
        />
        <Route 
          path="/login" 
          element={isAuthenticated ? <Navigate to="/app" /> : <AuthPage />} 
        />
        <Route 
          path="/register" 
          element={isAuthenticated ? <Navigate to="/app" /> : <AuthPage />} 
        />
        <Route 
          path="/forgot-password" 
          element={isAuthenticated ? <Navigate to="/app" /> : <ForgotPasswordPage />} 
        />
        <Route 
          path="/reset-password" 
          element={isAuthenticated ? <Navigate to="/app" /> : <ResetPasswordPage />} 
        />
        
        {/* --- Private Application Routes --- */}
        <Route 
          path="/app"
          element={
            <PrivateRoute>
              <MainAppLayout />
            </PrivateRoute>
          }
        >
          {/* Child routes render inside MainAppLayout's <Outlet> */}
          <Route index element={<ChatPage />} />
          <Route path="c/:chatId" element={<ChatPage />} />
          <Route path="pricing" element={<PricingPage />} /> {/* <-- Add this route */}
        </Route>
        
        {/* --- Fallback Route --- */}
        <Route path="*" element={<Navigate to={isAuthenticated ? "/app" : "/"} />} />
      </Routes>
    </Suspense>
  );
}

export default App;
- - components/
- - - AnalysisBlock.tsx:
// src/components/AnalysisBlock.tsx
import { useState, useMemo, memo } from 'react';
import { FiChevronDown, FiCheck, FiFileText, FiAlertTriangle } from 'react-icons/fi';
import type { Message } from '../types';
import '../css/AnalysisBlock.css';

interface AnalysisBlockProps {
  toolMessage: Message;
  outputMessage?: Message;
}

const AnalysisBlock = memo(({ toolMessage, outputMessage }: AnalysisBlockProps) => {
  const [isExpanded, setIsExpanded] = useState(false);

  const state = toolMessage.state || (outputMessage ? 'completed' : 'writing');
  const hasError = state === 'error';
  const filename = toolMessage.content || 'document';

  const { statusText, labelClass } = useMemo(() => {
    switch (state) {
      case 'analyzing':
      case 'writing':
      case 'ready_to_execute':
        return { statusText: 'Reading document...', labelClass: 'animate-shine' };
      case 'error':
        return { statusText: 'Failed to read document', labelClass: 'error' };
      case 'completed':
        return { statusText: 'Document Read', labelClass: 'completed' };
      default:
        return { statusText: 'Analysis', labelClass: '' };
    }
  }, [state]);

  return (
    <div className={`analysis-container ${state} ${isExpanded ? 'expanded' : ''}`}>
      {/* Header */}
      <div className="analysis-header" onClick={() => setIsExpanded(!isExpanded)}>
        <div className="analysis-header-content">
          <div className="analysis-header-left">
            <span className={`analysis-label ${labelClass}`}>{statusText}</span>
          </div>
          <FiChevronDown className="chevron-icon" />
        </div>
      </div>

      {/* Expanded Content: Just the file card, no raw text results */}
      {isExpanded && (
        <div className="analysis-content">
          <div className="analysis-file-card">
            <div className="file-icon-box">
              {hasError ? <FiAlertTriangle size={18} /> : <FiFileText size={18} />}
            </div>
            <div className="file-info">
              <span className="file-name">{filename}</span>
              <span className="file-status">
                {hasError ? 'Extraction failed' : 'Content extracted to context'}
              </span>
            </div>
            {!hasError && <FiCheck className="file-check-icon" size={16} />}
          </div>
          
          {/* Only show error details if present */}
          {hasError && outputMessage?.content && (
             <div className="analysis-error-details">
               {outputMessage.content}
             </div>
          )}
        </div>
      )}
    </div>
  );
});

export default AnalysisBlock;
- - - ChatInput.tsx:
import { useState, useRef, useEffect, memo } from 'react';
import { FiPlus, FiSend, FiX, FiImage, FiPaperclip, FiSquare } from 'react-icons/fi';
import { HiOutlineMicrophone } from "react-icons/hi2";
import { uploadFile } from '../utils/api';
import type { Attachment } from '../types';
import '../css/ChatInput.css';
import Tooltip from './Tooltip';
import { useSettings } from '../contexts/SettingsContext';
import { useNotification } from '../contexts/NotificationContext';
import { getFileIcon } from '../utils/fileIcons';
import VoiceChatModal from './VoiceChatModal';
import { useChat } from '../contexts/ChatContext';
import ThinkingIcon from '../icons/thinking.svg?react';

interface ChatInputProps {
  onSendMessage: (text: string, attachments: Attachment[], metadata?: Record<string, any>) => void;
  onStopGeneration: () => void;
  isSending: boolean;
  isThinkingVisible: boolean;
}

// --- HELPER: Generate Thumbnail ---
const generateThumbnail = async (file: File): Promise<string> => {
  return new Promise((resolve) => {
    const reader = new FileReader();
    reader.onload = (e) => {
      const img = new Image();
      img.onload = () => {
        const maxWidth = 150; // Thumbnail size
        const scale = maxWidth / img.width;
        // If image is already small, don't resize
        if (scale >= 1) {
            resolve(e.target?.result as string);
            return;
        }
        const canvas = document.createElement('canvas');
        canvas.width = maxWidth;
        canvas.height = img.height * scale;
        const ctx = canvas.getContext('2d');
        ctx?.drawImage(img, 0, 0, canvas.width, canvas.height);
        resolve(canvas.toDataURL(file.type));
      };
      img.src = e.target?.result as string;
    };
    reader.readAsDataURL(file);
  });
};

// --- SUB-COMPONENT: Attachment Preview Item ---
// Handles async thumbnail generation to prevent blocking the main render loop
const AttachmentPreviewItem = memo(({ file, onRemove }: { file: File, onRemove: (f: File) => void }) => {
    const [thumbnailSrc, setThumbnailSrc] = useState<string | null>(null);
    const isImage = file.type.startsWith('image/');
  
    useEffect(() => {
      let active = true;
      if (isImage) {
        generateThumbnail(file).then(src => {
          if (active) setThumbnailSrc(src);
        });
      }
      return () => { active = false; };
    }, [file, isImage]);
  
    return (
      <div className="attachment-preview-wrapper">
        {isImage ? (
          <div className="attachment-thumbnail">
            {thumbnailSrc ? (
                <img src={thumbnailSrc} alt={file.name} />
            ) : (
                <div className="skeleton-loader" style={{width: '100%', height: '100%', background: 'rgba(128,128,128,0.1)'}}></div>
            )}
          </div>
        ) : (
          <div className="attachment-file-preview">
            <div className="file-preview-icon">{getFileIcon(file.type)}</div>
            <span className="file-preview-name">{file.name}</span>
          </div>
        )}
        <Tooltip text={`Remove ${file.name}`}>
          <button onClick={() => onRemove(file)} className="remove-attachment-btn">
            <FiX size={14} />
          </button>
        </Tooltip>
      </div>
    );
});

const ChatInput = ({ onSendMessage, onStopGeneration, isSending, isThinkingVisible }: ChatInputProps) => {
  const { user, selectedModel } = useSettings();
  const { showNotification } = useNotification();
  const { isThinkingEnabled, toggleThinking } = useChat();
  const [isMenuOpen, setIsMenuOpen] = useState(false);
  const [text, setText] = useState('');
  const [selectedFiles, setSelectedFiles] = useState<File[]>([]);
  const [isDragging, setIsDragging] = useState(false);
  const [isVoiceChatOpen, setIsVoiceChatOpen] = useState(false);
  const isProUser = user?.subscriptionStatus === 'active';
  const voiceTooltip = isProUser ? 'Voice Chat' : 'Voice chat is available for Pro users only';

  const textareaRef = useRef<HTMLTextAreaElement>(null);
  const imageInputRef = useRef<HTMLInputElement>(null);
  const fileInputRef = useRef<HTMLInputElement>(null);
  const menuRef = useRef<HTMLDivElement>(null);
  const plusButtonRef = useRef<HTMLButtonElement>(null);
  const dragCounterRef = useRef(0);

  const hasContent = text.trim().length > 0 || selectedFiles.length > 0;
  const isGenerating = isSending;

  useEffect(() => {
    if (!isMenuOpen) return;
    const handleClickOutside = (event: MouseEvent) => {
      if (
        menuRef.current && !menuRef.current.contains(event.target as Node) &&
        plusButtonRef.current && !plusButtonRef.current.contains(event.target as Node)
      ) {
        setIsMenuOpen(false);
      }
    };
    document.addEventListener('mousedown', handleClickOutside);
    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
    };
  }, [isMenuOpen]);

  const validateAndAddFiles = (files: File[]) => {
    const containsImage = files.some(f => f.type.startsWith('image/'));

    if (containsImage) {
      const modelConfigs = user?.modelConfigs || [];
      const modelConfig = modelConfigs.find(c => c.id === selectedModel);
      const supportsImage = modelConfig?.modalities.includes('image');

      if (!supportsImage) {
        showNotification('This model does not support image inputs. Please select a vision-capable model.', 'error');
        return;
      }
    }

    const remainingSlots = 10 - selectedFiles.length;
    if (remainingSlots <= 0) {
      showNotification('Maximum 10 files allowed', 'error');
      return;
    }

    const filesToAdd = files.slice(0, remainingSlots);
    setSelectedFiles(prev => [...prev, ...filesToAdd]);
    
    if (files.length > remainingSlots) {
      showNotification(`Only ${remainingSlots} file(s) added. Maximum 10 files allowed.`, 'error');
    }
  };

  const handleFileSelect = (event: React.ChangeEvent<HTMLInputElement>) => {
    if (event.target.files) {
      const files = Array.from(event.target.files);
      validateAndAddFiles(files);
    }
    event.target.value = '';
  };

  // Handle paste events
  const handlePaste = (e: React.ClipboardEvent) => {
    const items = Array.from(e.clipboardData.items);
    const files: File[] = [];

    items.forEach(item => {
      if (item.kind === 'file') {
        const file = item.getAsFile();
        if (file) files.push(file);
      }
    });

    if (files.length > 0) {
      e.preventDefault();
      validateAndAddFiles(files);
    }
  };

  // Handle drag events
  const handleDragEnter = (e: React.DragEvent) => {
    e.preventDefault();
    e.stopPropagation();
    dragCounterRef.current++;
    
    if (e.dataTransfer.items && e.dataTransfer.items.length > 0) {
      setIsDragging(true);
    }
  };

  const handleDragLeave = (e: React.DragEvent) => {
    e.preventDefault();
    e.stopPropagation();
    dragCounterRef.current--;
    
    if (dragCounterRef.current === 0) {
      setIsDragging(false);
    }
  };

  const handleDragOver = (e: React.DragEvent) => {
    e.preventDefault();
    e.stopPropagation();
  };

  const handleDrop = (e: React.DragEvent) => {
    e.preventDefault();
    e.stopPropagation();
    setIsDragging(false);
    dragCounterRef.current = 0;

    const files = Array.from(e.dataTransfer.files);
    if (files.length > 0) {
      validateAndAddFiles(files);
    }
  };
  
  const triggerFileInput = (ref: React.RefObject<HTMLInputElement | null>) => {
    if (ref.current) {
      ref.current.click();
    }
    setIsMenuOpen(false);
  };

  const removeFile = (fileToRemove: File) => {
    setSelectedFiles(prev => prev.filter(file => file !== fileToRemove));
  };

  const handleSend = async () => {
    if (!hasContent || isGenerating) return;

    const messageMetadata: Record<string, any> = { isThinkingEnabled: isThinkingVisible };

    try {
      const uploadPromises = selectedFiles.map(file => uploadFile(file));
      const uploadResults = await Promise.all(uploadPromises);
      const newAttachments: Attachment[] = uploadResults.map(result => result.file);
      onSendMessage(text, newAttachments, messageMetadata);
      setText('');
      setSelectedFiles([]);
    } catch (error) {
      showNotification((error as Error).message || 'An error occurred during upload.', 'error');
    }
  };

  const handleKeyDown = (e: React.KeyboardEvent<HTMLTextAreaElement>) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      handleSend();
    }
  };

  const adjustTextareaHeight = () => {
    const textarea = textareaRef.current;
    if (!textarea) return;
    const hiddenDiv = document.createElement('div');
    hiddenDiv.style.position = 'absolute';
    hiddenDiv.style.visibility = 'hidden';
    hiddenDiv.style.height = 'auto';
    hiddenDiv.style.width = `${textarea.clientWidth}px`;
    hiddenDiv.style.fontSize = window.getComputedStyle(textarea).fontSize;
    hiddenDiv.style.fontFamily = window.getComputedStyle(textarea).fontFamily;
    hiddenDiv.style.lineHeight = window.getComputedStyle(textarea).lineHeight;
    hiddenDiv.style.padding = '0';
    hiddenDiv.style.border = 'none';
    hiddenDiv.style.wordWrap = 'break-word';
    hiddenDiv.style.whiteSpace = 'pre-wrap';
    hiddenDiv.textContent = text || '\u200B';
    document.body.appendChild(hiddenDiv);
    const contentHeight = hiddenDiv.scrollHeight;
    document.body.removeChild(hiddenDiv);
    const baseHeight = 24;
    const maxHeight = 120;
    if (contentHeight <= baseHeight) {
      textarea.style.height = `${baseHeight}px`;
      textarea.classList.remove('scrollable');
    } else if (contentHeight <= maxHeight) {
      textarea.style.height = `${contentHeight}px`;
      textarea.classList.remove('scrollable');
    } else {
      textarea.style.height = `${maxHeight}px`;
      textarea.classList.add('scrollable');
    }
  };

  const handleInput = () => { adjustTextareaHeight(); };
  useEffect(() => { adjustTextareaHeight(); }, [text]);
  useEffect(() => {
    if (!text && textareaRef.current) {
      textareaRef.current.style.height = '24px';
      textareaRef.current.classList.remove('scrollable');
    }
  }, [text]);

  return (
    <div 
      className={`chat-input-container ${isDragging ? 'drag-active' : ''}`}
      onDragEnter={handleDragEnter}
      onDragLeave={handleDragLeave}
      onDragOver={handleDragOver}
      onDrop={handleDrop}
    >
      {isProUser && (
        <VoiceChatModal 
          isOpen={isVoiceChatOpen} 
          onClose={() => setIsVoiceChatOpen(false)} 
        />
      )}
      
      {selectedFiles.length > 0 && (
        <div className="attachment-preview-area">
          {selectedFiles.map((file, index) => (
            // --- OPTIMIZATION: Use sub-component for resizing ---
            <AttachmentPreviewItem 
                key={`${file.name}-${index}`} 
                file={file} 
                onRemove={removeFile} 
            />
          ))}
        </div>
      )}

      <div className="chat-input-wrapper">
        <input type="file" ref={imageInputRef} onChange={handleFileSelect} multiple accept="image/*" style={{ display: 'none' }} />
        <input type="file" ref={fileInputRef} onChange={handleFileSelect} multiple style={{ display: 'none' }} />

        <Tooltip text={isThinkingEnabled ? "Disable reasoning" : "Enable reasoning"}>
          <button
            className={`chat-input-button reasoning-button ${isThinkingEnabled ? 'active' : ''}`}
            onClick={toggleThinking}
          >
            <ThinkingIcon className="reasoning-icon" />
          </button>
        </Tooltip>

        <div className="chat-input-divider" />
        
        <button
          ref={plusButtonRef}
          className="chat-input-button"
          onClick={() => setIsMenuOpen(prev => !prev)}
        >
          <FiPlus size={20} />
        </button>
        
        {isMenuOpen && (
          <div ref={menuRef} className="context-menu">
            <button className="context-menu-button" onClick={() => triggerFileInput(imageInputRef)}>
              <FiImage size={20} className="menu-button-icon" />
              <span>Attach Image</span>
            </button>
            <button className="context-menu-button" onClick={() => triggerFileInput(fileInputRef)}>
              <FiPaperclip size={20} className="menu-button-icon" />
              <span>Attach File</span>
            </button>
          </div>
        )}
        
        <textarea
          ref={textareaRef}
          className="chat-input"
          placeholder="Message Workspark"
          value={text}
          onChange={(e) => setText(e.target.value)}
          onKeyDown={handleKeyDown}
          onInput={handleInput}
          onPaste={handlePaste}
          rows={1}
        />
        <div className="chat-input-actions">
          {isGenerating ? (
            <Tooltip text="Stop generating">
              <button
                className="chat-input-button stop-button"
                onClick={onStopGeneration}
              >
                <FiSquare size={18} />
              </button>
            </Tooltip>
          ) : (
            <>
              {!hasContent && (
                <Tooltip text={voiceTooltip}>
                  <button 
                    className={`chat-input-button mic-button ${isProUser ? '' : 'mic-button-disabled'}`}
                    onClick={() => {
                      if (!isProUser) {
                        showNotification('Voice chat is available for Pro users only.', 'error');
                        return;
                      }
                      setIsVoiceChatOpen(true);
                    }}
                    aria-disabled={!isProUser}
                  >
                    <HiOutlineMicrophone size={20} />
                  </button>
                </Tooltip>
              )}
              <button
                className="chat-input-button send-button"
                onClick={handleSend}
                disabled={!hasContent || isGenerating}
              >
                {isSending ? <div className="button-spinner"></div> : <FiSend size={20} />}
              </button>
            </>
          )}
        </div>
      </div>
    </div>
  );
};

export default ChatInput;
- - - ChatMessage.tsx:
// src/components/ChatMessage.tsx
import { useState, useEffect, memo, useMemo, useRef, useCallback } from 'react';
import type { Message, Attachment } from '../types';
import api from '../utils/api';
import '../css/ChatMessage.css';
import '../css/AnalysisBlock.css';
import '../css/SearchBlock.css';
import React from 'react';
import { FiCopy, FiRefreshCw, FiEdit, FiCheck, FiLoader, FiExternalLink, FiSearch } from 'react-icons/fi';
import ImageViewer from './ImageViewer';
import Tooltip from './Tooltip';
import ReactMarkdown from 'react-markdown';
import type { Components } from 'react-markdown';
import { Prism as SyntaxHighlighter } from 'react-syntax-highlighter';
import { vscDarkPlus, oneLight } from 'react-syntax-highlighter/dist/esm/styles/prism';
import CodeAnalysisBlock from './CodeAnalysisBlock';
import InlineThinking from './InlineThinking';
import { getFileIcon } from '../utils/fileIcons';
import remarkGfm from 'remark-gfm';
import remarkMath from 'remark-math';
import rehypeKatex from 'rehype-katex';
import AnalysisBlock from './AnalysisBlock';
import { useNotification } from '../contexts/NotificationContext';
import GeolocationBlock from './GeolocationBlock';
import GeolocationRequestBlock from './GeolocationRequestBlock';
import GoogleMapsBlock from './GoogleMapsBlock';
import StreamingText from './StreamingText';
import { useSidePanel } from '../contexts/SidePanelContext';

interface CodeComponentProps {
  node?: any;
  inline?: boolean;
  className?: string;
  children?: React.ReactNode;
  style?: React.CSSProperties;
  [key: string]: any;
}

// --- HELPER: Client-side Image Resizing ---
const generateThumbnailFromBlob = async (blob: Blob): Promise<string> => {
    return new Promise((resolve) => {
      const img = new Image();
      const url = URL.createObjectURL(blob);
      img.onload = () => {
        const maxWidth = 300;
        const scale = maxWidth / img.width;
        if (scale >= 1) { resolve(url); return; }
        const canvas = document.createElement('canvas');
        canvas.width = maxWidth;
        canvas.height = img.height * scale;
        const ctx = canvas.getContext('2d');
        ctx?.drawImage(img, 0, 0, canvas.width, canvas.height);
        URL.revokeObjectURL(url);
        resolve(canvas.toDataURL(blob.type));
      };
      img.src = url;
    });
};

const useTheme = () => {
    const [theme, setTheme] = useState(() => document.documentElement.getAttribute('data-theme') || 'dark');
    useEffect(() => {
        const observer = new MutationObserver(mutations => {
            for (const mutation of mutations) {
                if (mutation.type === 'attributes' && mutation.attributeName === 'data-theme') {
                    setTheme(document.documentElement.getAttribute('data-theme') || 'dark');
                    break;
                }
            }
        });
        observer.observe(document.documentElement, { attributes: true });
        return () => observer.disconnect();
    }, []);
    return theme;
};

async function copyTextToClipboard(text: string): Promise<boolean> {
  if (navigator.clipboard?.writeText) {
    try { await navigator.clipboard.writeText(text); return true; } catch { }
  }
  const textArea = document.createElement("textarea");
  textArea.value = text;
  textArea.style.position = "fixed"; textArea.style.top = "-9999px";
  document.body.appendChild(textArea);
  textArea.focus(); textArea.select();
  try { return document.execCommand("copy"); } catch { return false; } finally { document.body.removeChild(textArea); }
}

const CustomCode = ({ node, inline, className, children, style, ...props }: CodeComponentProps) => {
  const [isCopied, setIsCopied] = useState(false);
  const theme = useTheme();
  const match = /language-(\w+)/.exec(className || '');
  const codeString = String(children).replace(/\n$/, '');
  const syntaxHighlighterStyle = theme === 'light' ? oneLight : vscDarkPlus;

  const handleCopy = async () => {
    if (await copyTextToClipboard(codeString)) {
      setIsCopied(true);
      setTimeout(() => setIsCopied(false), 2000);
    }
  };

  return !inline && match ? (
    <div className="code-block-wrapper">
      <div className="code-block-header">
        <span className="language-name">{match[1]}</span>
        <button onClick={handleCopy} className="copy-code-button">
          {isCopied ? <FiCheck size={16} /> : <FiCopy size={16} />}
          <span>{isCopied ? 'Copied!' : 'Copy code'}</span>
        </button>
      </div>
      <SyntaxHighlighter style={syntaxHighlighterStyle} language={match[1]} PreTag="div" {...props}>{codeString}</SyntaxHighlighter>
    </div>
  ) : <code className={className} {...props}>{children}</code>;
};

const Paragraph: Components['p'] = ({ node, ...props }) => {
    const child = node?.children[0];
    const childClassName = (child?.type === 'element' && child.properties?.className?.toString()) || '';
    if (node?.children.length === 1 && child?.type === 'element' && (child?.tagName === 'pre' || childClassName.includes('tool-block-container') || childClassName.includes('inline-thinking-container') || childClassName.includes('markdown-image-wrapper') || childClassName.includes('geolocation-request-container') || childClassName.includes('search-indicator'))) {
        return <>{props.children}</>;
    }
    return <p {...props} />;
};

// --- COMPONENT: Local Attachment (Optimistic) with Resizing ---
const LocalAttachmentImage = memo(({ src, fileName, onView }: { src: string, fileName: string, onView: (s: string) => void }) => {
    const [thumbSrc, setThumbSrc] = useState<string | null>(null);

    useEffect(() => {
        let active = true;
        fetch(src).then(r => r.blob()).then(blob => {
            return generateThumbnailFromBlob(blob);
        }).then(thumb => {
            if (active) setThumbSrc(thumb);
        }).catch(() => {
            if (active) setThumbSrc(src);
        });
        return () => { active = false; };
    }, [src]);

    if (!thumbSrc) return <div className="attachment-image-wrapper loading" />;

    return (
        <a href={src} onClick={(e) => { e.preventDefault(); onView(src); }} className="attachment-image-wrapper">
            <img src={thumbSrc} alt={fileName} />
        </a>
    );
});

// --- COMPONENT: Authenticated Image (Server) with Resizing ---
const AuthenticatedImage = memo(({ chatId, attachment, onView }: { chatId: string, attachment: Attachment, onView: (src: string) => void }) => {
    const [thumbUrl, setThumbUrl] = useState<string | null>(null);
    const [fullUrl, setFullUrl] = useState<string | null>(null);
    const [hasError, setHasError] = useState(false);
    const apiEndpoint = attachment._id ? `/files/view/${chatId}/${attachment._id}` : null;

    useEffect(() => {
        if (!apiEndpoint) { setThumbUrl(null); setFullUrl(null); setHasError(false); return; }
        let isMounted = true;
        setHasError(false); 
        
        api(apiEndpoint)
            .then(res => { if (!res.ok) throw new Error(`Server responded with ${res.status}`); return res.blob(); })
            .then(async (blob) => { 
                if (isMounted) { 
                    const full = URL.createObjectURL(blob);
                    setFullUrl(full);
                    const thumb = await generateThumbnailFromBlob(blob);
                    if (isMounted) setThumbUrl(thumb);
                }
            })
            .catch(() => { if (isMounted) setHasError(true); });
            
        return () => { 
            isMounted = false; 
            if (fullUrl) URL.revokeObjectURL(fullUrl); 
        };
    }, [apiEndpoint, attachment.fileName]);

    if (hasError) return <div className="attachment-image-wrapper error"><span>Error Loading Image</span></div>;
    if (!thumbUrl || !fullUrl) return <div className="attachment-image-wrapper loading" />;

    return (
        <a href={fullUrl} onClick={(e) => { e.preventDefault(); onView(fullUrl); }} className="attachment-image-wrapper">
            <img src={thumbUrl} alt={attachment.fileName} />
        </a>
    );
});

// Reusable styles for the link button
const linkButtonStyle: React.CSSProperties = {
    display: 'inline-flex',
    alignItems: 'center',
    justifyContent: 'center',
    marginLeft: '4px',
    padding: '4px',
    borderRadius: '6px',
    backgroundColor: 'var(--bg-secondary, rgba(128, 128, 128, 0.1))',
    border: '1px solid var(--border-color, rgba(128, 128, 128, 0.2))',
    color: 'var(--text-primary, inherit)',
    verticalAlign: 'middle',
    lineHeight: 0,
    cursor: 'pointer',
    transition: 'background-color 0.2s',
    fontSize: '0.8em',
    textDecoration: 'none'
};

// --- Helper Functions for Search Result Parsing ---
const parseSearchMarkdown = (content: string) => {
  if (!content) return [];
  const sources = [];
  const regex = /\*\*(.*?)\*\*\n\*Source: (.*?)\*\n\n> (.*?)(?=\n\n---|\n*$)/gs;
  let match;
  while ((match = regex.exec(content)) !== null) {
    sources.push({
      title: match[1].trim(),
      url: match[2].trim(),
      snippet: match[3].trim()
    });
  }
  return sources;
};

const cleanSearchQuery = (rawContent: string) => {
    if (!rawContent) return '';
    try {
        const parsed = JSON.parse(rawContent);
        if (parsed.query) return parsed.query;
    } catch (e) {
        return rawContent.replace(/^"|"$/g, '');
    }
    return rawContent;
};

type AssistantTurnProps = { 
  messages: Message[];
  chatId: string | null;
  startIndex: number;
  isStreaming: boolean;
  isThinking: boolean;
  onRegenerate: () => void;
  onCopy: (content: string) => void;
  onView: (src: string) => void; 
};

const AssistantTurn = memo(({ messages, chatId, startIndex, isStreaming, isThinking, onRegenerate, onCopy, onView }: AssistantTurnProps) => {
    const { openPanel } = useSidePanel();
    
    const ImageRenderer: Components['img'] = ({ src, alt }) => {
        if (!src) return null;
        return (
            <a href={src} onClick={(e) => { e.preventDefault(); onView(src); }} className="markdown-image-wrapper">
                <img src={src} alt={alt || 'image from message'} />
            </a>
        );
    };

    const LinkRenderer: Components['a'] = ({ href, children }) => {
        if (!href) return <>{children}</>;
        
        // Handle Images
        const isImage = href.match(/\.(jpeg|jpg|gif|png|bmp|webp)($|\?)/i);
        if (isImage) {
            return (
                <a href={href} onClick={(e) => { e.preventDefault(); onView(href); }} className="markdown-image-wrapper">
                    <img src={href} alt={String(children) || 'generated image'} />
                </a>
            );
        }

        // Handle Text Links
        const linkText = String(children);
        const isRawUrl = linkText.startsWith('http') || linkText.startsWith('www.') || linkText.length > 30;

        // If it's a raw long URL, replace text with just the button
        if (isRawUrl) {
            return (
                <Tooltip text={href}>
                    <a 
                        href={href} 
                        target="_blank" 
                        rel="noopener noreferrer" 
                        className="chat-link-icon-only"
                        aria-label="Open Link"
                    >
                        <FiExternalLink size={16} />
                    </a>
                </Tooltip>
            );
        }

        // For named links like [Click Here](url), keep text + small icon
        return (
            <span className="link-container">
                <a href={href} target="_blank" rel="noopener noreferrer" className="chat-link-text">
                    {children}
                </a>
                <Tooltip text={href}>
                    <a href={href} target="_blank" rel="noopener noreferrer" style={linkButtonStyle} className="chat-link-button">
                        <FiExternalLink size={12} />
                    </a>
                </Tooltip>
            </span>
        );
    };
    
    const { turnParts, fullContent, lastMessageInTurnIndex, accumulatedSources } = useMemo(() => {
        const parts: React.ReactNode[] = [];
        const textParts: string[] = [];
        let lastIndex = startIndex;
        const processedToolIds = new Set<string>();
        let currentTextBuffer = '';
        const sources: any[] = [];

        const flushTextBuffer = (key: string) => {
            if (currentTextBuffer.trim()) {
                const isLastGlobalMessage = lastIndex === messages.length - 1;
                const isCurrentlyStreaming = isStreaming && isLastGlobalMessage && key.includes('final');
                
                parts.push(
                    <StreamingText
                        key={key}
                        content={currentTextBuffer}
                        isStreaming={isCurrentlyStreaming}
                        components={{ code: CustomCode, p: Paragraph, img: ImageRenderer, a: LinkRenderer }}
                    />
                );
            }
            currentTextBuffer = '';
        };

        for (let i = startIndex; i < messages.length; i++) {
            const currentMessage = messages[i];
            if (currentMessage.role === 'user') { lastIndex = i - 1; break; }

            if (currentMessage.role === 'assistant') {
                if (currentMessage.thinking) {
                    flushTextBuffer(`text-before-thinking-${i}`);
                    parts.push(<InlineThinking key={`thinking-${i}`} content={currentMessage.thinking} isStreaming={isThinking && i === messages.length - 1} />);
                }
                if (currentMessage.content) {
                    currentTextBuffer += currentMessage.content;
                    textParts.push(currentMessage.content);
                }
            } else if (currentMessage.tool_id && !processedToolIds.has(currentMessage.tool_id)) {
                const toolType = currentMessage.role;
                const resultRole = toolType + '_result' as Message['role'];
                const outputMessage = messages.find(m => m.role === resultRole && m.tool_id === currentMessage.tool_id);
                const state = currentMessage.state || (outputMessage ? 'completed' : 'writing');

                if (toolType === 'tool_code') {
                    flushTextBuffer(`text-before-code-${i}`);
                    parts.push(<CodeAnalysisBlock key={`code-${currentMessage.tool_id}`} chatId={chatId} toolCodeMessage={currentMessage} toolOutputMessage={outputMessage} onView={onView} />);
                } else if (toolType === 'tool_search') {
                    const queryText = cleanSearchQuery(currentMessage.content || '');
                    
                    flushTextBuffer(`text-before-search-${i}`);
                    parts.push(
                        <div key={`search-indicator-${currentMessage.tool_id}`} className="search-indicator">
                            <div className="search-icon-wrapper"><FiSearch size={14} /></div>
                            <span className="search-text">
                                {state === 'writing' || state === 'searching' ? 'Searching for ' : 'Searched for '} 
                                "{queryText}"
                            </span>
                        </div>
                    );

                    if (outputMessage && !outputMessage.content?.includes('[LOCATION]')) {
                        const newSources = parseSearchMarkdown(outputMessage.content || '');
                        if(newSources.length > 0) sources.push(...newSources);
                    } else if (outputMessage && outputMessage.content?.includes('[LOCATION]')) {
                        flushTextBuffer(`text-before-geo-${i}`);
                        parts.push(<GeolocationBlock key={`geo-${currentMessage.tool_id}`} toolMessage={currentMessage} outputMessage={outputMessage} />);
                    }
                } else if (toolType === 'tool_doc_extract') {
                    flushTextBuffer(`text-before-extract-${i}`);
                    parts.push(<AnalysisBlock key={`extract-${currentMessage.tool_id}`} toolMessage={currentMessage} outputMessage={outputMessage} />);
                } else if (toolType === 'tool_geolocation') {
                    flushTextBuffer(`text-before-geo-req-${i}`);
                    // --- START OF FIX: Logic to hide request block if result exists ---
                    const hasResult = messages.some(m => m.role === 'tool_geolocation_result' && m.tool_id === currentMessage.tool_id);
                    if (!hasResult) {
                        parts.push(<GeolocationRequestBlock key={`geo-req-${currentMessage.tool_id}`} toolMessage={currentMessage} />);
                    }
                    // --- END OF FIX ---
                } else if (toolType === 'tool_integration' || toolType === 'tool_integration_result') {
                    flushTextBuffer(`text-before-int-${i}`);
                    const data = outputMessage?.integrationData || (currentMessage.role === 'tool_integration_result' ? currentMessage.integrationData : null);
                    if (data?.type === 'google_maps_route') {
                        parts.push(<GoogleMapsBlock key={`maps-${currentMessage.tool_id}`} integrationData={data} />);
                    }
                }
                processedToolIds.add(currentMessage.tool_id);
            }
            lastIndex = i;
        }
        flushTextBuffer('text-final');
        
        return { turnParts: parts, fullContent: textParts.join('\n\n'), lastMessageInTurnIndex: lastIndex, accumulatedSources: sources };
    }, [messages, chatId, startIndex, isStreaming, onView, isThinking]);

    const isStreamingInThisTurn = isStreaming && (messages.length - 1 <= lastMessageInTurnIndex);
    const showSources = accumulatedSources.length > 0 && !isStreamingInThisTurn;

    return (
        <div className={`chat-message-wrapper assistant ${isStreamingInThisTurn ? 'is-streaming' : ''}`}>
            <div className="chat-message-container">
                <div className="message-content-wrapper">
                    <div className={`message-content ${isStreamingInThisTurn ? 'is-streaming' : 'streaming-complete'}`}>
                        {turnParts}
                        {isStreamingInThisTurn && <span className="streaming-cursor"></span>}
                    </div>
                    
                    {/* FOOTER ACTIONS ROW */}
                    {!isStreamingInThisTurn && (fullContent || showSources) && (
                        <div className="message-actions">
                            {/* Standard Actions First */}
                            <div className="action-buttons-group" style={{ display: 'flex', gap: '0.5rem' }}>
                                <Tooltip text="Regenerate"><button className="action-button" onClick={onRegenerate}><FiRefreshCw size={16} /></button></Tooltip>
                                <Tooltip text="Copy"><button className="action-button" onClick={() => onCopy(fullContent)}><FiCopy size={16} /></button></Tooltip>
                            </div>

                            {showSources && (
                                <button className="sources-trigger" onClick={() => openPanel('sources', { sources: accumulatedSources })}>
                                    {accumulatedSources.slice(0, 3).map((s: any, i: number) => (
                                        <img 
                                            key={i} 
                                            className="source-favicon-stack"
                                            src={`https://www.google.com/s2/favicons?domain=${new URL(s.url).hostname}&sz=32`} 
                                            alt=""
                                            onError={(e) => (e.target as HTMLImageElement).style.display = 'none'}
                                        />
                                    ))}
                                    <span className="sources-count">{accumulatedSources.length} Sources</span>
                                </button>
                            )}
                        </div>
                    )}
                </div>
            </div>
        </div>
    );
});


interface ChatMessageProps {
  message: Message;
  messages: Message[];
  chatId: string | null;
  index: number;
  isEditing: boolean;
  isStreaming: boolean;
  isThinking: boolean;
  onRegenerate: () => void;
  onCopy: (content: string) => void;
  onStartEdit: (index: number) => void;
  onSaveEdit: (index: number, newContent: string, metadata?: Record<string, any>) => void;
  onCancelEdit: () => void;
}

const ChatMessage = ({ message, messages, chatId, index, isEditing, isStreaming, isThinking, onStartEdit, onSaveEdit, onCancelEdit, ...rest }: ChatMessageProps) => {
  const { showNotification } = useNotification();
  const [editedContent, setEditedContent] = useState(message.content || '');
  const [viewerSrc, setViewerSrc] = useState<string | null>(null);
  const [isViewerOpen, setIsViewerOpen] = useState(false);
  const editTextAreaRef = useRef<HTMLTextAreaElement>(null);
  const [downloadingId, setDownloadingId] = useState<string | null>(null);

  const handleDownloadAttachment = async (e: React.MouseEvent<HTMLAnchorElement>, attachment: Attachment) => {
    e.preventDefault();
    if (downloadingId) return; 

    if (!chatId || !attachment._id) {
      showNotification('Cannot download file: Missing identifiers.', 'error');
      return;
    }

    setDownloadingId(attachment._id); 

    try {
      const response = await api(`/files/view/${chatId}/${attachment._id}`);
      if (!response.ok) {
        const errorData = await response.json().catch(() => ({ msg: 'Download failed' }));
        throw new Error(errorData.msg || `Server responded with ${response.status}`);
      }
      
      const blob = await response.blob();
      const url = window.URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.setAttribute('download', attachment.fileName);
      
      document.body.appendChild(link);
      link.click();
      
      link.parentNode?.removeChild(link);
      window.URL.revokeObjectURL(url);

    } catch (error) {
      showNotification(error instanceof Error ? error.message : 'Could not download file.', 'error');
    } finally {
      setDownloadingId(null); 
    }
  };

  useEffect(() => {
    if (isEditing) setEditedContent(message.content || '');
  }, [isEditing, message.content]);

  useEffect(() => {
    if (isEditing && editTextAreaRef.current) {
      const ta = editTextAreaRef.current;
      ta.focus(); ta.setSelectionRange(ta.value.length, ta.value.length);
      setTimeout(() => { ta.style.height = 'auto'; ta.style.height = `${Math.min(ta.scrollHeight, 400)}px`; }, 0);
    }
  }, [isEditing]);

  const handleOpenViewer = useCallback((src: string) => { setViewerSrc(src); setIsViewerOpen(true); }, []);

  const renderAttachments = (attachments: Attachment[]) => (
    <div className="message-attachments">
        {attachments.map((att, idx) => {
            const isImage = att.mimeType.startsWith('image/');
            const url = (att as any).url || `/api/files/view/${chatId}/${att._id}`;
            if(isImage) {
                 if((att as any).url) return <LocalAttachmentImage key={idx} src={url} fileName={att.fileName} onView={handleOpenViewer} />;
                 return <AuthenticatedImage key={idx} chatId={chatId!} attachment={att} onView={handleOpenViewer} />;
            }
            return (
                <a key={idx} href={url} onClick={(e) => { if(!Boolean(chatId && att._id)) { e.preventDefault(); return; } handleDownloadAttachment(e, att); }} className={`attachment-file-link ${downloadingId === att._id ? 'downloading' : ''}`}>
                    <span className="attachment-file-icon">{downloadingId === att._id ? <FiLoader className="spinner-icon" /> : getFileIcon(att.mimeType)}</span>
                    <span className="attachment-file-name">{downloadingId === att._id ? 'Downloading...' : att.fileName}</span>
                </a>
            );
        })}
    </div>
  );

  if (message.role === 'user') {
    return (
        <div className={`chat-message-wrapper user ${isEditing ? 'editing' : ''}`}>
          <div className="chat-message-container">
            <div className="user-message-bubble">
              {!isEditing ? (
                <div className="message-content">
                  {message.attachments && message.attachments.length > 0 && renderAttachments(message.attachments)}
                  {message.content && <ReactMarkdown remarkPlugins={[remarkGfm, remarkMath]} rehypePlugins={[rehypeKatex]} components={{ code: CustomCode, p: Paragraph }}>{message.content}</ReactMarkdown>}
                </div>
              ) : (
                <div className="message-editor-content">
                    <textarea ref={editTextAreaRef} value={editedContent} onChange={(e) => setEditedContent(e.target.value)} rows={1} />
                    <div className="editor-actions">
                        <button className="editor-button cancel" onClick={onCancelEdit}>Cancel</button>
                        <button className="editor-button save" onClick={() => onSaveEdit(index, editedContent)}>Save</button>
                    </div>
                </div>
              )}
            </div>
            {!isEditing && <div className="message-actions"><Tooltip text="Edit"><button className="action-button" onClick={() => onStartEdit(index)}><FiEdit size={16} /></button></Tooltip></div>}
          </div>
        </div>
    );
  }

  const isStartOfTurn = index === 0 || messages[index - 1]?.role === 'user';
  if (isStartOfTurn) {
    return (
      <>
        <AssistantTurn chatId={chatId} messages={messages} startIndex={index} isStreaming={isStreaming} isThinking={isThinking} {...rest} onView={handleOpenViewer} />
        <ImageViewer isOpen={isViewerOpen} src={viewerSrc} alt={viewerSrc || ''} onClose={() => setIsViewerOpen(false)} />
      </>
    );
  }
  return null;
};

export default memo(ChatMessage);
- - - ChatView.tsx:
// src/components/ChatView.tsx
import { useEffect, useRef, useState, useCallback } from 'react';
import type { Message, Attachment } from '../types';
import ChatInput from './ChatInput';
import ChatMessage from './ChatMessage';
import { useNotification } from '../contexts/NotificationContext';
import ModelSelector from './ModelSelector';
import '../css/ChatView.css';
import Tooltip from './Tooltip';

interface ChatViewProps {
  messages: Message[];
  activeChatId: string | null;
  isStreaming: boolean;
  isThinking: boolean;
  isLoading: boolean;
  isSending: boolean;
  onSendMessage: (text: string, attachments: Attachment[], metadata?: Record<string, any>) => void;
  onStopGeneration: () => void; // <-- NEW
  editingIndex: number | null;
  onStartEdit: (index: number) => void;
  onCancelEdit: () => void;
  onSaveEdit: (index: number, newContent: string, metadata?: Record<string, any>) => void;
  onRegenerate: (metadata?: Record<string, any>) => void;
  isThinkingEnabled: boolean;
  toggleThinkingEnabled : () => void;
}

const ChatView = (props: ChatViewProps) => {
  const { 
    messages, activeChatId, isStreaming, isThinking, isLoading, isSending, onSendMessage, 
    onStopGeneration, // <-- NEW
    editingIndex, onStartEdit, onCancelEdit, 
    onSaveEdit, onRegenerate, isThinkingEnabled
  } = props;

  const chatContentRef = useRef<HTMLDivElement>(null);
  const { showNotification } = useNotification();
  const [isReady, setIsReady] = useState(false);
  const [showScrollToBottom, setShowScrollToBottom] = useState(false);

  useEffect(() => {
    const timer = setTimeout(() => setIsReady(true), 100);
    return () => clearTimeout(timer);
  }, []);

  useEffect(() => {
    if (chatContentRef.current && !showScrollToBottom) {
      chatContentRef.current.scrollTop = chatContentRef.current.scrollHeight;
    }
  }, [messages, isLoading, showScrollToBottom, isStreaming, isThinking]);

  useEffect(() => {
    const chatContent = chatContentRef.current;
    if (!chatContent) return;
    const handleScroll = () => {
      const { scrollTop, scrollHeight, clientHeight } = chatContent;
      const isScrolledUp = scrollHeight - scrollTop - clientHeight > 300;
      setShowScrollToBottom(isScrolledUp);
    };
    chatContent.addEventListener('scroll', handleScroll, { passive: true });
    return () => chatContent.removeEventListener('scroll', handleScroll);
  }, []);

  const handleCopy = useCallback((content: string) => {
    navigator.clipboard.writeText(content).then(() => showNotification("Copied!"));
  }, [showNotification]);

  const scrollToBottom = () => {
    chatContentRef.current?.scrollTo({ top: chatContentRef.current.scrollHeight, behavior: 'smooth' });
  };

  const handleSendMessage = (text: string, attachments: Attachment[]) => {
    onSendMessage(text, attachments);
  };
  
  const handleRegenerate = () => {
    onRegenerate();
  };

  return (
    <div className={`chat-view-container ${messages.length === 0 ? 'is-empty' : ''} ${isReady ? 'is-ready' : ''}`}>
      <header className="chat-view-header">
        <ModelSelector />
      </header>
      
      <main className="chat-view">
        {isLoading && (
          <div className="loading-overlay">
            <div className="bouncing-loader"><div></div><div></div><div></div></div>
          </div>
        )}
        
        <div className="chat-content" ref={chatContentRef}>
          <div className="chat-messages-list">
            {messages.filter(msg => msg != null).map((msg, index) => {
              return (
                <ChatMessage
                  key={activeChatId ? `${activeChatId}-${index}` : index}
                  index={index}
                  message={msg}
                  messages={messages}
                  chatId={activeChatId}
                  isEditing={editingIndex === index}
                  isStreaming={isStreaming}
                  isThinking={isThinking}
                  onRegenerate={handleRegenerate}
                  onCopy={handleCopy}
                  onStartEdit={onStartEdit}
                  onSaveEdit={onSaveEdit}
                  onCancelEdit={onCancelEdit}
                />
              );
            })}
          </div>
        </div>

        <div className="chat-input-area">
          <div className="empty-chat-container">
            <h1>How can I help you?</h1>
          </div>

          {showScrollToBottom && !isStreaming && messages.length > 0 && (
            <Tooltip text="Scroll to latest message">
              <button className="scroll-to-bottom" onClick={scrollToBottom}>
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5" strokeLinecap="round" strokeLinejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
              </button>
            </Tooltip>
          )}
          <ChatInput 
            onSendMessage={handleSendMessage} 
            onStopGeneration={onStopGeneration}
            isSending={isSending || isStreaming}
            isThinkingVisible={isThinkingEnabled}
          />
        </div>
      </main>
    </div>
  );
};

export default ChatView;
- - - CodeAnalysisBlock.tsx:
// src/components/CodeAnalysisBlock.tsx
import { useState, useMemo, memo } from 'react';
import { FiChevronDown, FiDownload, FiFileText, FiCheck, FiCopy } from 'react-icons/fi';
import { Prism as SyntaxHighlighter } from 'react-syntax-highlighter';
import { vscDarkPlus, oneLight } from 'react-syntax-highlighter/dist/esm/styles/prism';
import type { Message, FileOutput } from '../types';
import '../css/CodeAnalysisBlock.css';
import { useNotification } from '../contexts/NotificationContext';
import { useSettings } from '../contexts/SettingsContext';

interface CodeAnalysisBlockProps {
  chatId: string | null;
  toolCodeMessage: Message;
  toolOutputMessage?: Message;
  onView: (src: string) => void;
}

const CodeAnalysisBlock = ({ toolCodeMessage, toolOutputMessage, onView }: CodeAnalysisBlockProps) => {
  const [isExpanded, setIsExpanded] = useState(false);
  const [isCopied, setIsCopied] = useState(false);
  const { showNotification } = useNotification();
  const { theme } = useSettings();

  const state = toolCodeMessage.state || 'writing';
  const code = toolCodeMessage.content || '';
  const hasError = state === 'error';
  const output = toolOutputMessage?.content || '';
  const fileOutputs = toolOutputMessage?.fileOutputs || [];

  const isPending = state === 'writing' || state === 'executing';

  const syntaxTheme = theme === 'light' ? oneLight : vscDarkPlus;

  const handleCopy = async (e: React.MouseEvent) => {
    e.stopPropagation();
    await navigator.clipboard.writeText(code);
    setIsCopied(true);
    setTimeout(() => setIsCopied(false), 2000);
  };

  const handleDownload = async (e: React.MouseEvent, fileOutput: FileOutput) => {
    e.stopPropagation(); // Prevent accordion toggle
    try {
      const link = document.createElement('a');
      link.href = fileOutput.url;
      link.setAttribute('download', fileOutput.fileName);
      link.target = '_blank';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    } catch (error) {
      window.open(fileOutput.url, '_blank');
      showNotification('Could not download file', 'error');
    }
  };

  const handlePreviewClick = (e: React.MouseEvent, url: string) => {
    e.stopPropagation(); // Prevent accordion toggle
    onView(url);
  };

  const label = useMemo(() => {
    if (isPending) return 'Analyzing...';
    if (state === 'error') return 'Analysis Failed';
    return 'Analyzed';
  }, [state, isPending]);

  return (
    <div className={`code-analysis-container ${state} ${isExpanded ? 'expanded' : ''}`}>
      {/* Header */}
      <div className="analysis-header" onClick={() => setIsExpanded(!isExpanded)}>
        <div className="analysis-header-content">
          <div className="analysis-header-left">
            <span className={`analysis-label ${isPending ? 'animate-shine' : ''}`}>{label}</span>
          </div>
          <FiChevronDown className="chevron-icon" />
        </div>

        {/* --- NEW: File Preview Strip (Visible when collapsed) --- */}
        {!isExpanded && fileOutputs.length > 0 && (
          <div className="analysis-file-preview">
            {fileOutputs.map((f, i) => (
              f.mimeType.startsWith('image/') ? (
                <div 
                  key={i} 
                  className="preview-item image" 
                  onClick={(e) => handlePreviewClick(e, f.url)}
                  title={f.fileName}
                >
                  <img src={f.url} alt={f.fileName} />
                </div>
              ) : (
                <div 
                  key={i} 
                  className="preview-item file" 
                  onClick={(e) => handleDownload(e, f)}
                  title={`Download ${f.fileName}`}
                >
                  <div className="file-icon-wrapper">
                    <FiFileText size={14} />
                  </div>
                  <span className="preview-filename">{f.fileName}</span>
                </div>
              )
            ))}
          </div>
        )}
      </div>

      {/* Expanded Content */}
      {isExpanded && (
        <div className="analysis-content">
          <div className="code-block-header">
            <span className="lang-label">python</span>
            <button className="copy-btn" onClick={handleCopy}>
              {isCopied ? <><FiCheck size={12} /> Copied</> : <><FiCopy size={12} /> Copy code</>}
            </button>
          </div>
          
          <div className="code-wrapper">
            <SyntaxHighlighter
              style={syntaxTheme}
              language="python"
              PreTag="div"
              wrapLines={true}
              wrapLongLines={true}
              customStyle={{ margin: 0, padding: '1rem', background: 'transparent', fontSize: '0.9rem' }}
            >
              {code}
            </SyntaxHighlighter>
          </div>

          {(output || fileOutputs.length > 0) && (
            <div className="console-output">
              <div className="console-header">Output</div>
              {output && <pre className={`console-text ${hasError ? 'error' : ''}`}>{output}</pre>}
              
              {/* Full File List in Expanded View */}
              {fileOutputs.length > 0 && (
                <div className="console-files">
                  {fileOutputs.map((f, i) => (
                    f.mimeType.startsWith('image/') ? (
                      <div key={i} className="console-image" onClick={() => onView(f.url)}>
                        <img src={f.url} alt={f.fileName} />
                      </div>
                    ) : (
                      <div key={i} className="console-file">
                        <FiFileText /> <span>{f.fileName}</span>
                        <button onClick={(e) => handleDownload(e, f)}><FiDownload /></button>
                      </div>
                    )
                  ))}
                </div>
              )}
            </div>
          )}
        </div>
      )}
    </div>
  );
};

export default memo(CodeAnalysisBlock);
- - - ConfirmationModal.tsx:
// src/components/ConfirmationModal.tsx
import { FiHelpCircle } from 'react-icons/fi';
import '../css/ConfirmationModal.css';

interface ConfirmationModalProps {
  isOpen: boolean;
  onClose: () => void;
  onConfirm: () => void;
  title: string;
  message: string;
  confirmText?: string;
  cancelText?: string;
  isDestructive?: boolean;
}

const ConfirmationModal = ({
  isOpen,
  onClose,
  onConfirm,
  title,
  message,
  confirmText = "Confirm",
  cancelText = "Cancel",
  isDestructive = false
}: ConfirmationModalProps) => {
  if (!isOpen) return null;

  return (
    <div className="confirm-modal-overlay" onClick={onClose}>
      <div className="confirm-modal-content" onClick={(e) => e.stopPropagation()}>
        <div className="confirm-modal-header">
          <FiHelpCircle size={22} className="confirm-modal-icon" />
          <h3>{title}</h3>
        </div>
        <p>{message}</p>
        <div className="confirm-modal-actions">
          <button className="confirm-modal-button cancel" onClick={onClose}>
            {cancelText}
          </button>
          <button
            className={`confirm-modal-button confirm ${isDestructive ? 'destructive' : ''}`}
            onClick={onConfirm}
          >
            {confirmText}
          </button>
        </div>
      </div>
    </div>
  );
};

export default ConfirmationModal;
- - - CustomModelSelector.tsx:
import { useState, useRef, useEffect, FC } from 'react';
import { FiChevronDown, FiCheck } from 'react-icons/fi';
import '../css/CustomModelSelector.css';

type Model = {
  id: string;
};

interface CustomModelSelectorProps {
  models: Model[];
  selectedModel: string;
  onSelect: (modelId: string) => void;
  disabled: boolean;
  placeholderText?: string;
}

const CustomModelSelector: FC<CustomModelSelectorProps> = ({ models, selectedModel, onSelect, disabled, placeholderText }) => {
  const [isOpen, setIsOpen] = useState(false);
  const selectorRef = useRef<HTMLDivElement>(null);

  const handleSelect = (modelId: string) => {
    onSelect(modelId);
    setIsOpen(false);
  };
  
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (selectorRef.current && !selectorRef.current.contains(event.target as Node)) {
        setIsOpen(false);
      }
    };
    document.addEventListener('mousedown', handleClickOutside);
    return () => document.removeEventListener('mousedown', handleClickOutside);
  }, []);

  const currentModelName = models.find(m => m.id === selectedModel)?.id || selectedModel || placeholderText || 'Select a model';

  return (
    <div className="custom-model-selector" ref={selectorRef}>
      <button 
        className="custom-model-selector-button" 
        onClick={() => setIsOpen(!isOpen)}
        disabled={disabled}
      >
        <span className="selected-model-name">{currentModelName}</span>
        <FiChevronDown size={20} className={`chevron-icon ${isOpen ? 'open' : ''}`} />
      </button>

      {isOpen && !disabled && (
        <div className="custom-model-selector-dropdown">
          {models.length > 0 ? (
            models.map(model => (
              <div 
                key={model.id}
                className={`model-dropdown-item ${selectedModel === model.id ? 'selected' : ''}`}
                onClick={() => handleSelect(model.id)}
              >
                <span>{model.id}</span>
                {selectedModel === model.id && <FiCheck size={16} className="checkmark-icon" />}
              </div>
            ))
          ) : (
             <div className="model-dropdown-item empty">
                {placeholderText || 'No models available'}
             </div>
          )}
        </div>
      )}
    </div>
  );
};

export default CustomModelSelector;
- - - GeolocationBlock.tsx:
// src/components/GeolocationBlock.tsx
import { useMemo, memo } from 'react';
import { FiMapPin } from 'react-icons/fi';
import type { Message } from '../types';
import '../css/GeolocationBlock.css';
import '../css/SearchBlock.css'; // Re-use common styles

interface GeolocationBlockProps {
  toolMessage: Message;
  outputMessage?: Message;
}

type ParsedLocation = {
  lat: string;
  lon: string;
  title: string;
};

const GeolocationBlock = memo(({ outputMessage }: GeolocationBlockProps) => {
  const output = outputMessage?.content || '';

  const location = useMemo((): ParsedLocation | null => {
    if (!output.includes('[LOCATION]')) return null;
    const match = /\[LOCATION lat="([^"]+)" lon="([^"]+)" title="([^"]+)"\]/g.exec(output);
    if (!match) return null;
    return { lat: match[1], lon: match[2], title: match[3] };
  }, [output]);

  if (!location) {
    return null;
  }
  
  const mapUrl = `https://www.google.com/maps?q=${location.lat},${location.lon}&hl=en&z=14&output=embed`;

  return (
    <div className="tool-block-container geolocation-container">
        <div className="tool-block-header">
            <div className="status">
                <div className="status-icon-wrapper"><FiMapPin /></div>
                <span>Location: {location.title}</span>
            </div>
        </div>
        <div className="geolocation-map-wrapper">
            <iframe
                title={`Map of ${location.title}`}
                width="100%"
                height="300"
                style={{ border: 0 }}
                loading="lazy"
                allowFullScreen
                src={mapUrl}>
            </iframe>
        </div>
    </div>
  );
});

export default GeolocationBlock;
- - - GeolocationRequestBlock.tsx:
// src/components/GeolocationRequestBlock.tsx
import { memo, useState } from 'react';
import { FiMapPin, FiX, FiCheck } from 'react-icons/fi';
import { useChat } from '../contexts/ChatContext';
import type { Message } from '../types';
import '../css/GeolocationRequestBlock.css';

interface GeolocationRequestBlockProps {
  toolMessage: Message;
}

const GeolocationRequestBlock = memo(({ toolMessage }: GeolocationRequestBlockProps) => {
  const { sendGeolocationResult, activeChatId } = useChat();
  // State to control visibility - defaults to true, becomes false immediately on interaction
  const [isVisible, setIsVisible] = useState(true);

  const handleAllow = () => {
    // 1. Hide the UI immediately
    setIsVisible(false);
    
    // 2. Perform logic in background
    if (!navigator.geolocation) {
      sendGeolocationResult(activeChatId!, toolMessage.tool_id!, { error: 'Geolocation not supported by client.' });
      return;
    }
    
    navigator.geolocation.getCurrentPosition(
      (position) => {
        const { latitude, longitude } = position.coords;
        sendGeolocationResult(activeChatId!, toolMessage.tool_id!, {
          coordinates: { latitude, longitude }
        });
      },
      (geoError) => {
        let errorMessage = 'An unknown error occurred.';
        switch(geoError.code) {
          case geoError.PERMISSION_DENIED:
            errorMessage = "You denied the request for Geolocation.";
            break;
          case geoError.POSITION_UNAVAILABLE:
            errorMessage = "Location information is unavailable.";
            break;
          case geoError.TIMEOUT:
            errorMessage = "The request to get user location timed out.";
            break;
        }
        sendGeolocationResult(activeChatId!, toolMessage.tool_id!, { error: errorMessage });
      }
    );
  };

  const handleDeny = () => {
    // 1. Hide the UI immediately
    setIsVisible(false);
    
    // 2. Send denial to backend
    const errorMessage = "User denied geolocation access.";
    sendGeolocationResult(activeChatId!, toolMessage.tool_id!, { error: errorMessage });
  };

  // If the user has clicked a button, render nothing
  if (!isVisible) return null;

  return (
    <div className="geolocation-wrapper">
        {/* The text request bubble */}
        <div className="geo-content-card">
            <div className="geo-icon-circle">
                <FiMapPin size={16} />
            </div>
            <div className="geo-text-content">
                <span className="geo-text">The AI needs your location to provide directions.</span>
            </div>
        </div>

        {/* Buttons Row - Below the card */}
        <div className="geo-actions-row">
            <button className="geo-square-btn deny" onClick={handleDeny} aria-label="Deny">
                <FiX size={20} />
            </button>
            <button className="geo-square-btn allow" onClick={handleAllow} aria-label="Allow">
                <FiCheck size={20} />
            </button>
        </div>
    </div>
  );
});

export default GeolocationRequestBlock;
- - - GoogleMapsBlock.tsx:
// src/components/GoogleMapsBlock.tsx
import { memo, useMemo, useState, useCallback } from 'react';
import { GoogleMap, useLoadScript, Marker, Polyline, TrafficLayer } from '@react-google-maps/api';
import { FiMap, FiNavigation, FiClock, FiMapPin, FiMaximize2, FiMinimize2, FiLayers, FiEye, FiNavigation2, FiAlertTriangle, FiPlay } from 'react-icons/fi';
import type { GoogleMapsData } from '../types';
import { useNavigation } from '../contexts/NavigationContext';
import NavigationPanel from './NavigationPanel';
import type { NavigationStep } from '../utils/navigationHelpers';
import '../css/AnalysisBlock.css';
import '../css/GoogleMapsBlock.css';

interface GoogleMapsBlockProps {
  integrationData: GoogleMapsData;
}

// Use a stable superset of libraries to avoid reloading the script with different URLs across routes
const LIBRARIES: ("geometry" | "places" | "drawing" | "visualization" | "marker")[] = ['geometry', 'places', 'marker'];

const mapContainerStyle = {
  height: '100%',
  width: '100%',
};

type MapType = 'roadmap' | 'satellite' | 'hybrid' | 'terrain';

const CIRCLE_MARKER_ICON_START = {
  path: 0, // google.maps.SymbolPath.CIRCLE
  scale: 10,
  fillColor: "#4285F4",
  fillOpacity: 1,
  strokeColor: "#ffffff",
  strokeWeight: 2,
};

const CIRCLE_MARKER_ICON_END = {
  path: 0, // google.maps.SymbolPath.CIRCLE
  scale: 10,
  fillColor: "#EA4335",
  fillOpacity: 1,
  strokeColor: "#ffffff",
  strokeWeight: 2,
};

// This function is kept as a fallback in case the Google geometry library isn't loaded yet
const decodePolyline = (encoded: string): google.maps.LatLngLiteral[] => {
  const poly: google.maps.LatLngLiteral[] = [];
  let index = 0, len = encoded.length, lat = 0, lng = 0;

  while (index < len) {
    let b, shift = 0, result = 0;
    do {
      b = encoded.charCodeAt(index++) - 63;
      result |= (b & 0x1f) << shift;
      shift += 5;
    } while (b >= 0x20);
    const dlat = (result & 1) !== 0 ? ~(result >> 1) : result >> 1;
    lat += dlat;

    shift = 0; result = 0;
    do {
      b = encoded.charCodeAt(index++) - 63;
      result |= (b & 0x1f) << shift;
      shift += 5;
    } while (b >= 0x20);
    const dlng = (result & 1) !== 0 ? ~(result >> 1) : result >> 1;
    lng += dlng;

    poly.push({ lat: lat / 1e5, lng: lng / 1e5 });
  }
  return poly;
};

// User position marker icon
const USER_POSITION_ICON = {
  path: 0, // google.maps.SymbolPath.CIRCLE
  scale: 12,
  fillColor: "#4285F4",
  fillOpacity: 1,
  strokeColor: "#ffffff",
  strokeWeight: 3,
};

// Inner component that actually loads Maps JS API. We only mount this when a valid key is available
// to prevent duplicate API script loads (root cause of the prod errors seen).
const GoogleMapsInner = memo(({ 
  integrationData,
  mapType,
  showTraffic,
  showStreetView,
  mapsApiKey,
  onMapLoad,
  userPosition,
}: {
  integrationData: GoogleMapsData;
  mapType: 'roadmap' | 'satellite' | 'hybrid' | 'terrain';
  showTraffic: boolean;
  showStreetView: boolean;
  mapsApiKey: string;
  onMapLoad: (map: google.maps.Map) => void;
  userPosition: { lat: number; lng: number } | null;
}) => {
  const { isLoaded, loadError } = useLoadScript({
    googleMapsApiKey: mapsApiKey,
    libraries: LIBRARIES,
    preventGoogleFontsLoading: true,
    id: 'google-maps-script',
  });

  const decodedPath = useMemo(() => {
    if (!isLoaded || !integrationData.polyline || typeof window.google === 'undefined') return [];
    if (window.google?.maps?.geometry?.encoding) {
      try {
        return window.google.maps.geometry.encoding.decodePath(integrationData.polyline);
      } catch (error) {}
    }
    return decodePolyline(integrationData.polyline);
  }, [integrationData.polyline, isLoaded]);

  const mapBounds = useMemo(() => {
    if (!isLoaded || typeof window.google === 'undefined' || !window.google.maps.LatLngBounds) return null;
    return new window.google.maps.LatLngBounds(
      integrationData.bounds.southwest,
      integrationData.bounds.northeast
    );
  }, [integrationData.bounds, isLoaded]);

  const handleMapLoadInner = useCallback((map: google.maps.Map) => {
    if (mapBounds) map.fitBounds(mapBounds);
    else map.setCenter(integrationData.start);
    onMapLoad(map);
  }, [mapBounds, integrationData.start, onMapLoad]);

  const mapOptions = useMemo(() => ({
    disableDefaultUI: false,
    zoomControl: true,
    mapTypeControl: false,
    streetViewControl: false,
    fullscreenControl: false,
    mapTypeId: mapType,
    gestureHandling: 'greedy',
    styles: mapType === 'roadmap' ? [{
      featureType: 'poi',
      elementType: 'labels',
      stylers: [{ visibility: 'on' }]
    }] : undefined,
  }), [mapType]);

  if (loadError) {
    return (
      <div className="maps-error-state">
        <FiAlertTriangle size={24} />
        <p><strong>Map Loading Error</strong></p>
        <p>Failed to load Google Maps. Please check your API key and browser console.</p>
      </div>
    );
  }
  if (!isLoaded || typeof window.google === 'undefined' || !window.google.maps) {
    return <div className="maps-loading-state">Initializing Map...</div>;
  }

  if (showStreetView) {
    return (
      <GoogleMap
        mapContainerStyle={mapContainerStyle}
        options={mapOptions}
        onLoad={(map) => {
          const panorama = new window.google.maps.StreetViewPanorama(
            map.getDiv(),
            {
              position: integrationData.start,
              pov: { heading: 0, pitch: 0 },
              visible: true,
              enableCloseButton: false,
              fullscreenControl: false,
            }
          );
          map.setStreetView(panorama);
        }}
      />
    );
  }

  return (
    <GoogleMap
      mapContainerStyle={mapContainerStyle}
      options={mapOptions}
      onLoad={handleMapLoadInner}
    >
      {/* TODO: migrate to AdvancedMarkerElement in a follow-up */}
      <Marker
        position={integrationData.start}
        label={{ text: "A", color: "white", fontSize: "14px", fontWeight: "bold" }}
        icon={CIRCLE_MARKER_ICON_START}
      />
      <Marker
        position={integrationData.end}
        label={{ text: "B", color: "white", fontSize: "14px", fontWeight: "bold" }}
        icon={CIRCLE_MARKER_ICON_END}
      />
      {decodedPath.length > 0 && (
        <Polyline
          path={decodedPath}
          options={{
            strokeColor: '#4285F4',
            strokeOpacity: 0.9,
            strokeWeight: 5,
          }}
        />
      )}
      {showTraffic && <TrafficLayer />}
      {/* User position marker when navigating */}
      {userPosition && (
        <Marker
          position={userPosition}
          icon={USER_POSITION_ICON}
          zIndex={1000}
        />
      )}
    </GoogleMap>
  );
});
GoogleMapsInner.displayName = 'GoogleMapsInner';

const GoogleMapsBlock = memo(({ integrationData }: GoogleMapsBlockProps) => {
  const [mapType, setMapType] = useState<MapType>('roadmap');
  const [showTraffic, setShowTraffic] = useState(false);
  const [isFullscreen, setIsFullscreen] = useState(false);
  const [showStreetView, setShowStreetView] = useState(false);

  // Navigation integration
  const { navigation, startNavigation } = useNavigation();

  // Get Maps API key directly from Vite env (baked in at build time)
  const mapsApiKey = (import.meta as any).env?.VITE_GOOGLE_MAPS_API_KEY || '';

  // Keep a hook for future map interactions (e.g., migrating to Advanced Markers)
  const handleMapLoad = useCallback((_map: google.maps.Map) => {
    // no-op for now
  }, []);

  // Handle start navigation button
  const handleStartNavigation = useCallback(() => {
    const steps: NavigationStep[] = integrationData.steps.map((step: any) => ({
      instructions: step.html_instructions || step.instructions,
      distance: step.distance,
      duration: step.duration,
      start_location: step.start_location,
      end_location: step.end_location,
      maneuver: step.maneuver,
    }));

    startNavigation(steps, integrationData.end);
  }, [integrationData, startNavigation]);
  
  const toggleFullscreen = () => setIsFullscreen(!isFullscreen);
  const toggleStreetView = () => setShowStreetView(!showStreetView);

  const cycleMapType = () => {
    const types: MapType[] = ['roadmap', 'satellite', 'hybrid', 'terrain'];
    setMapType(prev => types[(types.indexOf(prev) + 1) % types.length]);
  };
  
  const getMapTypeLabel = () => ({ 
    roadmap: 'Road', 
    satellite: 'Satellite', 
    hybrid: 'Hybrid', 
    terrain: 'Terrain' 
  }[mapType] || 'Map');
  
  const openInGoogleMaps = () => {
    const url = `https://www.google.com/maps/dir/?api=1&origin=${integrationData.start.lat},${integrationData.start.lng}&destination=${integrationData.end.lat},${integrationData.end.lng}`;
    window.open(url, '_blank', 'noopener,noreferrer');
  };
  
  // Map options are computed inside the inner component

  const routeInfo = useMemo(() => ({
    distance: integrationData.distance?.text || '...',
    duration: integrationData.duration?.text || '...',
    steps: integrationData.steps || []
  }), [integrationData]);

  // Map rendering is handled by the inner component
  
  return (
    <div className={`tool-block-container maps-container state-completed ${isFullscreen ? 'fullscreen' : ''}`}>
      <div className="tool-block-header" style={{ cursor: 'default' }}>
        <div className="status">
          <div className="status-icon-wrapper"><FiMap /></div>
          <span>Directions</span>
        </div>
        <div className="maps-controls">
          <button 
            className="map-control-btn" 
            onClick={cycleMapType} 
            title={`Map Type: ${getMapTypeLabel()}`}
            aria-label={`Map Type: ${getMapTypeLabel()}`}
          >
            <FiLayers />
            <span>{getMapTypeLabel()}</span>
          </button>
          <button 
            className={`map-control-btn ${showTraffic ? 'active' : ''}`} 
            onClick={() => setShowTraffic(!showTraffic)} 
            title="Toggle Traffic"
            aria-label="Toggle Traffic"
          >
            <FiNavigation2 />
            <span>Traffic</span>
          </button>
          <button 
            className={`map-control-btn ${showStreetView ? 'active' : ''}`} 
            onClick={toggleStreetView} 
            title="Toggle Street View"
            aria-label="Toggle Street View"
          >
            <FiEye />
            <span>Street</span>
          </button>
          <button 
            className="map-control-btn" 
            onClick={toggleFullscreen} 
            title={isFullscreen ? 'Exit Fullscreen' : 'Fullscreen'}
            aria-label={isFullscreen ? 'Exit Fullscreen' : 'Fullscreen'}
          >
            {isFullscreen ? <FiMinimize2 /> : <FiMaximize2 />}
          </button>
        </div>
      </div>
      
      <div className="tool-block-content expanded">
        <div className="maps-layout">
          <div className={`maps-map-wrapper ${isFullscreen ? 'fullscreen-map' : ''}`}>
            {!mapsApiKey ? (
              <div className="maps-loading-state">Loading Maps API key...</div>
            ) : (
              <GoogleMapsInner
                integrationData={integrationData}
                mapType={mapType}
                showTraffic={showTraffic}
                showStreetView={showStreetView}
                mapsApiKey={mapsApiKey}
                onMapLoad={handleMapLoad}
                userPosition={navigation.currentPosition}
              />
            )}
          </div>
          <div className="maps-info-panel">
            {/* Live Navigation Panel */}
            {navigation.isNavigating ? (
              <NavigationPanel />
            ) : (
              <>
                {/* Start Navigation Button */}
                {routeInfo.steps.length > 0 && (
                  <button 
                    className="start-navigation-btn" 
                    onClick={handleStartNavigation}
                    aria-label="Start live navigation"
                  >
                    <FiPlay />
                    <span>Start Live Navigation</span>
                  </button>
                )}
                
                <div className="maps-route-summary">
                  <div className="route-info-item">
                    <FiNavigation className="route-icon" />
                    <div>
                      <div className="route-label">Distance</div>
                      <div className="route-value">{routeInfo.distance}</div>
                    </div>
                  </div>
                  <div className="route-info-item">
                    <FiClock className="route-icon" />
                    <div>
                      <div className="route-label">Duration</div>
                      <div className="route-value">{routeInfo.duration}</div>
                    </div>
                  </div>
                </div>
              </>
            )}
            
            <div className="maps-locations">
              <div className="location-item start">
                <div className="location-marker">A</div>
                <div className="location-details">
                  <div className="location-label">From</div>
                  <div className="location-address">{integrationData.start.address}</div>
                </div>
              </div>
              <div className="location-divider"></div>
              <div className="location-item end">
                <div className="location-marker">B</div>
                <div className="location-details">
                  <div className="location-label">To</div>
                  <div className="location-address">{integrationData.end.address}</div>
                </div>
              </div>
            </div>
            
            {routeInfo.steps.length > 0 && (
              <div className="maps-directions">
                <div className="directions-header">Step-by-step Directions</div>
                <div className="directions-list">
                  {routeInfo.steps.map((step: any, index: number) => (
                    <div key={index} className="direction-step">
                      <div className="step-number">{index + 1}</div>
                      <div className="step-content">
                        <div className="step-instruction" dangerouslySetInnerHTML={{ __html: step.instructions }} />
                        <div className="step-distance">{step.distance?.text}</div>
                      </div>
                    </div>
                  ))}
                </div>
              </div>
            )}
            
            <button className="open-in-maps-btn" onClick={openInGoogleMaps}>
              <FiMapPin /> Open in Google Maps
            </button>
          </div>
        </div>
      </div>
    </div>
  );
});

GoogleMapsBlock.displayName = 'GoogleMapsBlock';

export default GoogleMapsBlock;
- - - ImageViewer.tsx:
// src/components/ImageViewer.tsx
import { useEffect, useState } from 'react';
import { FiX, FiDownload } from 'react-icons/fi';
import '../css/ImageViewer.css';
import Tooltip from './Tooltip';
import { useNotification } from '../contexts/NotificationContext';

interface ImageViewerProps {
  src: string | null;
  alt: string;
  isOpen: boolean;
  onClose: () => void;
}

const ImageViewer = ({ src, alt, isOpen, onClose }: ImageViewerProps) => {
  const [isClosing, setIsClosing] = useState(false);
  const { showNotification } = useNotification();

  const handleClose = () => {
    setIsClosing(true);
    setTimeout(() => {
      onClose();
      setIsClosing(false);
    }, 300);
  };

  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key === 'Escape') {
        handleClose();
      }
    };

    if (isOpen) {
      document.body.style.overflow = 'hidden';
      window.addEventListener('keydown', handleKeyDown);
    } else {
      document.body.style.overflow = '';
    }

    return () => {
      document.body.style.overflow = '';
      window.removeEventListener('keydown', handleKeyDown);
    };
  }, [isOpen]);

  if (!isOpen) return null;

  // --- START OF THE FIX ---
  const handleDownload = async () => {
    if (!src) return;
    try {
      const response = await fetch(src);
      if (!response.ok) {
        throw new Error(`Failed to fetch image: ${response.statusText}`);
      }
      const blob = await response.blob();
      const objectUrl = window.URL.createObjectURL(blob);
      
      const link = document.createElement('a');
      link.href = objectUrl;
      link.download = alt || 'downloaded-image';
      document.body.appendChild(link);
      link.click();

      document.body.removeChild(link);
      window.URL.revokeObjectURL(objectUrl);
    } catch (error) {
      showNotification('Could not download the image.', 'error');
    }
  };
  // --- END OF THE FIX ---

  return (
    <div className={`image-viewer-overlay ${isClosing ? 'closing' : ''}`} onClick={handleClose}>
      <div className={`image-viewer-content ${isClosing ? 'closing' : ''}`} onClick={(e) => e.stopPropagation()}>
        <img src={src || ''} alt={alt} />
      </div>
      <div className="image-viewer-actions">
        <Tooltip text="Download Image">
          <button className="viewer-action-button" onClick={handleDownload} disabled={!src}>
            <FiDownload size={20} />
            <span>Download</span>
          </button>
        </Tooltip>
        <Tooltip text="Close (Esc)">
          <button className="viewer-action-button" onClick={handleClose}>
            <FiX size={20} />
            <span>Close</span>
          </button>
        </Tooltip>
      </div>
    </div>
  );
};

export default ImageViewer;
- - - InlineThinking.tsx:
// src/components/InlineThinking.tsx
import { useState, memo } from 'react'; 
import { FiChevronDown } from 'react-icons/fi';
import ReactMarkdown from 'react-markdown';
import remarkGfm from 'remark-gfm';
import '../css/InlineThinking.css';

interface InlineThinkingProps {
  content: string | undefined;
  isStreaming?: boolean;
}

const InlineThinking = ({ content, isStreaming = false }: InlineThinkingProps) => {
  const [isExpanded, setIsExpanded] = useState(false);

  return (
    <div className={`inline-thinking-container ${isExpanded ? 'expanded' : ''}`}>
      <button className="thinking-header" onClick={() => setIsExpanded(prev => !prev)}>
        <div className="thinking-status">
          <span className={`thinking-text-shimmer ${isStreaming ? 'animate' : ''}`}>Thinking</span>
        </div>
        <FiChevronDown className="chevron-icon" size={16} />
      </button>
      <div className="thinking-content-details">
        {content ? (
          <ReactMarkdown remarkPlugins={[remarkGfm]}>{content}</ReactMarkdown>
        ) : null}
        {isStreaming && <span className="streaming-cursor-small"></span>}
      </div>
    </div>
  );
};

export default memo(InlineThinking);
- - - LandingNav.tsx:
// FexoApp/src/components/LandingNav.tsx
import { Link } from 'react-router-dom';
import '../css/LandingNav.css';

const LandingNav = () => {
  return (
    <nav className="landing-nav">
      <div className="landing-nav-container">
        {/* --- START OF THE FIX --- */}
        <Link to="/" className="landing-nav-logo">
          <img src="/worksparkai.svg" alt="Workspark AI Logo" />
        </Link>
        {/* --- END OF THE FIX --- */}
        <div className="landing-nav-actions">
          <Link to="/login" className="landing-nav-button login">
            Log In
          </Link>
          <Link to="/register" className="landing-nav-button register">
            Register
          </Link>
        </div>
      </div>
    </nav>
  );
};

export default LandingNav;
- - - MobileHeader.tsx:
// src/components/MobileHeader.tsx
import { FiMenu, FiEdit } from 'react-icons/fi';
import ModelSelector from './ModelSelector';
import '../css/MobileHeader.css';

interface MobileHeaderProps {
  onToggleSidebar: () => void;
  onNewChat: () => void;
}

const MobileHeader = ({ onToggleSidebar, onNewChat }: MobileHeaderProps) => {
  return (
    <header className="mobile-header">
      <button className="mobile-header-button" onClick={onToggleSidebar} aria-label="Open menu">
        <FiMenu size={22} />
      </button>
      
      {/* The static title is now replaced by the interactive ModelSelector */}
      <ModelSelector />
      
      <button className="mobile-header-button" onClick={onNewChat} aria-label="New chat">
        <FiEdit size={22} />
      </button>
    </header>
  );
};

export default MobileHeader;
- - - ModelSelector.tsx:
import { useState, useRef, useEffect } from 'react';
import { useSettings } from '../contexts/SettingsContext';
import { FiChevronDown, FiCheck, FiCpu } from 'react-icons/fi';
import '../css/ModelSelector.css';

const ModelSelector = () => {
  const { user, models, selectedModel, updateSettings, loading } = useSettings();
  const [isOpen, setIsOpen] = useState(false);
  const selectorRef = useRef<HTMLDivElement>(null);

  const quickAccessModelIds = user?.quickAccessModels || [];
  const quickAccessModels = models.filter(m => quickAccessModelIds.includes(m.id));

  const handleSelectModel = async (modelId: string) => {
    if (modelId !== selectedModel) {
      await updateSettings({ selectedModel: modelId });
    }
    setIsOpen(false);
  };
  
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (selectorRef.current && !selectorRef.current.contains(event.target as Node)) {
        setIsOpen(false);
      }
    };
    document.addEventListener('mousedown', handleClickOutside);
    return () => document.removeEventListener('mousedown', handleClickOutside);
  }, []);

  if (loading) {
    return <div className="model-selector-placeholder" />;
  }

  const getModelInfo = () => {
    return {
      Icon: FiCpu,
      description: "",
    };
  };

  return (
    <div className="model-selector" ref={selectorRef}>
      {/* --- START OF THE FIX --- */}
      <button className="model-selector-button" onClick={() => setIsOpen(!isOpen)}>
        <span>Workspark AI</span>
        <span className="beta-tag">Beta</span>
        <FiChevronDown size={16} className={isOpen ? 'open' : ''} />
      </button>
      {/* --- END OF THE FIX --- */}

      {isOpen && (
        <div className="model-selector-dropdown">
          {quickAccessModels.length > 0 ? (
            quickAccessModels.map(model => {
              const { Icon, description } = getModelInfo();
              return (
                <div 
                  key={model.id}
                  className={`model-item ${selectedModel === model.id ? 'selected' : ''}`}
                  onClick={() => handleSelectModel(model.id)}
                >
                  <Icon size={20} className="model-item-icon" />
                  <div className="model-item-details">
                    <span className="model-item-name">{model.id}</span>
                    <span className="model-item-description">{description}</span>
                  </div>
                  {selectedModel === model.id && <FiCheck size={18} className="model-item-check" />}
                </div>
              );
            })
          ) : (
            <div className="model-item-empty">
              Configure quick access models in Settings.
            </div>
          )}
        </div>
      )}
    </div>
  );
};

export default ModelSelector;
- - - NavigationPanel.tsx:
// src/components/NavigationPanel.tsx
import { memo } from 'react';
import { FiNavigation, FiClock, FiAlertTriangle, FiX } from 'react-icons/fi';
import { useNavigation } from '../contexts/NavigationContext';
import {
  formatDistance,
  formatSpeed,
  formatETA,
  getTurnDirection,
  cleanInstruction,
} from '../utils/navigationHelpers';
import '../css/NavigationPanel.css';

const NavigationPanel = memo(() => {
  const { navigation, stopNavigation, acknowledgeOffRoute } = useNavigation();

  if (!navigation.isNavigating) return null;

  const currentStep = navigation.steps[navigation.currentStepIndex];
  const isLastStep = navigation.currentStepIndex >= navigation.steps.length - 1;
  
  if (!currentStep) return null;

  const turnInfo = getTurnDirection(currentStep.maneuver);
  const instruction = cleanInstruction(currentStep.instructions);

  return (
    <div className="navigation-panel">
      {/* Off-route warning */}
      {navigation.offRoute && (
        <div className="off-route-warning">
          <FiAlertTriangle />
          <span>You appear to be off route</span>
          <button
            className="off-route-dismiss"
            onClick={acknowledgeOffRoute}
            aria-label="Dismiss warning"
          >
            <FiX />
          </button>
        </div>
      )}

      {/* Current instruction */}
      <div className="nav-instruction-container">
        <div className="nav-turn-icon" aria-label={turnInfo.text}>
          {turnInfo.icon}
        </div>
        <div className="nav-instruction-details">
          <div className="nav-instruction-text">{instruction}</div>
          <div className="nav-distance-to-turn">
            {isLastStep
              ? 'Arriving at destination'
              : `in ${formatDistance(navigation.distanceToNextTurn)}`}
          </div>
        </div>
      </div>

      {/* Stats bar */}
      <div className="nav-stats-bar">
        <div className="nav-stat">
          <FiNavigation className="nav-stat-icon" />
          <div className="nav-stat-content">
            <div className="nav-stat-label">Speed</div>
            <div className="nav-stat-value">
              {formatSpeed(navigation.currentSpeed)}
            </div>
          </div>
        </div>

        <div className="nav-stat">
          <FiClock className="nav-stat-icon" />
          <div className="nav-stat-content">
            <div className="nav-stat-label">ETA</div>
            <div className="nav-stat-value">
              {navigation.eta ? formatETA(navigation.eta) : '--:--'}
            </div>
          </div>
        </div>

        <div className="nav-stat">
          <div className="nav-stat-content">
            <div className="nav-stat-label">Remaining</div>
            <div className="nav-stat-value">
              {formatDistance(navigation.totalRemainingDistance)}
            </div>
          </div>
        </div>
      </div>

      {/* Stop navigation button */}
      <button
        className="nav-stop-button"
        onClick={stopNavigation}
        aria-label="Stop navigation"
      >
        <div className="nav-stop-icon">
          <div className="nav-stop-square"></div>
        </div>
        <span>Stop Navigation</span>
      </button>

      {/* Progress indicator */}
      <div className="nav-progress-container">
        <div className="nav-progress-info">
          <span>Step {navigation.currentStepIndex + 1} of {navigation.steps.length}</span>
        </div>
        <div className="nav-progress-bar">
          <div
            className="nav-progress-fill"
            style={{
              width: `${((navigation.currentStepIndex + 1) / navigation.steps.length) * 100}%`,
            }}
          />
        </div>
      </div>

      {/* Error display */}
      {navigation.error && (
        <div className="nav-error">
          <FiAlertTriangle />
          <span>{navigation.error}</span>
        </div>
      )}
    </div>
  );
});

NavigationPanel.displayName = 'NavigationPanel';

export default NavigationPanel;
- - - Notification.tsx:
// src/components/Notification.tsx
import { useNotification } from '../contexts/NotificationContext';
import '../css/Notification.css';

const Notification = () => {
  const { notificationMessage, isNotificationVisible, notificationType } = useNotification();

  return (
    <div className={`notification-popup ${isNotificationVisible ? 'visible' : ''} ${notificationType}`}>
      {notificationMessage}
    </div>
  );
};

export default Notification;
- - - NotificationsModal.tsx:
// FexoApp/src/components/NotificationsModal.tsx
import { useState, useEffect } from 'react';
import { FiBell, FiClock, FiCheckCircle, FiTrash2, FiX, FiCalendar } from 'react-icons/fi';
import Portal from './Portal';
import { getTasks, deleteTask, type ScheduledTask } from '../utils/scheduler';
import '../css/NotificationsModal.css';

interface NotificationsModalProps {
  isOpen: boolean;
  onClose: () => void;
}

const NotificationsModal = ({ isOpen, onClose }: NotificationsModalProps) => {
  const [activeTab, setActiveTab] = useState<'scheduled' | 'completed'>('scheduled');
  const [tasks, setTasks] = useState<ScheduledTask[]>([]);

  const refreshTasks = () => {
    const allTasks = getTasks();
    // Auto-move past scheduled tasks to completed if time has passed
    const now = Date.now();
    let updated = false;
    
    const processedTasks = allTasks.map(t => {
      if (t.status === 'scheduled' && t.scheduledTime < now) {
        updated = true;
        return { ...t, status: 'completed' as const };
      }
      return t;
    });

    if (updated) {
      // We don't save back to localStorage here to avoid side-effects during render,
      // but ideally, the system should update status on trigger.
      setTasks(processedTasks);
    } else {
      setTasks(allTasks);
    }
  };

  useEffect(() => {
    if (isOpen) {
      refreshTasks();
    }
    
    // Listen for updates from other parts of the app
    const handleUpdate = () => refreshTasks();
    window.addEventListener('fexo-tasks-updated', handleUpdate);
    
    // Refresh interval to update "time remaining" or move to completed
    const interval = setInterval(refreshTasks, 30000);
    
    return () => {
      window.removeEventListener('fexo-tasks-updated', handleUpdate);
      clearInterval(interval);
    };
  }, [isOpen]);

  if (!isOpen) return null;

  const filteredTasks = tasks
    .filter(t => activeTab === 'scheduled' ? t.status === 'scheduled' : t.status === 'completed')
    .sort((a, b) => b.scheduledTime - a.scheduledTime); // Newest first

  const handleDelete = (id: string) => {
    deleteTask(id);
    refreshTasks();
  };

  const formatTime = (timestamp: number) => {
    return new Date(timestamp).toLocaleString(undefined, {
      month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit'
    });
  };

  return (
    <Portal>
      <div className="notifications-modal-overlay" onClick={onClose}>
        <div className="notifications-modal-content" onClick={e => e.stopPropagation()}>
          
          {/* Sidebar */}
          <aside className="notif-sidebar">
            <div className="notif-header">
              <h2><FiBell /> <span>Notifications</span></h2>
            </div>
            <nav className="notif-tabs">
              <button 
                className={`notif-tab-btn ${activeTab === 'scheduled' ? 'active' : ''}`}
                onClick={() => setActiveTab('scheduled')}
              >
                <FiClock /> Scheduled
                <span className="notif-count-badge">
                  {tasks.filter(t => t.status === 'scheduled').length}
                </span>
              </button>
              <button 
                className={`notif-tab-btn ${activeTab === 'completed' ? 'active' : ''}`}
                onClick={() => setActiveTab('completed')}
              >
                <FiCheckCircle /> Completed
                <span className="notif-count-badge">
                  {tasks.filter(t => t.status === 'completed').length}
                </span>
              </button>
            </nav>
          </aside>

          {/* Main Content */}
          <main className="notif-main">
            <header className="notif-main-header">
              <h3>{activeTab === 'scheduled' ? 'Upcoming Tasks' : 'Task History'}</h3>
              <button className="close-modal-btn" onClick={onClose}>
                <FiX size={20} />
              </button>
            </header>

            <div className="notif-list">
              {filteredTasks.length === 0 ? (
                <div className="notif-empty">
                  {activeTab === 'scheduled' ? <FiClock /> : <FiCheckCircle />}
                  <p>No {activeTab} tasks found.</p>
                </div>
              ) : (
                filteredTasks.map(task => (
                  <div key={task.id} className="task-card">
                    <div className="task-info">
                      <h4>{task.title}</h4>
                      <p className="task-desc">{task.description}</p>
                      <div className="task-meta">
                        <span className="task-time">
                          <FiCalendar size={12} /> 
                          {formatTime(task.scheduledTime)}
                        </span>
                        {task.status === 'completed' && (
                          <span className="status-completed">Completed</span>
                        )}
                      </div>
                    </div>
                    <div className="task-actions">
                      <button 
                        className="task-action-btn delete" 
                        onClick={() => handleDelete(task.id)}
                        title="Delete"
                      >
                        <FiTrash2 size={16} />
                      </button>
                    </div>
                  </div>
                ))
              )}
            </div>
          </main>

        </div>
      </div>
    </Portal>
  );
};

export default NotificationsModal;
- - - Portal.tsx:
// src/components/Portal.tsx
import { useEffect, useState, type ReactNode } from 'react';
import { createPortal } from 'react-dom';

interface PortalProps {
  children: ReactNode;
}

/**
 * A component that renders its children into a "portal" DOM node,
 * typically `div#portal-root` in the main HTML file. This is useful for
 * modals, tooltips, and other elements that need to appear on top of
 * the main application UI without being clipped by parent overflow styles.
 */
const Portal = ({ children }: PortalProps) => {
  // State to hold the portal container DOM element.
  const [container, setContainer] = useState<HTMLElement | null>(null);

  useEffect(() => {
    // This effect runs on the client after the component mounts.
    // It finds the portal root element in the document.
    let portalRoot = document.getElementById('portal-root');
    
    // If the portal root doesn't exist for some reason, create it dynamically.
    if (!portalRoot) {
        const newPortalRoot = document.createElement('div');
        newPortalRoot.id = 'portal-root';
        document.body.appendChild(newPortalRoot);
        portalRoot = newPortalRoot;
    }
    
    // Set the container in state.
    setContainer(portalRoot);

    // The cleanup function is not strictly necessary here, but it's good practice.
    // We don't want to remove the portalRoot as other components might use it.
  }, []); // The empty dependency array ensures this runs only once on mount.

  // If the container has been found, create a portal and render the children into it.
  // Otherwise, render nothing (this prevents errors during server-side rendering or initial mount).
  return container ? createPortal(children, container) : null;
};

export default Portal;
- - - ProviderSelector.tsx:
import { useState, useRef, useEffect, type FC, type SVGProps } from 'react';
import { FiChevronDown } from 'react-icons/fi';
import '../css/ProviderSelector.css';

export type Provider = {
  id: string;
  name: string;
  Icon: FC<SVGProps<SVGSVGElement>>;
};

interface ProviderSelectorProps {
  providers: Provider[];
  selectedProvider: string;
  onSelect: (providerId: string) => void;
}

const ProviderSelector: FC<ProviderSelectorProps> = ({ providers, selectedProvider, onSelect }) => {
  const [isOpen, setIsOpen] = useState(false);
  const selectorRef = useRef<HTMLDivElement>(null);

  const currentProvider = providers.find(p => p.id === selectedProvider) || providers[0];

  const handleSelect = (providerId: string) => {
    onSelect(providerId);
    setIsOpen(false);
  };
  
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (selectorRef.current && !selectorRef.current.contains(event.target as Node)) {
        setIsOpen(false);
      }
    };
    document.addEventListener('mousedown', handleClickOutside);
    return () => document.removeEventListener('mousedown', handleClickOutside);
  }, []);

  return (
    <div className="provider-selector" ref={selectorRef}>
      <button className="provider-selector-button" onClick={() => setIsOpen(!isOpen)}>
        <div className="provider-info">
          <currentProvider.Icon className="provider-icon" />
          <span>{currentProvider.name}</span>
        </div>
        <FiChevronDown size={20} className={`chevron-icon ${isOpen ? 'open' : ''}`} />
      </button>

      {isOpen && (
        <div className="provider-selector-dropdown">
          {providers.map(provider => (
            <div 
              key={provider.id}
              className={`provider-item ${selectedProvider === provider.id ? 'selected' : ''}`}
              onClick={() => handleSelect(provider.id)}
            >
              <provider.Icon className="provider-icon" />
              <span>{provider.name}</span>
            </div>
          ))}
        </div>
      )}
    </div>
  );
};

export default ProviderSelector;
- - - RenameModal.tsx:
// src/components/RenameModal.tsx
import { useState, useEffect } from 'react';
import { FiEdit2 } from 'react-icons/fi';
import '../css/RenameModal.css';

interface RenameModalProps {
  isOpen: boolean;
  onClose: () => void;
  onRename: (newTitle: string) => void;
  currentTitle: string;
}

const RenameModal = ({ isOpen, onClose, onRename, currentTitle }: RenameModalProps) => {
  const [newTitle, setNewTitle] = useState(currentTitle);

  useEffect(() => {
    if (isOpen) {
      setNewTitle(currentTitle);
    }
  }, [isOpen, currentTitle]);

  if (!isOpen) return null;

  const handleSave = () => {
    if (newTitle.trim() && newTitle.trim() !== currentTitle) {
      onRename(newTitle.trim());
    }
    onClose();
  };
  
  const handleKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {
    if (e.key === 'Enter') {
      e.preventDefault();
      handleSave();
    }
  };

  return (
    <div className="rename-modal-overlay" onClick={onClose}>
      <div className="rename-modal-content" onClick={(e) => e.stopPropagation()}>
        <div className="rename-modal-header">
          <FiEdit2 size={20} className="rename-modal-icon" />
          <h3>Rename Chat?</h3>
        </div>
        <input
          type="text"
          value={newTitle}
          onChange={(e) => setNewTitle(e.target.value)}
          onKeyDown={handleKeyDown}
          autoFocus
          onFocus={(e) => e.target.select()}
        />
        <div className="rename-modal-actions">
          <button className="rename-modal-button cancel" onClick={onClose}>
            Cancel
          </button>
          <button className="rename-modal-button save" onClick={handleSave}>
            Save
          </button>
        </div>
      </div>
    </div>
  );
};

export default RenameModal;
- - - SearchBlock.tsx:
import { useState, useMemo, memo } from 'react';
import { FiChevronDown, FiXCircle, FiLoader, FiSearch, FiExternalLink } from 'react-icons/fi';
import ReactMarkdown from 'react-markdown';
import type { Message } from '../types';
import '../css/SearchBlock.css';

interface SearchBlockProps {
  toolSearchMessage: Message;
  toolOutputMessage?: Message;
}

type ParsedImage = {
  title: string;
  source: string;
  imageUrl: string;
}

const SearchBlock = memo(({ toolSearchMessage, toolOutputMessage }: SearchBlockProps) => {
  const [isExpanded, setIsExpanded] = useState(false);
  const state = toolSearchMessage.state || (toolOutputMessage ? 'completed' : 'writing');

  const hasError = state === 'error';

  const { statusText, StatusIcon } = useMemo(() => {
    switch (state) {
      case 'searching':
        return { statusText: 'Searching the web...', StatusIcon: <FiLoader className="spinner-icon" /> };
      case 'error':
        return { statusText: 'Search Error', StatusIcon: <FiXCircle /> };
      case 'completed':
      case 'searched':
        return { statusText: 'Web Search', StatusIcon: <FiSearch /> };
      default: // writing, ready_to_execute
        return { statusText: 'Preparing search...', StatusIcon: <FiLoader className="spinner-icon" /> };
    }
  }, [state]);

  const output = toolOutputMessage?.content || '';
  const isOutputError = hasError || (state === 'completed' && output.toLowerCase().startsWith('error:'));

  const parsedContent = useMemo(() => {
    const images: ParsedImage[] = [];
    let textContent = output;

    if (output && output.includes('[IMAGE_ITEM]')) {
      textContent = ''; // Clear text content if we find image items to prevent it from being rendered by mistake
      const imageRegex = /\[IMAGE_ITEM\](.*?)\[\/IMAGE_ITEM\]/g;
      const attrRegex = /(\w+)="(.*?)"/g;

      let match;
      while ((match = imageRegex.exec(output)) !== null) {
        const attrsString = match[1];
        const image: Partial<ParsedImage> = {};
        let attrMatch;
        while ((attrMatch = attrRegex.exec(attrsString)) !== null) {
          // @ts-expect-error Works
          image[attrMatch[1]] = attrMatch[2];
        }
        if(image.imageUrl && image.source && image.title) {
          images.push(image as ParsedImage);
        }
      }
    }
    
    return { images, textContent };
  }, [output]);

  return (
    <div className={`tool-block-container search-container state-${state}`}>
      <button className="tool-block-header" onClick={() => setIsExpanded(!isExpanded)}>
        <div className="status">
          <div className="status-icon-wrapper">{StatusIcon}</div>
          <span>{statusText}</span>
        </div>
        <FiChevronDown className={`chevron-icon ${isExpanded ? 'expanded' : ''}`} />
      </button>
      
      {/* --- Collapsed Image Preview --- */}
      {!isExpanded && parsedContent.images.length > 0 && (
        <div className="tool-block-preview">
          <div className="search-image-gallery-preview">
            {parsedContent.images.slice(0, 4).map((image, index) => (
              <div key={`preview-${index}`} className="search-image-item-preview">
                <img src={image.imageUrl} alt={image.title} />
              </div>
            ))}
          </div>
        </div>
      )}

      {/* --- Expanded Content --- */}
      <div className={`tool-block-content ${isExpanded ? 'expanded' : ''}`}>
        <div className="search-section">
          <div className="section-title">Query</div>
          <pre className="search-query-text">
            {toolSearchMessage.content || <span className="streaming-cursor-static"></span>}
          </pre>
        </div>
        {(output || state === 'searching') && (
          <div className="search-section">
            <div className="section-title">Results</div>
            {state === 'searching' && !output ? (
              <div className="searching-placeholder">
                  <div className="dot"></div>
                  <div className="dot"></div>
                  <div className="dot"></div>
              </div>
            ) : (
              <>
                {isExpanded && parsedContent.images.length > 0 && (
                  <div className="search-image-gallery">
                    {parsedContent.images.map((image, index) => (
                      <div key={index} className="search-image-item">
                        <img src={image.imageUrl} alt={image.title} />
                        <div className="search-image-info">
                           <div className="search-image-title">{image.title}</div>
                           <a href={image.source} target="_blank" rel="noopener noreferrer" className="search-image-source">
                             Source <FiExternalLink />
                           </a>
                        </div>
                      </div>
                    ))}
                  </div>
                )}
                {parsedContent.textContent && (
                   <div className={`search-output-text ${isOutputError ? 'error' : ''}`}>
                    <ReactMarkdown
                      components={{
                          a: ({node, ...props}) => <a {...props} target="_blank" rel="noopener noreferrer" />
                      }}
                    >
                      {parsedContent.textContent}
                    </ReactMarkdown>
                  </div>
                )}
              </>
            )}
          </div>
        )}
      </div>
    </div>
  );
});

export default memo(SearchBlock);
- - - SettingsModal.tsx:
import { useState, useEffect, useRef, useCallback } from 'react';
import { useNavigate } from 'react-router-dom';
import { useSettings } from '../contexts/SettingsContext';
import { useNotification } from '../contexts/NotificationContext';
import '../css/SettingsModal.css';
import { FiRefreshCw, FiCpu, FiSliders, FiEye, FiEyeOff, FiMoreVertical, FiX, FiCreditCard, FiCheckCircle, FiLink, FiStar, FiVolume2, FiPlay, FiPause } from "react-icons/fi";
import OpenAIIcon from '../icons/openai.svg?react';
import AnthropicIcon from '../icons/anthropic.svg?react';
import GeminiIcon from '../icons/gemini.svg?react';
import api from '../utils/api';
import Tooltip from './Tooltip';
import Portal from './Portal';
import ProviderSelector, { type Provider } from './ProviderSelector';
import CustomModelSelector from './CustomModelSelector';
import '../css/ProviderSelector.css';
import '../css/VoiceSettings.css';
import '../css/CustomModelSelector.css';

type Model = { id: string };
type Modality = 'text' | 'image' | 'code' | 'reasoning';
type ModelConfig = { id: string; modalities: Modality[]; };
type ApiKeyEntry = { provider: string; key: string; };

type Integration = {
  id: string;
  name: string;
  description: string;
};

interface SettingsModalProps { isOpen: boolean; onClose: () => void; }
type ActiveTab = 'GPT' | 'Subscription' | 'Appearance' | 'Integrations' | 'Voice';

const providers: Provider[] = [
  { id: 'default', name: "Default (Free)",Icon: GeminiIcon},
  { id: 'openai', name: 'OpenAI', Icon: OpenAIIcon },
  { id: 'anthropic', name: 'Anthropic', Icon: AnthropicIcon },
  { id: 'gemini', name: 'Gemini', Icon: GeminiIcon },
];

const MIN_CONTEXT = 4096;
const MAX_CONTEXT = 1000000;
const MIN_OUTPUT_TOKENS = 256;
const MAX_OUTPUT_TOKENS = 64000;

// --- START: Added for Subscription Tab ---
const proFeatures = [
  'Premium default model (GPT-5)',
  'Code Interpreter & File Analysis',
  'Web Search capabilities',
  'Bring your own API keys',
  'Voice chat included',
  'Priority support',
];
const freeFeatures = [
    'Standard default model',
    'Code Interpreter & File Analysis',
    'Web Search capabilities',
    'Bring your own API keys',
    'Community support'
];
// --- END: Added for Subscription Tab ---

const SettingsModal = ({ isOpen, onClose }: SettingsModalProps) => {
  const { user, models, setModels, updateSettings, theme, setTheme } = useSettings();
  const { showNotification } = useNotification();
  const navigate = useNavigate();
  
  const [activeTab, setActiveTab] = useState<ActiveTab>('GPT');
  const [selectedProvider, setSelectedProvider] = useState(user?.selectedProvider || 'default');
  const [apiKeys, setApiKeys] = useState<ApiKeyEntry[]>(user?.apiKeys || []);
  const [baseUrl, setBaseUrl] = useState(user?.baseUrl || '');
  const [selectedModel, setSelectedModel] = useState(user?.selectedModel || '');
  const [quickAccessModels, setQuickAccessModels] = useState<string[]>(user?.quickAccessModels || []);
  const [availableIntegrations, setAvailableIntegrations] = useState<Integration[]>([]);
  const [enabledIntegrations, setEnabledIntegrations] = useState<string[]>(user?.enabledIntegrations || []);
  const [isLoadingIntegrations, setIsLoadingIntegrations] = useState(false);
  const [modelConfigs, setModelConfigs] = useState<ModelConfig[]>(user?.modelConfigs || []);
  const [contextLength, setContextLength] = useState(user?.contextLength || MIN_CONTEXT);
  const [maxOutputTokens, setMaxOutputTokens] = useState(user?.maxOutputTokens || 4096);
  
  const [isFetching, setIsFetching] = useState(false);
  const [fetchError, setFetchError] = useState('');
  const [isClosing, setIsClosing] = useState(false);
  const [isApiKeyVisible, setIsApiKeyVisible] = useState(false);
  const [openConfigMenuId, setOpenConfigMenuId] = useState<string | null>(null);
  const [menuPosition, setMenuPosition] = useState({ top: 0, left: 0 });
  const configMenuRef = useRef<HTMLDivElement>(null);

  const [isEditingContext, setIsEditingContext] = useState(false);
  const [editableContextValue, setEditableContextValue] = useState(String(contextLength));
  const [isEditingMaxOutput, setIsEditingMaxOutput] = useState(false);
  const [editableMaxOutputValue, setEditableMaxOutputValue] = useState(String(maxOutputTokens));

  const [modelSearchQuery, setModelSearchQuery] = useState('');
  // --- Voice state ---
  const curatedVoices = [
    { id: '9BWtsMINqrJLrRacOk9x', name: 'Aria', gender: 'female' as const, description: 'Warm, conversational' },
    { id: '21m00Tcm4TlvDq8ikWAM', name: 'Rachel', gender: 'female' as const, description: 'Casual, personable' },
    { id: '29vD33N1CtxCmqQRPOHJ', name: 'Drew', gender: 'male' as const, description: 'Well-rounded, newsy' },
    { id: '4YYIPFl9wE5c4L2eu2Gb', name: 'Burt Reynolds™', gender: 'male' as const, description: 'Iconic, deep' },
  ];
  const [voiceId, setVoiceId] = useState(user?.voiceSettings?.voiceId || curatedVoices[0].id);
  const [voiceName, setVoiceName] = useState(user?.voiceSettings?.voiceName || curatedVoices[0].name);
  const [previewingId, setPreviewingId] = useState<string | null>(null);
  const audioEl = useRef<HTMLAudioElement | null>(null);


  useEffect(() => {
    if (!isEditingContext) {
      setEditableContextValue(String(contextLength));
    }
  }, [contextLength, isEditingContext]);

  useEffect(() => {
    if (!isEditingMaxOutput) {
      setEditableMaxOutputValue(String(maxOutputTokens));
    }
  }, [maxOutputTokens, isEditingMaxOutput]);

  useEffect(() => {
    if (isOpen && user) {
      setSelectedProvider(user.selectedProvider || 'default');
      setApiKeys(user.apiKeys || []);
      setBaseUrl(user.baseUrl || '');
      setSelectedModel(user.selectedModel || '');
      setQuickAccessModels(user.quickAccessModels || []);
      setModelConfigs(user.modelConfigs || []);
      setContextLength(user.contextLength || MIN_CONTEXT);
      setMaxOutputTokens(user.maxOutputTokens || 4096);
      setEnabledIntegrations(user.enabledIntegrations || []);
      setVoiceId(user.voiceSettings?.voiceId || voiceId);
      setVoiceName(user.voiceSettings?.voiceName || voiceName);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [isOpen]); 

  useEffect(() => {
    if (isOpen) {
      const fetchIntegrations = async () => {
        setIsLoadingIntegrations(true);
        try {
          const response = await api('/integrations');
          if (!response.ok) throw new Error('Could not fetch integrations.');
          const data = await response.json();
          setAvailableIntegrations(data);
        } catch (error) {
          showNotification('Failed to load available integrations.', 'error');
        } finally {
          setIsLoadingIntegrations(false);
        }
      };
      fetchIntegrations();
    }
  }, [isOpen, showNotification]);

  useEffect(() => {
    // If we have models loaded and the provider is NOT default (default has implicit models)
    if (isOpen && models.length > 0 && selectedProvider !== 'default') {
      const isModelValid = models.some(m => m.id === selectedModel);
      
      // If the currently selected model isn't in the new provider's list, clear it or pick a fallback
      if (!isModelValid && selectedModel !== '') {
        // Try to keep a selection if it's in quick access, otherwise clear
        const fallback = quickAccessModels.find(qaId => models.some(m => m.id === qaId));
        setSelectedModel(fallback || '');
      }
    } else if (selectedProvider !== 'default' && models.length === 0 && !isFetching) {
      // If no models loaded yet for this provider, clear selection to avoid mismatch
      setSelectedModel('');
    }
  }, [selectedProvider, models, isOpen, quickAccessModels]);

  useEffect(() => {
    if (!isOpen) {
      setIsApiKeyVisible(false);
      setOpenConfigMenuId(null);
      setIsEditingContext(false);
      setIsEditingMaxOutput(false);
      setModelSearchQuery(''); // Reset search on close
    }
  }, [isOpen]);
  
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (configMenuRef.current && !configMenuRef.current.contains(event.target as Node)) {
        setOpenConfigMenuId(null);
      }
    };
    if (openConfigMenuId) {
      document.addEventListener('mousedown', handleClickOutside);
    }
    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
    };
  }, [openConfigMenuId]);
  
  const fetchProviderModels = useCallback(async (provider: string) => {
    // START CHANGE: Do not fetch for the default provider
    if (provider === 'default') {
        setModels([]);
        return;
    }
    // END CHANGE

    const keyForProvider = apiKeys.find(k => k.provider === provider)?.key;
    if (!keyForProvider) {
        setModels([]);
        return;
    }

    setIsFetching(true);
    setFetchError('');
    try {
        const response = await api('/models', { method: 'POST', body: JSON.stringify({ provider }) });
        const data = await response.json();
        if (!response.ok) throw new Error(data.error || 'Failed to fetch models.');
        
        setModels(data);
        
        if (selectedModel && !data.some((m: Model) => m.id === selectedModel)) {
            setSelectedModel('');
        }
    } catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred.';
        setFetchError(errorMessage);
        showNotification(errorMessage, 'error');
        setModels([]);
    } finally {
        setIsFetching(false);
    }
  }, [apiKeys, selectedModel, setModels, showNotification]);

  useEffect(() => {
    setFetchError('');
    setModels([]); 
    
    fetchProviderModels(selectedProvider);
  }, [selectedProvider, fetchProviderModels, setModels]);

  const handleApiKeyChange = (newKey: string) => {
    setApiKeys(prev => {
      const otherKeys = prev.filter(k => k.provider !== selectedProvider);
      if (newKey) {
        return [...otherKeys, { provider: selectedProvider, key: newKey }];
      }
      return otherKeys;
    });
  };
  
  const handleClose = () => {
    setIsClosing(true);
    setTimeout(() => {
      onClose();
      setIsClosing(false);
    }, 300);
  };

  const handleManualFetch = async () => {
    const currentApiKey = apiKeys.find(k => k.provider === selectedProvider)?.key;
    if (!currentApiKey) {
      const providerName = providers.find(p => p.id === selectedProvider)?.name || 'Current provider';
      setFetchError(`${providerName} API Key is required to fetch models.`);
      return;
    }
    await updateSettings({ apiKeys, baseUrl });
    await fetchProviderModels(selectedProvider);
  };

  const handleSave = async () => {
    // START CHANGE: Adjust validation for default provider
    if (selectedProvider !== 'default' && quickAccessModels.length > 0 && !selectedModel) {
        showNotification('Please select a default model from your Quick Access list.', 'error');
        return;
    }
    // END CHANGE
    try {
      const configsToSave = modelConfigs.filter(config => quickAccessModels.includes(config.id));

      if (selectedProvider === "default") {
        configsToSave.push({id: "default", modalities: ["text", "image"]})
        setModelConfigs(prevConfigs => {
            const modelConfigIndex = prevConfigs.findIndex(c => c.id === "default");

            if (modelConfigIndex > -1) {
              prevConfigs[modelConfigIndex] = {id: "default", modalities: ["text", "image"]}
            } else {
              prevConfigs.push({id: "default", modalities: ["text", "image"]})
            }
            return prevConfigs;
        })
      }
      
      // START CHANGE: Only save relevant settings based on provider
      const settingsToSave = {
        selectedProvider,
        apiKeys,
        baseUrl: selectedProvider === 'openai' ? baseUrl : '',
        modelConfigs: configsToSave,
        contextLength,
        maxOutputTokens,
        selectedModel: selectedProvider === 'default' 
          ? 'default' 
          : selectedModel,
        ...(selectedProvider !== 'default' && {
          quickAccessModels,
        }),
        enabledIntegrations,
        voiceSettings: { voiceId, voiceName },
      };
      
      await updateSettings(settingsToSave);
      // END CHANGE

      showNotification('Settings Saved!');
      handleClose();
    } catch (err) {
      showNotification(`Failed to save settings.\n${err}`, "error");
    }
  };
  const previewVoice = async (id: string, name: string) => {
    setPreviewingId(id);
    try {
      // Try local pre-downloaded preview first to avoid API cost
      const tryLocal = async (): Promise<boolean> => {
        const exts = ['mp3', 'ogg', 'wav'];
        for (const ext of exts) {
          const url = `/voices/${id}.${ext}`;
          try {
            const resp = await fetch(url, { method: 'GET' });
            if (resp.ok) {
              if (!audioEl.current) audioEl.current = new Audio();
              audioEl.current.src = `${url}?v=${Date.now()}`; // bust cache during dev
              await audioEl.current.play();
              return true;
            }
          } catch (_) {
            // try next extension
          }
        }
        return false;
      };

      const playedLocal = await tryLocal();
      if (playedLocal) return;

      // Fallback: call server TTS preview
      if (!audioEl.current) audioEl.current = new Audio();
      const res = await api('/voice/tts', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', Accept: 'audio/mpeg' },
        body: JSON.stringify({
          text: `Hi, I am ${name}. This is a sample of my voice.`,
          voiceId: id,
        }),
      });
      if (!res.ok) {
        const err = await res.json();
        throw new Error(err?.error || 'Could not preview voice');
      }
      const buf = await res.arrayBuffer();
      const blob = new Blob([buf], { type: 'audio/mpeg' });
      const url = URL.createObjectURL(blob);
      audioEl.current.src = url;
      await audioEl.current.play();
    } catch (e) {
      showNotification(e instanceof Error ? e.message : 'Failed to preview voice', 'error');
    } finally {
      setPreviewingId(null);
    }
  };

  const renderVoiceTab = () => {
    const isPro = user?.subscriptionStatus === 'active';
    return (
      <>
        <h3>Voice</h3>
        <p>Choose how the assistant sounds. Preview each voice and pick your favorite.</p>
        {!isPro && (
          <div className="upgrade-prompt">
            <FiStar size={18} />
            <span>Voice is a Pro feature.</span>
            <button onClick={handleUpgrade}>Upgrade to Pro</button>
          </div>
        )}

        <div className="voice-grid">
          {curatedVoices.map(v => (
            <div key={v.id} className={`voice-card ${voiceId === v.id ? 'selected' : ''}`} onClick={() => { setVoiceId(v.id); setVoiceName(v.name);} }>
              <div className="voice-card-header">
                <div className={`voice-gender ${v.gender}`}></div>
                <h4>{v.name}</h4>
              </div>
              <p className="voice-desc">{v.description}</p>
              <div className="voice-actions">
                <button className="preview-btn" onClick={(e) => { e.stopPropagation(); previewVoice(v.id, v.name); }} disabled={!isPro || !!previewingId}>
                  {previewingId === v.id ? <FiPause /> : <FiPlay />} Preview
                </button>
                <label className="select-radio">
                  <input type="radio" checked={voiceId === v.id} onChange={() => { setVoiceId(v.id); setVoiceName(v.name);} } disabled={!isPro} />
                  <span>Use</span>
                </label>
              </div>
            </div>
          ))}
        </div>

        <div className="modal-actions">
          <button className="modal-button modal-button-cancel" onClick={handleClose}>Cancel</button>
          <button className="modal-button modal-button-save" onClick={handleSave}>
            <FiVolume2 style={{marginRight: 8}}/> Save & Close
          </button>
        </div>
      </>
    );
  };

  const handleIntegrationToggle = (integrationId: string) => {
    setEnabledIntegrations(prev =>
      prev.includes(integrationId)
        ? prev.filter(id => id !== integrationId)
        : [...prev, integrationId]
    );
  };
  
  const handleQuickAccessChange = (modelId: string) => {
    if (quickAccessModels.includes(modelId)) {
        if (selectedModel === modelId) {
            setSelectedModel('');
        }
    }

    setQuickAccessModels(prev => 
      prev.includes(modelId)
        ? prev.filter(id => id !== modelId)
        : [...prev, modelId]
    );
  };
  
  const handleModalityChange = (modelId: string, modalityToToggle: Modality, isEnabled: boolean) => {
    setModelConfigs(prevConfigs => {
      const newConfigs = [...prevConfigs];
      const configIndex = newConfigs.findIndex(c => c.id === modelId);

      if (configIndex > -1) {
        const configToUpdate = { ...newConfigs[configIndex] };
        const modalitiesSet = new Set(configToUpdate.modalities);
        if (isEnabled) modalitiesSet.add(modalityToToggle); else modalitiesSet.delete(modalityToToggle);
        configToUpdate.modalities = Array.from(modalitiesSet);
        newConfigs[configIndex] = configToUpdate;
      } else {
        const newModalities: Modality[] = ['text'];
        if (isEnabled) newModalities.push(modalityToToggle);
        newConfigs.push({ id: modelId, modalities: newModalities });
      }
      return newConfigs;
    });
  };

  const handleMenuToggle = (modelId: string, event: React.MouseEvent<HTMLButtonElement>) => {
    if (openConfigMenuId === modelId) {
      setOpenConfigMenuId(null);
    } else {
      const rect = event.currentTarget.getBoundingClientRect();
      setMenuPosition({ top: rect.bottom + window.scrollY + 5, left: rect.left + window.scrollX });
      setOpenConfigMenuId(modelId);
    }
  };

  const handleProcessAndSetContextValue = () => {
    let numValue = parseInt(editableContextValue, 10);
    if (isNaN(numValue)) {
      numValue = contextLength;
    }
    const clampedValue = Math.max(MIN_CONTEXT, Math.min(numValue, MAX_CONTEXT));
    setContextLength(clampedValue);
    setIsEditingContext(false);
  };

  const handleContextInputBlur = () => {
    handleProcessAndSetContextValue();
  };

  const handleContextInputKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {
    if (e.key === 'Enter') {
      handleProcessAndSetContextValue();
    } else if (e.key === 'Escape') {
      setEditableContextValue(String(contextLength));
      setIsEditingContext(false);
    }
  };

  const handleProcessAndSetMaxOutput = () => {
    let numValue = parseInt(editableMaxOutputValue, 10);
    if (isNaN(numValue)) {
      numValue = maxOutputTokens;
    }
    const clampedValue = Math.max(MIN_OUTPUT_TOKENS, Math.min(numValue, MAX_OUTPUT_TOKENS));
    setMaxOutputTokens(clampedValue);
    setIsEditingMaxOutput(false);
  };

  const handleMaxOutputInputBlur = () => {
    handleProcessAndSetMaxOutput();
  };

  const handleMaxOutputInputKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {
    if (e.key === 'Enter') {
      handleProcessAndSetMaxOutput();
    } else if (e.key === 'Escape') {
      setEditableMaxOutputValue(String(maxOutputTokens));
      setIsEditingMaxOutput(false);
    }
  };

  if (!isOpen) return null;

  const renderIntegrationsTab = () => {
    const isPro = user?.subscriptionStatus === 'active';

    return (
      <>
        <h3>Integrations</h3>
        <p>Connect Workspark to other services. Available for Pro users.</p>
        
        {!isPro && (
          <div className="upgrade-prompt">
            <FiStar size={18} />
            <span>Integrations are a Pro feature.</span>
            <button onClick={handleUpgrade}>Upgrade to Pro</button>
          </div>
        )}

        <div className="integrations-list">
          {isLoadingIntegrations ? (
            <p>Loading...</p>
          ) : availableIntegrations.length > 0 ? (
            availableIntegrations.map((integration) => (
              <div key={integration.id} className="integration-card">
                <div className="integration-info">
                  <h4>{integration.name}</h4>
                  <p>{integration.description}</p>
                </div>
                <div className="integration-toggle">
                  <label className="switch">
                    <input
                      type="checkbox"
                      checked={enabledIntegrations.includes(integration.id)}
                      onChange={() => handleIntegrationToggle(integration.id)}
                      disabled={!isPro}
                    />
                    <span className="slider round"></span>
                  </label>
                </div>
              </div>
            ))
          ) : (
            <p>No integrations are currently available.</p>
          )}
        </div>

        <div className="modal-actions">
          <button className="modal-button modal-button-cancel" onClick={handleClose}>Cancel</button>
          <button className="modal-button modal-button-save" onClick={handleSave}>Save & Close</button>
        </div>
      </>
    );
  };

  const renderGptTab = () => {
    const isDefaultProviderSelected = selectedProvider === 'default';
    const currentApiKey = apiKeys.find(k => k.provider === selectedProvider)?.key || '';
    const defaultModelOptions = models.filter(model => quickAccessModels.includes(model.id));
    const filteredModels = models.filter(model => 
        model.id.toLowerCase().includes(modelSearchQuery.toLowerCase())
    );
    const getApiKeyPlaceholder = () => {
        switch (selectedProvider) {
            case 'openai': return 'Required: sk-...';
            case 'anthropic': return 'Required: sk-ant-...';
            case 'gemini': return 'Required: Your Gemini API Key';
            default: return 'API Key';
        }
    };

    return (
    <>
      <h3>GPT Settings</h3>
      <p>Configure your connection to a compatible LLM provider.</p>
      
       <div className="form-group">
        <label>Provider</label>
        <ProviderSelector 
            providers={providers}
            selectedProvider={selectedProvider}
            onSelect={(id) => setSelectedProvider(id)}
        />
      </div>

      {isDefaultProviderSelected ? (
        <div className="form-group default-provider-info">
          <p className="description">
            You are using free Gemini 2.5 Flash model.
          </p>
          <p>
            Rate limits spread across all users.
          </p>
        </div>
      ) : (
        <>
          <div className="form-group">
            <label htmlFor="apiKey">API Key</label>
            <div className="input-wrapper">
              <input 
                id="apiKey" 
                type={isApiKeyVisible ? 'text' : 'password'}
                className={!isApiKeyVisible ? 'input-hidden' : ''}
                value={currentApiKey} 
                onChange={(e) => handleApiKeyChange(e.target.value)} 
                placeholder={ getApiKeyPlaceholder() }
                autoComplete="off"
              />
              <Tooltip text={isApiKeyVisible ? "Hide API Key" : "Show API Key"}>
                <button type="button" className="visibility-toggle-btn" onClick={() => setIsApiKeyVisible(prev => !prev)}>
                  {isApiKeyVisible ? <FiEyeOff size={18} /> : <FiEye size={18} />}
                </button>
              </Tooltip>
            </div>
          </div>

          {(selectedProvider === 'openai') && (
            <div className="form-group">
              <label htmlFor="baseUrl">Base URL (optional)</label>
              <input 
                  id="baseUrl" 
                  type="text" 
                  value={baseUrl} 
                  onChange={(e) => setBaseUrl(e.target.value)} 
                  placeholder="e.g., https://api.groq.com/openai/v1"
              />
            </div>
          )}
          
          <div className="form-group">
            <div className="label-with-value">
              <label htmlFor="contextLength">Total Context Length</label>
              {isEditingContext ? (
                <input
                  type="number"
                  value={editableContextValue}
                  onChange={(e) => setEditableContextValue(e.target.value)}
                  onBlur={handleContextInputBlur}
                  onKeyDown={handleContextInputKeyDown}
                  className="context-value-input"
                  autoFocus
                  onFocus={(e) => e.target.select()}
                />
              ) : (
                <span
                  onClick={() => setIsEditingContext(true)}
                  className="context-value-span"
                >
                  {contextLength}
                </span>
              )}
            </div>
            <p className="description">
              The total token window for the model (input + output). Set this to your selected model's maximum context.
            </p>
            <div className="context-slider-group">
                <input 
                    type="range" 
                    id="contextLength"
                    min={MIN_CONTEXT}
                    max={MAX_CONTEXT}
                    step="1024"
                    value={contextLength}
                    onChange={(e) => setContextLength(parseInt(e.target.value, 10))}
                    className="context-slider"
                />
            </div>
          </div>

          <div className="form-group">
            <div className="label-with-value">
              <label htmlFor="maxOutputTokens">Max Output Tokens</label>
              {isEditingMaxOutput ? (
                <input
                  type="number"
                  value={editableMaxOutputValue}
                  onChange={(e) => setEditableMaxOutputValue(e.target.value)}
                  onBlur={handleMaxOutputInputBlur}
                  onKeyDown={handleMaxOutputInputKeyDown}
                  className="context-value-input"
                  autoFocus
                  onFocus={(e) => e.target.select()}
                />
              ) : (
                <span
                  onClick={() => setIsEditingMaxOutput(true)}
                  className="context-value-span"
                >
                  {maxOutputTokens}
                </span>
              )}
            </div>
            <p className="description">
              Controls the maximum tokens the model can generate in one response. This is reserved from the total context length.
            </p>
            <div className="context-slider-group">
                <input 
                    type="range" 
                    id="maxOutputTokens"
                    min={MIN_OUTPUT_TOKENS}
                    max={MAX_OUTPUT_TOKENS}
                    step="256"
                    value={maxOutputTokens}
                    onChange={(e) => setMaxOutputTokens(parseInt(e.target.value, 10))}
                    className="context-slider"
                />
            </div>
          </div>

          {models.length > 0 && (
            <>
            <div className="form-group">
              <label>Quick Access Models</label>
              <p className="description">Select which models appear in the top-of-screen selector. Only models selected here can be set as the default.</p>
              
              <div className="model-search-wrapper">
                <input
                  type="text"
                  className="model-search-input"
                  placeholder="Search available models..."
                  value={modelSearchQuery}
                  onChange={(e) => setModelSearchQuery(e.target.value)}
                />
                <button 
                    className={`model-search-clear-btn ${modelSearchQuery ? 'visible' : ''}`}
                    onClick={() => setModelSearchQuery('')}
                  >
                    <FiX size={18} />
                </button>
              </div>
              <div className="quick-access-list">
                {filteredModels.length > 0 ? (
                  filteredModels.map(model => {
                    const config = modelConfigs.find(c => c.id === model.id) || { modalities: ['text'] };
                    const hasImageModality = config.modalities.some(modality => modality === 'image');

                    return (
                    <div key={model.id} className="quick-access-row">
                      <label className="quick-access-item">
                        <input type="checkbox" checked={quickAccessModels.includes(model.id)} onChange={() => handleQuickAccessChange(model.id)} />
                        <span className="checkbox-visual"></span>
                        <span className="model-name-text">{model.id}</span>
                      </label>
                      <div className="model-config-wrapper">
                        <button className="model-config-button" onClick={(e) => handleMenuToggle(model.id, e)} disabled={!quickAccessModels.includes(model.id)}>
                          <FiMoreVertical size={16}/>
                        </button>
                        {openConfigMenuId === model.id && (
                          <Portal>
                            <div className="model-config-menu" ref={configMenuRef} style={{ position: 'absolute', top: `${menuPosition.top}px`, left: `${menuPosition.left}px` }}>
                              <label className="config-menu-item">
                                  <input type="checkbox" checked disabled />
                                  <span className="checkbox-visual"></span>
                                  <span>Text</span>
                              </label>
                              <label className="config-menu-item">
                                  <input type="checkbox" checked={hasImageModality} onChange={(e) => handleModalityChange(model.id, 'image', e.target.checked)} />
                                  <span className="checkbox-visual"></span>
                                  <span>Image</span>
                              </label>
                            </div>
                          </Portal>
                        )}
                      </div>
                    </div>
                    );
                  })
                ) : (
                  <div className="no-models-found">
                    No models found matching your search.
                  </div>
                )}
              </div>
            </div>

            <div className="form-group">
                <label htmlFor="model">Default Model</label>
                <div className="model-select-wrapper">
                <CustomModelSelector
                    models={defaultModelOptions}
                    selectedModel={selectedModel}
                    onSelect={setSelectedModel}
                    disabled={defaultModelOptions.length === 0}
                    placeholderText="Select from Quick Access models"
                />
                <Tooltip text={!currentApiKey ? "API Key is required" : "Save credentials & Refresh models" }>
                    <button 
                    className="refresh-button" 
                    onClick={handleManualFetch} 
                    disabled={isFetching || !currentApiKey}
                    >
                    {isFetching ? '...' : <FiRefreshCw size={16} />}
                    </button>
                </Tooltip>
                </div>
            </div>
            </>
          )}

          {models.length === 0 && (
             <div className="form-group">
                <label htmlFor="model">Models</label>
                <div className="model-select-wrapper">
                    <div className="placeholder-selector">
                        {isFetching ? 'Loading models...' : 'Click Refresh to load available models'}
                    </div>
                    <Tooltip text={!currentApiKey ? "API Key is required" : "Save credentials & Refresh models" }>
                        <button 
                        className="refresh-button" 
                        onClick={handleManualFetch} 
                        disabled={isFetching || !currentApiKey}
                        >
                        {isFetching ? '...' : <FiRefreshCw size={16} />}
                        </button>
                    </Tooltip>
                </div>
                {fetchError && <p className="error-text">{fetchError}</p>}
            </div>
          )}
        </>
      )}
      
      <div className="modal-actions">
        <button className="modal-button modal-button-cancel" onClick={handleClose}>Cancel</button>
        <button className="modal-button modal-button-save" onClick={handleSave}>Save & Close</button>
      </div>
    </>
    );
  };
  
  const handleManageSubscription = async () => {
    try {
      const response = await api('/stripe/create-portal-session', { method: 'POST' });
      const data = await response.json();
      if (!response.ok) throw new Error(data.msg || 'Could not open management portal.');
      window.location.href = data.url;
    } catch (error) {
      showNotification(error instanceof Error ? error.message : 'An error occurred.', 'error');
    }
  };

  // --- START: New Subscription Handler ---
  const handleUpgrade = () => {
    navigate('/app/pricing');
    handleClose(); // Close the modal after navigating
  };
  // --- END: New Subscription Handler ---

  // --- START: Updated Subscription Tab ---
  const renderSubscriptionTab = () => {
    const status = user?.subscriptionStatus;
    const isPro = status === 'active';
    const isCanceled = status === 'canceled';
    const isPaymentIssue = ['past_due', 'unpaid', 'incomplete'].includes(status || '');

    let planName = 'Free Plan';
    let planFeatures = freeFeatures;
    let statusText = 'Active';
    let statusClass = 'free';
    let description = 'You are currently on the Free plan, with access to basic features.';
    let ctaButton: React.ReactNode = (
      <button className="modal-button sub-button upgrade" onClick={handleUpgrade}>
        Upgrade to Pro
      </button>
    );

    if (isPro) {
      planName = 'Pro Plan';
      planFeatures = proFeatures;
      statusText = 'Active';
      statusClass = 'active';
      description = 'Your subscription is active. All Pro features are available to you.';
      ctaButton = (
        <button className="modal-button sub-button manage" onClick={handleManageSubscription} disabled={!user?.stripeCustomerId}>
          Manage Subscription
        </button>
      );
    } else if (isCanceled) {
      planName = 'Pro Plan';
      planFeatures = proFeatures;
      statusText = 'Canceled';
      statusClass = 'canceled';
      description = 'Your plan is canceled and will not renew. You can use Pro features until the end of the current billing period.';
      ctaButton = (
        <button className="modal-button sub-button upgrade" onClick={handleUpgrade}>
          Resubscribe to Pro
        </button>
      );
    } else if (isPaymentIssue) {
      planName = 'Pro Plan';
      planFeatures = proFeatures;
      statusText = 'Payment Due';
      statusClass = 'warning';
      description = 'Your payment failed. Please update your payment method to restore access to Pro features.';
      ctaButton = (
        <button className="modal-button sub-button warning" onClick={handleManageSubscription} disabled={!user?.stripeCustomerId}>
          Update Payment Info
        </button>
      );
    }

    return (
      <>
        <h3>Subscription</h3>
        <p>Manage your billing and subscription plan.</p>
        <div className={`subscription-info-card ${statusClass}`}>
          <div className="plan-header">
            <h4>{planName}</h4>
            <span className={`status-badge ${statusClass}`}>{statusText}</span>
          </div>
          <p className="plan-description">{description}</p>
          <ul className="plan-features-list">
            {planFeatures.map((feature, index) => (
              <li key={index}>
                <FiCheckCircle size={16} />
                <span>{feature}</span>
              </li>
            ))}
          </ul>
          <div className="plan-actions">
            {ctaButton}
          </div>
        </div>
      </>
    );
  };
  // --- END: Updated Subscription Tab ---

  const renderAppearanceTab = () => (
    <>
      <h3>Appearance</h3>
      <p>Customize the look and feel of the application.</p>
      <div className="form-group">
        <label>Theme</label>
        <div className="theme-options">
          <div className={`theme-card ${theme === 'light' ? 'selected' : ''}`} onClick={() => setTheme('light')} data-theme-name="light">
            <div className="theme-preview">Aa</div>
            <span>Light</span>
          </div>
          <div className={`theme-card ${theme === 'dark' ? 'selected' : ''}`} onClick={() => setTheme('dark')} data-theme-name="dark">
            <div className="theme-preview">Aa</div>
            <span>Dark</span>
          </div>
        </div>
      </div>
    </>
  );

  return (
    <div className={`modal-overlay ${isClosing ? 'closing' : ''}`} onClick={handleClose}>
      <div className={`modal-content ${isClosing ? 'closing' : ''}`} onClick={(e) => e.stopPropagation()}>
        <aside className="settings-sidebar">
          <h2>Settings</h2>
          <button className={`settings-tab-button ${activeTab === 'GPT' ? 'active' : ''}`} onClick={() => setActiveTab('GPT')}>
            <FiCpu size={18} />
            <span>GPT</span>
          </button>
          <button className={`settings-tab-button ${activeTab === 'Integrations' ? 'active' : ''}`} onClick={() => setActiveTab('Integrations')}>
            <FiLink size={18} />
            <span>Integrations</span>
          </button>
          <button className={`settings-tab-button ${activeTab === 'Subscription' ? 'active' : ''}`} onClick={() => setActiveTab('Subscription')}>
            <FiCreditCard size={18} />
            <span>Subscription</span>
          </button>
          <button className={`settings-tab-button ${activeTab === 'Appearance' ? 'active' : ''}`} onClick={() => setActiveTab('Appearance')}>
            <FiSliders size={18} />
            <span>Appearance</span>
          </button>
          <button className={`settings-tab-button ${activeTab === 'Voice' ? 'active' : ''}`} onClick={() => setActiveTab('Voice')}>
            <FiVolume2 size={18} />
            <span>Voice</span>
          </button>
        </aside>
        <main className="settings-content">
          {activeTab === 'GPT' && renderGptTab()}
          {activeTab === 'Integrations' && renderIntegrationsTab()}
          {activeTab === 'Subscription' && renderSubscriptionTab()}
          {activeTab === 'Appearance' && renderAppearanceTab()}
          {activeTab === 'Voice' && renderVoiceTab()}
        </main>
      </div>
    </div>
  );
};

export default SettingsModal;
- - - Sidebar.tsx:
// src/components/Sidebar.tsx
import { useState, useRef, useEffect } from 'react';
import { NavLink, useNavigate } from 'react-router-dom';
import '../css/Sidebar.css';
import { FiEdit, FiSettings, FiLogOut, FiEdit2, FiTrash, FiX, FiTrash2, FiStar, FiBell } from 'react-icons/fi';
import { HiOutlineDotsHorizontal } from 'react-icons/hi';
import { TbLayoutSidebarLeftCollapse } from 'react-icons/tb';
import { useSettings } from '../contexts/SettingsContext';
import { useChat } from '../contexts/ChatContext';
import ConfirmationModal from './ConfirmationModal';
import RenameModal from './RenameModal';
import NotificationsModal from './NotificationsModal';
import Tooltip from './Tooltip';
import { requestNotificationPermission } from '../utils/scheduler';

import '../css/ConfirmationModal.css';
import '../css/RenameModal.css';

interface SidebarProps {
  onOpenSettings: () => void;
  isMobileOpen: boolean;
  onClose: () => void;
  isCollapsed: boolean;
  onToggleCollapse: () => void;
}

const Sidebar = ({ onOpenSettings, isMobileOpen, onClose, isCollapsed, onToggleCollapse }: SidebarProps) => {
  const { user, logout } = useSettings();
  const { chatList, renameChat, deleteChat, clearAllChats, activeChatId, isLoadingChatList } = useChat();
  const navigate = useNavigate();
  
  const [isUserMenuOpen, setIsUserMenuOpen] = useState(false);
  const userMenuRef = useRef<HTMLDivElement>(null);

  const [openMenuId, setOpenMenuId] = useState<string | null>(null);
  const menuRef = useRef<HTMLDivElement>(null);

  const [isDeleteModalOpen, setDeleteModalOpen] = useState(false);
  const [isClearAllModalOpen, setClearAllModalOpen] = useState(false);
  const [isRenameModalOpen, setRenameModalOpen] = useState(false);
  
  // State for Notifications Modal
  const [isNotificationsModalOpen, setIsNotificationsModalOpen] = useState(false);

  const [activeChat, setActiveChat] = useState<{ id: string; title: string } | null>(null);

  const [isBannerVisible, setIsBannerVisible] = useState(
    localStorage.getItem('fexo-upgrade-banner-hidden') !== 'true'
  );

  const handleDismissBanner = (e: React.MouseEvent) => {
    e.preventDefault();
    e.stopPropagation();
    localStorage.setItem('fexo-upgrade-banner-hidden', 'true');
    setIsBannerVisible(false);
  };

  const handleNotificationsClick = async () => {
    // Request permission immediately on click
    await requestNotificationPermission();
    // Then open modal
    setIsNotificationsModalOpen(true);
    onClose(); // close mobile sidebar
  };

  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (userMenuRef.current && !userMenuRef.current.contains(event.target as Node)) {
        setIsUserMenuOpen(false);
      }
      if (menuRef.current && !menuRef.current.contains(event.target as Node)) {
        setOpenMenuId(null);
      }
    };
    if (isUserMenuOpen || openMenuId) {
      document.addEventListener('mousedown', handleClickOutside);
    }
    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
    };
  }, [isUserMenuOpen, openMenuId]);
  
  const handleSettingsClick = () => {
    onOpenSettings();
    setIsUserMenuOpen(false);
    onClose();
  };
  
  const handleLogoutClick = () => {
    logout();
    setIsUserMenuOpen(false);
    onClose();
  };
  
  const handleNewChat = () => {
    navigate('/app');
    onClose();
  }
  
  const handleNavLinkClick = () => {
    onClose();
  }

  const handleLogoLinkClick = (e: React.MouseEvent) => {
    if (isCollapsed) {
      e.preventDefault();
      return;
    }
    handleNewChat();
  };

  const openRenameModal = (e: React.MouseEvent, chatId: string, currentTitle: string) => {
    e.preventDefault();
    e.stopPropagation();
    setActiveChat({ id: chatId, title: currentTitle });
    setRenameModalOpen(true);
    setOpenMenuId(null);
  };

  const openDeleteModal = (e: React.MouseEvent, chatId: string) => {
    e.preventDefault();
    e.stopPropagation();
    setActiveChat({ id: chatId, title: '' });
    setDeleteModalOpen(true);
    setOpenMenuId(null);
  };

  const handleConfirmDelete = async () => {
    if (activeChat) {
      await deleteChat(activeChat.id);
      if (activeChatId === activeChat.id) {
        navigate('/app');
      }
    }
    setDeleteModalOpen(false);
    setActiveChat(null);
    onClose();
  };

  const handleConfirmRename = async (newTitle: string) => {
    if (activeChat) {
      await renameChat(activeChat.id, newTitle);
    }
    setRenameModalOpen(false);
    setActiveChat(null);
  };

  const handleConfirmClearAll = async () => {
    await clearAllChats();
    setClearAllModalOpen(false);
    onClose();
    navigate('/app');
  };

  return (
    <>
      {isMobileOpen && <div className="sidebar-overlay" onClick={onClose}></div>}
      
      <aside className={`sidebar ${isMobileOpen ? 'mobile-open' : ''} ${isCollapsed ? 'is-collapsed' : ''}`}>
        <div className="sidebar-top">
          <NavLink to="/app" className="sidebar-logo-link" onClick={handleLogoLinkClick}>
            <img src="/worksparkai.svg" alt="Workspark AI Logo" className="sidebar-logo" />
            <span className="sidebar-logo-text">Workspark AI</span>
          </NavLink>
          
          <button className="sidebar-button collapse-button" onClick={onToggleCollapse}>
            <TbLayoutSidebarLeftCollapse size={20} />
          </button>
          
          <button className="sidebar-button mobile-close-button" onClick={onClose} aria-label="Close menu">
            <FiX size={24} />
          </button>
        </div>

        <nav className="sidebar-nav">
          <ul>
            {/* 1. New Chat Button (Moved to top) */}
            <li>
              <button className="sidebar-button new-chat-button" onClick={handleNewChat}>
                <FiEdit size={20} />
                <span>New Chat</span>
              </button>
            </li>

            {/* 2. Visible Divider */}
            <li className="sidebar-divider"></li>

            {/* 3. Notifications Button (Moved below divider) */}
            <li>
              <button 
                className="sidebar-button nav-button notifications-btn" 
                onClick={handleNotificationsClick}
              >
                <FiBell size={20} />
                <span>Notifications</span>
              </button>
            </li>
          </ul>
        </nav>

        <div className="sidebar-conversations">
          <div className="convos-header">
            <span>Chats</span>
          </div>
          {isLoadingChatList ? (
            <div className="convo-list-loading">
              {[...Array(4)].map((_, i) => (
                <div key={i} className="convo-list-item-skeleton" />
              ))}
            </div>
          ) : (
            <ul className="convo-list">
              {chatList.map((chat) => (
                <li key={chat._id}>
                  <NavLink to={`c/${chat._id}`} onClick={handleNavLinkClick}>
                    {chat.title || 'Untitled Chat'}
                  </NavLink>
                  <Tooltip text="More options">
                    <button
                      className={`chat-item-menu-trigger ${openMenuId === chat._id ? 'active' : ''}`}
                      onClick={(e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        setOpenMenuId(openMenuId === chat._id ? null : chat._id);
                      }}
                    >
                      <HiOutlineDotsHorizontal size={16} />
                    </button>
                  </Tooltip>
                  {openMenuId === chat._id && (
                    <div className="chat-item-actions-menu" ref={menuRef}>
                      <button className="menu-action-button" onClick={(e) => openRenameModal(e, chat._id, chat.title)}>
                        <FiEdit2 size={14} />
                        <span>Rename</span>
                      </button>
                      <button className="menu-action-button destructive" onClick={(e) => openDeleteModal(e, chat._id)}>
                        <FiTrash size={14} />
                        <span>Delete</span>
                      </button>
                    </div>
                  )}
                </li>
              ))}
            </ul>
          )}
        </div>

        <div className="sidebar-footer">
          {user?.subscriptionStatus !== 'active' && !isCollapsed && isBannerVisible && (
            <div className="upgrade-banner-wrapper">
              <div className="upgrade-banner" onClick={() => navigate('/app/pricing')}>
                <FiStar />
                <span>Upgrade to Pro</span>
              </div>
              <button 
                className="dismiss-banner-btn" 
                onClick={handleDismissBanner} 
                aria-label="Dismiss upgrade banner"
              >
                <FiX size={14} />
              </button>
            </div>
          )}
          <div className="user-profile-wrapper" ref={userMenuRef}>
            <div className={`user-profile-menu ${isUserMenuOpen ? 'open' : ''}`}>
               <button className="menu-button" onClick={handleSettingsClick}>
                  <FiSettings size={16} />
                  <span>Settings</span>
              </button>
              <button 
                className="menu-button destructive" 
                onClick={() => { setClearAllModalOpen(true); setIsUserMenuOpen(false); onClose(); }}
              >
                  <FiTrash2 size={16} />
                  <span>Clear conversations</span>
              </button>
              <div className="user-profile-menu-divider" />
              <button className="menu-button" onClick={handleLogoutClick} >
                  <FiLogOut size={18} />
                  <span>Logout</span>
              </button>
            </div>

            <div className="user-profile" onClick={() => setIsUserMenuOpen(!isUserMenuOpen)}>
              <div className="user-avatar">{user?.email?.[0]?.toUpperCase() || 'U'}</div>
              <span className="user-name">{user?.email || 'User'}</span>
              <button className="user-options-button">
                  <HiOutlineDotsHorizontal size={20} />
              </button>
            </div>
          </div>
        </div>
      </aside>

      <ConfirmationModal
        isOpen={isDeleteModalOpen}
        onClose={() => setDeleteModalOpen(false)}
        onConfirm={handleConfirmDelete}
        title="Delete Chat?"
        message="Are you sure you want to delete this chat? This action cannot be undone."
        confirmText="Delete"
        isDestructive={true}
      />

      <ConfirmationModal
        isOpen={isClearAllModalOpen}
        onClose={() => setClearAllModalOpen(false)}
        onConfirm={handleConfirmClearAll}
        title="Clear All Conversations?"
        message="Are you sure you want to delete all of your chats? This action is permanent and cannot be undone."
        confirmText="Delete All"
        isDestructive={true}
      />

      <NotificationsModal 
        isOpen={isNotificationsModalOpen} 
        onClose={() => setIsNotificationsModalOpen(false)} 
      />

      {activeChat && (
        <RenameModal
          isOpen={isRenameModalOpen}
          onClose={() => setRenameModalOpen(false)}
          onRename={handleConfirmRename}
          currentTitle={activeChat.title}
        />
      )}
    </>
  );
};

export default Sidebar;
- - - SidePanel.tsx:
// src/components/SidePanel.tsx
import { useEffect, useState, useCallback } from 'react';
import { FiX, FiExternalLink } from 'react-icons/fi';
import { useSidePanel } from '../contexts/SidePanelContext';
import Portal from './Portal';
import '../css/SidePanel.css';

const SidePanel = () => {
  const { isOpen, closePanel, panelType, panelData } = useSidePanel();
  const [isClosing, setIsClosing] = useState(false);

  // Handle the closing sequence: animate first, then update context to unmount
  const handleClose = useCallback(() => {
    if (isClosing) return; // Prevent double triggering
    setIsClosing(true);
    setTimeout(() => {
      closePanel();
      setIsClosing(false);
    }, 300); // Match the CSS animation duration (0.3s)
  }, [closePanel, isClosing]);

  // Close on Escape key
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key === 'Escape' && isOpen) {
        handleClose();
      }
    };
    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [isOpen, handleClose]);

  if (!isOpen) return null;

  const renderSources = () => (
    <div className="side-panel-content">
      <div className="side-panel-header">
        <h3>Sources</h3>
        <button onClick={handleClose} className="close-panel-btn"><FiX size={20} /></button>
      </div>
      <div className="sources-list">
        {panelData?.sources?.map((source: any, index: number) => (
          <a key={index} href={source.url} target="_blank" rel="noopener noreferrer" className="source-card">
            <div className="source-card-header">
              <div className="source-favicon">
                <img 
                  src={`https://www.google.com/s2/favicons?domain=${new URL(source.url).hostname}&sz=32`} 
                  alt="favicon" 
                  onError={(e) => {
                    (e.target as HTMLImageElement).style.display = 'none';
                    const parent = (e.target as HTMLImageElement).parentElement;
                    if (parent) parent.innerHTML = '<svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><circle cx="12" cy="12" r="10"></circle><line x1="2" y1="12" x2="22" y2="12"></line><path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"></path></svg>'; 
                  }} 
                />
              </div>
              <span className="source-title">{source.title}</span>
            </div>
            <div className="source-snippet">{source.snippet}</div>
            <div className="source-url">
              {new URL(source.url).hostname} <FiExternalLink size={12} />
            </div>
          </a>
        ))}
      </div>
    </div>
  );

  return (
    <Portal>
      <div 
        className={`side-panel-overlay ${isClosing ? 'closing' : ''}`} 
        onClick={handleClose}
      ></div>
      <div className={`side-panel-container ${isClosing ? 'closing' : ''}`}>
        {panelType === 'sources' && renderSources()}
      </div>
    </Portal>
  );
};

export default SidePanel;
- - - StreamingText.tsx:
// src/components/StreamingText.tsx
import { useState, useEffect, useRef, memo } from 'react';
import ReactMarkdown from 'react-markdown';
import type { Components } from 'react-markdown';
import remarkGfm from 'remark-gfm';
import remarkMath from 'remark-math';
import rehypeKatex from 'rehype-katex';
import '../css/StreamingText.css';

interface StreamingTextProps {
  content: string;
  isStreaming: boolean;
  components?: Components;
}

const DISPLAY_SPEED = 35; // Display new content every 35ms for smooth animation (1.5x faster)
const CATCHUP_SPEED = 10; // Much faster when catching up after streaming ends

const StreamingText = memo(({ content, isStreaming, components }: StreamingTextProps) => {
  const [displayedContent, setDisplayedContent] = useState(content);
  const bufferRef = useRef(content);
  const displayedLengthRef = useRef(content.length);
  const timerRef = useRef<number | null>(null);
  const containerRef = useRef<HTMLDivElement>(null);
  const isCatchingUpRef = useRef(false);
  const hasStartedStreamingRef = useRef(false);

  useEffect(() => {
    if (!isStreaming && !isCatchingUpRef.current) {
      // Streaming ended - switch to catch-up mode
      const buffer = content; // Use latest content
      const currentDisplayed = displayedLengthRef.current;
      
      if (currentDisplayed < buffer.length) {
        // There's remaining content - speed up to catch up
        isCatchingUpRef.current = true;
        bufferRef.current = buffer;
        
        // Clear existing timer and start faster one
        if (timerRef.current) {
          clearInterval(timerRef.current);
          timerRef.current = null;
        }
        
        // Use setTimeout chain for catch-up to ensure it runs
        const catchUpNextChunk = () => {
          const currentBuffer = bufferRef.current;
          const displayed = displayedLengthRef.current;
          
          if (displayed >= currentBuffer.length) {
            // Fully caught up
            isCatchingUpRef.current = false;
            return;
          }

          // Display more content - show ~3-5 words at a time
          const remainingContent = currentBuffer.substring(displayed);
          const words = remainingContent.split(/\s+/).filter(w => w.trim());
          
          if (words.length === 0) {
            isCatchingUpRef.current = false;
            return;
          }
          
          // Take 3-5 words
          const wordsToShow = Math.min(words.length, Math.floor(Math.random() * 3) + 3);
          const chunkLength = remainingContent.split(/\s+/).slice(0, wordsToShow).join(' ').length + 1;
          
          const newDisplayLength = Math.min(displayed + chunkLength, currentBuffer.length);
          const newContent = currentBuffer.substring(0, newDisplayLength);
          
          setDisplayedContent(newContent);
          displayedLengthRef.current = newDisplayLength;
          
          // Schedule next chunk
          setTimeout(catchUpNextChunk, CATCHUP_SPEED);
        };
        
        // Start catch-up
        setTimeout(catchUpNextChunk, CATCHUP_SPEED);
      }
      
      return;
    }

    // Update buffer with new content
    bufferRef.current = content;

    // Only start streaming if content is actually growing
    if (!hasStartedStreamingRef.current) {
      hasStartedStreamingRef.current = true;
      displayedLengthRef.current = 0;
      setDisplayedContent('');
    }

    // Start interval to gradually display buffered content
    if (!timerRef.current) {
      timerRef.current = setInterval(() => {
        const buffer = bufferRef.current;
        const currentDisplayed = displayedLengthRef.current;
        
        if (currentDisplayed >= buffer.length) {
          // We've caught up, no need to update
          return;
        }

        // Display more content - show ~3-5 words at a time
        const remainingContent = buffer.substring(currentDisplayed);
        const words = remainingContent.split(/\s+/).filter(w => w.trim());
        
        if (words.length === 0) return;
        
        // Take 3-5 words
        const wordsToShow = Math.min(words.length, Math.floor(Math.random() * 3) + 3);
        const chunkLength = remainingContent.split(/\s+/).slice(0, wordsToShow).join(' ').length + 1;
        
        const newDisplayLength = Math.min(currentDisplayed + chunkLength, buffer.length);
        const newContent = buffer.substring(0, newDisplayLength);
        
        setDisplayedContent(newContent);
        displayedLengthRef.current = newDisplayLength;
      }, DISPLAY_SPEED);
    }

    return () => {
      if (timerRef.current) {
        clearInterval(timerRef.current);
        timerRef.current = null;
      }
    };
  }, [content, isStreaming]);

  useEffect(() => {
    return () => {
      if (timerRef.current) {
        clearInterval(timerRef.current);
      }
    };
  }, []);

  // Use displayed content only if streaming has started, otherwise show full content
  const currentDisplayText = (isStreaming || isCatchingUpRef.current) && hasStartedStreamingRef.current 
    ? displayedContent 
    : content;

  const previousLengthRef = useRef(currentDisplayText.length);
  const [showNewContent, setShowNewContent] = useState(false);

  useEffect(() => {
    if (currentDisplayText.length > previousLengthRef.current) {
      setShowNewContent(true);
      const timer = setTimeout(() => setShowNewContent(false), 300);
      previousLengthRef.current = currentDisplayText.length;
      return () => clearTimeout(timer);
    }
  }, [currentDisplayText]);

  return (
    <div 
      ref={containerRef}
      className={`streaming-text-container ${isStreaming ? 'is-streaming' : ''} ${showNewContent ? 'content-updating' : ''}`}
    >
      <div className="markdown-body">
        <ReactMarkdown
          remarkPlugins={[remarkGfm, remarkMath]}
          rehypePlugins={[rehypeKatex]}
          components={components}
        >
          {currentDisplayText}
        </ReactMarkdown>
      </div>
    </div>
  );
});

StreamingText.displayName = 'StreamingText';

export default StreamingText;
- - - SubscriptionSuccessOverlay.tsx:
// src/components/SubscriptionSuccessOverlay.tsx
import { FiCheckCircle } from 'react-icons/fi';
import Portal from './Portal';
import '../css/SubscriptionSuccessOverlay.css';

interface SubscriptionSuccessOverlayProps {
  onClose: () => void;
}

const SubscriptionSuccessOverlay = ({ onClose }: SubscriptionSuccessOverlayProps) => {
  return (
    <Portal>
      <div className="sub-success-overlay" role="dialog" aria-modal="true" aria-label="Subscription successful">
        <div className="sub-success-backdrop" onClick={onClose} />
        <div className="sub-success-card">
          <div className="confetti" aria-hidden="true">
            <span></span><span></span><span></span><span></span><span></span>
          </div>
          <div className="icon-wrap">
            <FiCheckCircle size={36} />
          </div>
          <h2 className="title">Welcome to Pro 🎉</h2>
          <p className="subtitle">Thanks for upgrading! You now have access to:</p>
          <ul className="feature-list">
            <li>Voice chat included</li>
            <li>Premium default model (GPT-5)</li>
            <li>Code Interpreter & File Analysis</li>
            <li>Web Search capabilities</li>
            <li>Bring your own API keys</li>
            <li>Priority support</li>
          </ul>
          <button className="cta-button" onClick={onClose}>Start exploring</button>
        </div>
      </div>
    </Portal>
  );
};

export default SubscriptionSuccessOverlay;
- - - Tooltip.tsx:
// src/components/Tooltip.tsx
import { useState, type ReactNode, Children, isValidElement, useRef, useLayoutEffect } from 'react';
import { createPortal } from 'react-dom';
import '../css/Tooltip.css';

interface TooltipProps {
  children: ReactNode;
  text: string;
  className?: string;
}

const Tooltip = ({ children, text, className }: TooltipProps) => {
  const [isVisible, setIsVisible] = useState(false);
  const [style, setStyle] = useState({});
  const triggerRef = useRef<HTMLDivElement>(null);
  const tooltipRef = useRef<HTMLDivElement>(null);

  if (!text) {
    return <>{children}</>;
  }

  // Attempt to check for a `disabled` prop on the first valid child element.
  let isDisabled = false;
  const childArray = Children.toArray(children);
  if (childArray.length > 0 && isValidElement(childArray[0])) {
      isDisabled = (childArray[0].props as any).disabled;
  }

  const handleMouseEnter = () => {
    if (isDisabled || !triggerRef.current) return;
    setIsVisible(true);
  };
  
  useLayoutEffect(() => {
    if (isVisible && triggerRef.current && tooltipRef.current) {
      const triggerRect = triggerRef.current.getBoundingClientRect();
      const tooltipRect = tooltipRef.current.getBoundingClientRect();

      // --- UPDATED: Position tooltip below the trigger element ---
      const top = triggerRect.bottom + 8; // 8px gap below the trigger
      const left = triggerRect.left + (triggerRect.width / 2) - (tooltipRect.width / 2);

      setStyle({
        top: `${top}px`,
        left: `${left}px`,
      });
    }
  }, [isVisible]);

  return (
    <div
      ref={triggerRef}
      className={`tooltip-container ${className || ''}`}
      onMouseEnter={handleMouseEnter}
      onMouseLeave={() => setIsVisible(false)}
    >
      {children}
      {createPortal(
        <div 
          ref={tooltipRef}
          className={`tooltip-content ${isVisible ? 'visible' : ''}`}
          style={style}
        >
          {text}
        </div>,
        document.body
      )}
    </div>
  );
};

export default Tooltip;
- - - VoiceChatModal.tsx:
// src/components/VoiceChatModal.tsx
import { useState, useEffect, useRef, useCallback } from 'react';
import { FiX, FiAlertTriangle } from 'react-icons/fi';
import { useChat } from '../contexts/ChatContext';
import { useSettings } from '../contexts/SettingsContext';
import { useNotification } from '../contexts/NotificationContext';
import { API_BASE_URL } from '../utils/api';
import '../css/VoiceChatModal.css';
import Portal from './Portal';
import type { Message } from '../types';
import CodeAnalysisBlock from './CodeAnalysisBlock';
import SearchBlock from './SearchBlock';
import AnalysisBlock from './AnalysisBlock';
import GeolocationBlock from './GeolocationBlock';
import GeolocationRequestBlock from './GeolocationRequestBlock';
import GoogleMapsBlock from './GoogleMapsBlock';
import ImageViewer from './ImageViewer';

interface VoiceChatModalProps {
  isOpen: boolean;
  onClose: () => void;
}

const SPEECH_START_THRESHOLD = 0.19; // Start speaking when above this RMS
const SPEECH_STOP_THRESHOLD = 0.15; // Consider silence only when below this RMS (hysteresis)
const SILENCE_DURATION_MS = 2800; // Longer hangover to avoid early cutoff
const MIN_RECORDING_MS = 1100; // Require a bit longer minimum capture
const MIN_AUDIO_BYTES = 2000; // Minimum audio size to send

const VoiceChatModal = ({ isOpen, onClose }: VoiceChatModalProps) => {
  const [isListening, setIsListening] = useState(false);
  const [isMicReady, setIsMicReady] = useState(false); // triggers re-render when mic is ready
  const [isSpeaking, setIsSpeaking] = useState(false);
  const [isRecording, setIsRecording] = useState(false);
  const [isThinking, setIsThinking] = useState(false); // UI hint while waiting for assistant
  const [voiceError, setVoiceError] = useState<string | null>(null);
  const { sendMessage, messages, isStreaming, activeChatId } = useChat();
  const { user } = useSettings();
  const { showNotification } = useNotification();

  // Kept for potential fallback to browser TTS; not used after switching to ElevenLabs
  // const speechSynthesisRef = useRef<SpeechSynthesisUtterance | null>(null);
  const audioRef = useRef<HTMLAudioElement | null>(null);
  const audioUnlockedRef = useRef(false);
  const playbackGenerationRef = useRef(0); // increment when we intentionally interrupt playback
  // Playback queue of ready audio URLs; each is played sequentially with no delay
  const playbackQueueRef = useRef<Array<{ url: string; text: string }>>([]);
  const isPlayingQueueRef = useRef(false);
  const ttsServerAvailableRef = useRef(true);
  const pendingTextBufferRef = useRef<string>('');
  const lastAssistantProcessedLenRef = useRef<number>(0);
  const isProcessingRef = useRef(false);
  const lastSpokenMessageIdRef = useRef<string | null>(null);
  // removed awaitingAssistantRef gating; auto-resume is based on concrete end-of-turn signals
  // Per-reply management
  const currentReplyIdRef = useRef<string | null>(null);
  const replyUseFallbackRef = useRef<boolean>(false);
  const spokenSegmentsSetRef = useRef<Set<string>>(new Set());
  // TTS concurrency and cooldown
  const maxConcurrentTts = 2;
  const MIN_TTS_SPACING_MS = 250; // small global delay between provider requests
  const SPEECH_GAP_MS = 200; // gap between spoken segments
  const currentFetchesRef = useRef<number>(0);
  const pendingTtsQueueRef = useRef<Array<{ text: string; replyId: string }>>([]);
  const pumpingRef = useRef<boolean>(false);
  const providerCooldownUntilRef = useRef<number>(0);
  const nextAllowedTtsStartAtRef = useRef<number>(0);

  const mediaStreamRef = useRef<MediaStream | null>(null);
  const mediaRecorderRef = useRef<MediaRecorder | null>(null);
  const audioContextRef = useRef<AudioContext | null>(null);
  const analyserRef = useRef<AnalyserNode | null>(null);
  const animationFrameRef = useRef<number | null>(null);
  const audioChunksRef = useRef<Blob[]>([]);
  const recordingStartTimeRef = useRef<number>(0);
  const lastSoundTimeRef = useRef<number>(0);
  const smoothedRmsRef = useRef<number>(0);
  const [viewerSrc, setViewerSrc] = useState<string | null>(null);
  const [isViewerOpen, setIsViewerOpen] = useState(false);

  const handleOpenViewer = useCallback((src: string) => {
    setViewerSrc(src);
    setIsViewerOpen(true);
  }, []);

  const cleanupResources = useCallback(() => {
    
    
    if (animationFrameRef.current !== null) {
      cancelAnimationFrame(animationFrameRef.current);
      animationFrameRef.current = null;
    }

    if (mediaRecorderRef.current) {
      try {
        if (mediaRecorderRef.current.state !== 'inactive') {
          mediaRecorderRef.current.stop();
        }
      } catch (_) {}
      mediaRecorderRef.current.ondataavailable = null;
      mediaRecorderRef.current.onstop = null;
      mediaRecorderRef.current = null;
    }

    if (audioContextRef.current) {
      audioContextRef.current.close().catch(() => {});
      audioContextRef.current = null;
    }

    if (mediaStreamRef.current) {
      mediaStreamRef.current.getTracks().forEach((track) => track.stop());
      mediaStreamRef.current = null;
    }

    analyserRef.current = null;
    audioChunksRef.current = [];
  }, []);

  // Convert stage directions to speech-friendly cues
  const sanitizeForTTS = (input: string) => {
    let s = input;
    s = s.replace(/\[(laughs|laughing|chuckles)\]/gi, 'Haha,');
    s = s.replace(/\[(surprised|gasp|gasps)\]/gi, 'Oh!');
    s = s.replace(/\[(sigh|sighs)\]/gi, 'Sigh,');
    s = s.replace(/\[[^\]]+\]/g, '');
    s = s.replace(/\s{2,}/g, ' ').trim();
    return s;
  };

  // Fetch TTS URL for a chunk with retry/backoff to handle rate limits
  const fetchTtsUrl = useCallback(async (text: string): Promise<string> => {
    const token = localStorage.getItem('fexo-token');
    const payload = {
      text: sanitizeForTTS(text),
      voiceId: user?.voiceSettings?.voiceId,
    };
    const attempt = async (delayMs: number) => {
      if (delayMs > 0) await new Promise((r) => setTimeout(r, delayMs));
      const response = await fetch(`${API_BASE_URL}/api/voice/tts`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          Accept: 'audio/mpeg',
          ...(token ? { 'x-auth-token': token } : {}),
        },
        body: JSON.stringify(payload),
      });
      return response;
    };
    const backoffs = [0, 600, 1200];
    let lastErr: any = null;
    for (let i = 0; i < backoffs.length; i++) {
      try {
        const res = await attempt(backoffs[i]);
        if (!res.ok) {
          const status = res.status;
          // Try to surface server error json when available
          let serverMsg: string | undefined;
          try {
            const j = await res.json();
            serverMsg = j?.error || j?.detail?.status;
          } catch {}
          if (status === 429 || status >= 500) {
            lastErr = new Error(serverMsg || `TTS failed with ${status}`);
            continue; // retry with next backoff
          } else {
            throw new Error(serverMsg || `TTS request failed (${status})`);
          }
        }
        const arrayBuf = await res.arrayBuffer();
        const blob = new Blob([arrayBuf], { type: 'audio/mpeg' });
        return URL.createObjectURL(blob);
      } catch (e) {
        lastErr = e;
      }
    }
    throw lastErr || new Error('TTS request failed');
  }, [user?.voiceSettings?.voiceId]);

  const unlockAudioPlayback = useCallback(async () => {
    if (audioUnlockedRef.current) return;
    try {
      // Use Web Audio to unlock audio on user gesture with a 1-frame silent buffer
      if (!audioContextRef.current) {
        audioContextRef.current = new AudioContext();
      }
      const ctx = audioContextRef.current;
      if (ctx.state === 'suspended') {
        await ctx.resume();
      }
      const buffer = ctx.createBuffer(1, 1, ctx.sampleRate);
      const source = ctx.createBufferSource();
      source.buffer = buffer;
      source.connect(ctx.destination);
      source.start(0);
      audioUnlockedRef.current = true;
    } catch (err) {
      // Best-effort unlock; continue even if this fails
    }
  }, []);

  const playUrl = useCallback((url: string) => {
    return new Promise<void>((resolve, reject) => {
      try {
        if (!audioRef.current) {
          audioRef.current = new Audio();
        }
        const myGen = playbackGenerationRef.current;
        const onEnded = () => { cleanup(); resolve(); };
        const onError = (e: any) => {
          if (myGen !== playbackGenerationRef.current) { cleanup(); resolve(); return; }
          cleanup(); reject(e);
        };
        const cleanup = () => {
          audioRef.current?.removeEventListener('ended', onEnded);
          audioRef.current?.removeEventListener('error', onError);
          try { URL.revokeObjectURL(url); } catch {}
        };
        audioRef.current.addEventListener('ended', onEnded);
        audioRef.current.addEventListener('error', onError);
        audioRef.current.src = url;
        audioRef.current.play().catch(onError);
      } catch (e) {
        reject(e);
      }
    });
  }, []);

  const enqueuePlaybackUrl = useCallback((url: string, text: string) => {
    playbackQueueRef.current.push({ url, text });
    // Kick playback loop
    (async () => {
      if (isPlayingQueueRef.current) return;
      isPlayingQueueRef.current = true;
      try {
        while (playbackQueueRef.current.length > 0) {
          const { url } = playbackQueueRef.current.shift()!;
          setIsSpeaking(true);
          setIsThinking(false); // no longer thinking once we start speaking
          try {
            await playUrl(url);
          } catch (err) {
          }
          // small, natural pause between segments
          if (SPEECH_GAP_MS > 0) {
            await new Promise((r) => setTimeout(r, SPEECH_GAP_MS));
          }
        }
      } finally {
        isPlayingQueueRef.current = false;
  setIsSpeaking(false);
      }
    })();
  }, [playUrl]);

  const segmentKey = useCallback((text: string) => `${text.length}:${text.slice(0, 64)}`, []);

  const enqueueSpeechFallback = useCallback((text: string) => {
    // Queue a SpeechSynthesis utterance to mimic sequential playback
    const makeUtter = (t: string) => {
      const u = new SpeechSynthesisUtterance(t);
      u.rate = 1.0;
      u.pitch = 1.0;
      return u;
    };
  const utter = makeUtter(text);
  utter.onstart = () => { setIsSpeaking(true); setIsThinking(false); };
    utter.onend = () => { setIsSpeaking(false); };
    utter.onerror = () => { setIsSpeaking(false); };
    window.speechSynthesis.speak(utter);
  }, []);

  const pumpTtsQueue = useCallback(() => {
    if (pumpingRef.current) return;
    pumpingRef.current = true;
    const step = async () => {
      try {
        while (
          pendingTtsQueueRef.current.length > 0 &&
          currentFetchesRef.current < maxConcurrentTts
        ) {
          const nextItem = pendingTtsQueueRef.current[0];
          const text = nextItem?.text || '';
          if (!text.trim()) { pendingTtsQueueRef.current.shift(); continue; }

          const now = Date.now();
          const providerUnavailable =
            replyUseFallbackRef.current ||
            !ttsServerAvailableRef.current ||
            now < providerCooldownUntilRef.current;

          if (providerUnavailable) {
            // Use fallback immediately for this segment
            pendingTtsQueueRef.current.shift();
            const key = segmentKey(text);
            if (!spokenSegmentsSetRef.current.has(key)) {
              spokenSegmentsSetRef.current.add(key);
              enqueueSpeechFallback(text);
            }
            continue;
          }

          // Enforce global spacing between provider requests
          if (now < nextAllowedTtsStartAtRef.current) {
            const delay = Math.max(0, nextAllowedTtsStartAtRef.current - now);
            setTimeout(() => {
              pumpingRef.current = false;
              pumpTtsQueue();
            }, delay);
            return;
          }

          // Start provider request for this item
          const { replyId: itemReplyId } = nextItem;
          pendingTtsQueueRef.current.shift();
          currentFetchesRef.current += 1;
          nextAllowedTtsStartAtRef.current = Date.now() + MIN_TTS_SPACING_MS;
          (async () => {
            try {
              const url = await fetchTtsUrl(text);
              const key = segmentKey(text);
              // Discard if reply changed while fetching
              if (itemReplyId !== currentReplyIdRef.current) {
                try { URL.revokeObjectURL(url); } catch {}
              } else if (!spokenSegmentsSetRef.current.has(key)) {
                enqueuePlaybackUrl(url, text);
              } else {
                try { URL.revokeObjectURL(url); } catch {}
              }
            } catch (err: any) {
              const msg = String(err?.message || '');
              if (msg.includes('401') || msg.includes('403') || msg.toLowerCase().includes('unauthor')) {
                ttsServerAvailableRef.current = false;
                replyUseFallbackRef.current = true;
                setVoiceError('Slow down! Our voice service is experiencing rate exceed. Please try again later.');
                const key = segmentKey(text);
                if (!spokenSegmentsSetRef.current.has(key)) {
                  spokenSegmentsSetRef.current.add(key);
                  enqueueSpeechFallback(text);
                }
              } else if (msg.includes('429') || msg.includes('Too Many') || msg.includes('concurrent')) {
                providerCooldownUntilRef.current = Date.now() + 2000;
                setVoiceError('Slow down! Our voice service is experiencing rate exceed. Please try again later.');
                const key = segmentKey(text);
                if (!spokenSegmentsSetRef.current.has(key)) {
                  spokenSegmentsSetRef.current.add(key);
                  enqueueSpeechFallback(text);
                }
              } else {
                const emsg = String(err?.message || '').toLowerCase();
                if (emsg.includes('500') || emsg.includes('internal') || emsg.includes('server')) {
                  setVoiceError('Slow down! Our voice service is experiencing rate exceed. Please try again later.');
                }
                const key = segmentKey(text);
                if (!spokenSegmentsSetRef.current.has(key)) {
                  spokenSegmentsSetRef.current.add(key);
                  enqueueSpeechFallback(text);
                }
              }
            } finally {
              currentFetchesRef.current -= 1;
              if (pendingTtsQueueRef.current.length > 0) {
                step();
              } else {
                pumpingRef.current = false;
              }
            }
          })();
        }
      } finally {
        if (
          pendingTtsQueueRef.current.length === 0 &&
          currentFetchesRef.current === 0
        ) {
          pumpingRef.current = false;
        }
      }
    };
    step();
  }, [enqueuePlaybackUrl, enqueueSpeechFallback, fetchTtsUrl, segmentKey, showNotification]);

  const fetchAndQueueTts = useCallback((text: string) => {
    const replyId = currentReplyIdRef.current || 'default';
    pendingTtsQueueRef.current.push({ text, replyId });
    pumpTtsQueue();
  }, [pumpTtsQueue]);

  // Deprecated chunk queue retained for reference; no longer used since we speak once per reply

  // Deprecated: queue processor no longer used with single-shot TTS

  // Deprecated: chunked enqueue no longer used (single-shot TTS per reply)

  const handleClose = useCallback(() => {
    // Force stop any ongoing speech synthesis and audio playback
    try { if (window.speechSynthesis.speaking) window.speechSynthesis.cancel(); } catch {}
    try {
      if (audioRef.current) {
        const src = audioRef.current.src;
        audioRef.current.pause();
        audioRef.current.src = '';
        playbackGenerationRef.current += 1; // mark intentional interruption
        if (src && src.startsWith('blob:')) { try { URL.revokeObjectURL(src); } catch {} }
      }
    } catch {}

    // Revoke any queued blob URLs and clear queues
    try {
      for (const item of playbackQueueRef.current) {
        const u = item.url;
        if (u && u.startsWith('blob:')) { try { URL.revokeObjectURL(u); } catch {} }
      }
    } catch {}
    playbackQueueRef.current = [];
    pendingTtsQueueRef.current = [];
    spokenSegmentsSetRef.current.clear();
    ttsServerAvailableRef.current = true;
    replyUseFallbackRef.current = false;
    pendingTextBufferRef.current = '';
    lastAssistantProcessedLenRef.current = 0;

    cleanupResources();
    setIsListening(false);
    setIsSpeaking(false);
    setIsRecording(false);
    setIsMicReady(false);
    lastSpokenMessageIdRef.current = null;

    onClose();
  }, [cleanupResources, onClose]);

  const transcribeAudioBlob = useCallback(async (blob: Blob) => {
    
    const token = localStorage.getItem('fexo-token');
    const formData = new FormData();
    formData.append('audio', blob, `voice-${Date.now()}.webm`);

    const headers: Record<string, string> = {};
    if (token) {
      headers['x-auth-token'] = token;
    }

    const response = await fetch(`${API_BASE_URL}/api/voice/transcribe`, {
      method: 'POST',
      headers,
      body: formData,
    });

    if (!response.ok) {
      const errorData = await response.json().catch(() => null);
      let message = 'Failed to transcribe audio.';
      if (errorData?.error) {
        if (typeof errorData.error === 'string') {
          message = errorData.error;
        } else if (typeof errorData.error === 'object') {
          try { message = JSON.stringify(errorData.error); } catch {}
        }
      } else if (errorData?.detail?.message) {
        message = errorData.detail.message;
      }
      const status = response.status;
      const quotaExceeded =
        errorData?.detail?.status === 'quota_exceeded' ||
        errorData?.error?.detail?.status === 'quota_exceeded' ||
        /quota|rate|exceed/i.test(String(message));
      if (status === 401 || status === 403 || status === 429 || status >= 500 || quotaExceeded) {
        setVoiceError('Slow down! Our voice service is experiencing rate exceed. Please try again later.');
      }
      throw new Error(message);
    }

    const data = await response.json();
    return (data?.transcript as string) || '';
  }, []);

  const handleUserSpeech = useCallback(async (text: string) => {
    
    if (isProcessingRef.current || !text.trim()) {
      
      return;
    }

    
    isProcessingRef.current = true;
    setIsThinking(true);
    

    try {
      await sendMessage(text, [], { isThinkingEnabled: false, voiceMode: true });
    } catch (error) {
      showNotification('Failed to send message', 'error');
    } finally {
      isProcessingRef.current = false;
    }
  }, [sendMessage, showNotification]);

  const stopRecording = useCallback(() => {
    
    
    if (animationFrameRef.current !== null) {
      cancelAnimationFrame(animationFrameRef.current);
      animationFrameRef.current = null;
    }

    if (mediaRecorderRef.current && mediaRecorderRef.current.state === 'recording') {
      
      mediaRecorderRef.current.stop();
    }

    setIsRecording(false);
    setIsListening(false);
  }, []);

  const monitorAudioLevels = useCallback(() => {
    if (!analyserRef.current) return;

    const analyser = analyserRef.current;
    const dataArray = new Float32Array(analyser.fftSize);

    const checkLevel = () => {
      if (!analyserRef.current || !mediaRecorderRef.current) return;

      analyser.getFloatTimeDomainData(dataArray);

      // Calculate RMS (root mean square) to determine volume level
      let sumSquares = 0;
      for (let i = 0; i < dataArray.length; i++) {
        sumSquares += dataArray[i] * dataArray[i];
      }
      const instantRms = Math.sqrt(sumSquares / dataArray.length);
      // Exponential smoothing to stabilize detection
      const alpha = 0.08; // smoothing factor
      const prev = smoothedRmsRef.current || 0;
      const smoothed = prev + alpha * (instantRms - prev);
      smoothedRmsRef.current = smoothed;

      const now = performance.now();
      const recordingDuration = now - recordingStartTimeRef.current;

      // Hysteresis-based detection: start vs stop thresholds
      if (smoothed > SPEECH_START_THRESHOLD) {
        // Clearly speaking
        lastSoundTimeRef.current = now;
      } else if (smoothed < SPEECH_STOP_THRESHOLD) {
        // Clearly below stop threshold: evaluate silence timeout
        const silenceDuration = now - lastSoundTimeRef.current;
        if (recordingDuration > MIN_RECORDING_MS && silenceDuration > SILENCE_DURATION_MS) {
          
          stopRecording();
          return;
        }
      } else {
        // Between stop and start thresholds: do nothing (neutral zone)
      }

      animationFrameRef.current = requestAnimationFrame(checkLevel);
    };

    animationFrameRef.current = requestAnimationFrame(checkLevel);
  }, [stopRecording]);

  const startRecording = useCallback(async () => {
    if (!mediaStreamRef.current || isRecording || isSpeaking || isProcessingRef.current) {
      return;
    }

    
    audioChunksRef.current = [];
    recordingStartTimeRef.current = performance.now();
    lastSoundTimeRef.current = performance.now();

    // Set up MediaRecorder
    const mimeTypesToTry = [
      'audio/webm;codecs=opus',
      'audio/webm',
      'audio/ogg;codecs=opus',
      'audio/mp4',
    ];

    let selectedMimeType = '';
    for (const mime of mimeTypesToTry) {
      if (MediaRecorder.isTypeSupported(mime)) {
        selectedMimeType = mime;
        break;
      }
    }

    const recorder = new MediaRecorder(
      mediaStreamRef.current,
      selectedMimeType ? { mimeType: selectedMimeType } : undefined
    );
    mediaRecorderRef.current = recorder;

    recorder.ondataavailable = (event: BlobEvent) => {
      if (event.data && event.data.size > 0) {
        audioChunksRef.current.push(event.data);
      }
    };

    recorder.onstop = async () => {
      
      const chunks = audioChunksRef.current;
      audioChunksRef.current = [];

      if (chunks.length === 0 || isProcessingRef.current) {
        
        return;
      }

      const blob = new Blob(chunks, { type: recorder.mimeType });
      

      if (blob.size < MIN_AUDIO_BYTES) {
        
        return;
      }

      try {
        const text = await transcribeAudioBlob(blob);
        if (text && text.trim()) {
          await handleUserSpeech(text);
        } else {
          
        }
      } catch (error) {
        const msg = String(error instanceof Error ? error.message : error || '');
        const isRate = /quota|rate|exceed|429|unauthorized|401|403/i.test(msg);
        if (isRate) {
          // voiceError is set inside transcribeAudioBlob; avoid noisy toast
        } else {
          showNotification(msg || 'Failed to transcribe audio.', 'error');
        }
      }
    };

    recorder.start(400); // Collect data every 400ms
    setIsRecording(true);
    setIsListening(true);
    

    // Start monitoring audio levels for silence detection
    monitorAudioLevels();
  }, [isRecording, isSpeaking, transcribeAudioBlob, handleUserSpeech, showNotification, monitorAudioLevels]);

  // Initialize audio context and microphone
  useEffect(() => {
    if (!isOpen) {
      return;
    }

    let cancelled = false;

    const setup = async () => {
      try {
        
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        if (cancelled) {
          stream.getTracks().forEach((track) => track.stop());
          return;
        }

  mediaStreamRef.current = stream;
  setIsMicReady(true);

        // Set up audio context and analyser
        const audioContext = new AudioContext();
        const source = audioContext.createMediaStreamSource(stream);
        const analyser = audioContext.createAnalyser();
        analyser.fftSize = 2048;
        source.connect(analyser);

        audioContextRef.current = audioContext;
        analyserRef.current = analyser;

        
      } catch (error) {
        showNotification('Microphone access is required for voice chat.', 'error');
        onClose();
      }
    };

    setup();

    return () => {
      cancelled = true;
      if (animationFrameRef.current !== null) {
        cancelAnimationFrame(animationFrameRef.current);
        animationFrameRef.current = null;
      }
      if (mediaRecorderRef.current && mediaRecorderRef.current.state !== 'inactive') {
        try {
          mediaRecorderRef.current.stop();
        } catch (_) {}
      }
      if (audioContextRef.current) {
        audioContextRef.current.close().catch(() => {});
      }
      if (mediaStreamRef.current) {
        mediaStreamRef.current.getTracks().forEach((track) => track.stop());
      }
      setIsMicReady(false);
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [isOpen]);

  // Stop recording while assistant is actively responding (streaming) or speaking
  useEffect(() => {
    if (!isOpen || !isRecording) return;
    // If TTS playback is ongoing, avoid recording to prevent feedback
    if (isSpeaking) {
      stopRecording();
      return;
    }
    // If assistant stream is active (deltas incoming), stop until reply finishes
    if (isStreaming && messages.length > 0) {
      const lastMessage = messages[messages.length - 1];
      if (lastMessage.role === 'assistant') {
        stopRecording();
      }
    }
  }, [isOpen, isRecording, isSpeaking, isStreaming, messages, stopRecording]);

  // After assistant finishes speaking and streaming, automatically resume listening
  useEffect(() => {
    if (!isOpen) return;
    const ready =
      !isSpeaking &&
      !isStreaming &&
      isMicReady &&
      !isRecording &&
      !isProcessingRef.current &&
      playbackQueueRef.current.length === 0 &&
      pendingTtsQueueRef.current.length === 0 &&
      currentFetchesRef.current === 0 &&
      pendingTextBufferRef.current.trim().length === 0;
    let t: number | undefined;
    if (ready) {
      // small cooldown to avoid rapid start/stop oscillation
      t = window.setTimeout(() => {
        startRecording();
      }, 350);
    }
    return () => { if (t) window.clearTimeout(t); };
  }, [isSpeaking, isStreaming, isOpen, isMicReady, isRecording, startRecording]);

  // Stream assistant deltas into finalized chunks; for each chunk, immediately request TTS and queue the audio for playback
  useEffect(() => {
    if (!isOpen || messages.length === 0) return;
    const lastMessage = messages[messages.length - 1];
    if (lastMessage.role !== 'assistant') return;
    const content = lastMessage.content || '';

    // Reset counters when a new assistant reply starts (content shrank)
    if (content.length < lastAssistantProcessedLenRef.current) {
      // New assistant reply started
      pendingTextBufferRef.current = '';
      lastAssistantProcessedLenRef.current = 0;
      currentReplyIdRef.current = `${Date.now()}-${Math.random().toString(36).slice(2)}`;
      replyUseFallbackRef.current = false;
      spokenSegmentsSetRef.current.clear();
      // Interrupt any ongoing playback from previous reply and clear queued items
      try { if (window.speechSynthesis.speaking) window.speechSynthesis.cancel(); } catch {}
      try {
        if (audioRef.current) {
          const src = audioRef.current.src;
          audioRef.current.pause();
          audioRef.current.src = '';
          playbackGenerationRef.current += 1;
          if (src && src.startsWith('blob:')) { try { URL.revokeObjectURL(src); } catch {} }
        }
      } catch {}
      playbackQueueRef.current = [];
      pendingTtsQueueRef.current = [];
    }
    if (!currentReplyIdRef.current) {
      currentReplyIdRef.current = `${Date.now()}-${Math.random().toString(36).slice(2)}`;
    }

    if (content.length > lastAssistantProcessedLenRef.current) {
      const delta = content.substring(lastAssistantProcessedLenRef.current);
      pendingTextBufferRef.current += delta;
      lastAssistantProcessedLenRef.current = content.length;

  // Finalize chunks on strong punctuation or if buffer is long to reduce latency
      const segments: string[] = [];
      const regex = /(.*?[\.!\?])(\s|$)/g;
      let match;
      let consumed = 0;
      while ((match = regex.exec(pendingTextBufferRef.current)) !== null) {
        const seg = match[1].trim();
        if (seg) segments.push(seg);
        consumed = regex.lastIndex;
      }
      // If no sentence end yet but buffer is long, flush mid-chunk to keep audio flowing
      if (segments.length === 0 && pendingTextBufferRef.current.length > 260) {
        const cut = pendingTextBufferRef.current.slice(0, 260);
        const lastSpace = cut.lastIndexOf(' ');
        const seg = cut.slice(0, lastSpace > 140 ? lastSpace : cut.length).trim();
        if (seg) {
          segments.push(seg);
          consumed = seg.length;
        }
      }

      if (segments.length > 0) {
        pendingTextBufferRef.current = pendingTextBufferRef.current.slice(consumed);
        // Fire TTS requests immediately; playback will start as audio becomes ready
        for (const seg of segments) {
          fetchAndQueueTts(seg);
        }
      }
    }
  }, [messages, isOpen, fetchAndQueueTts]);

  // Flush any leftover text at end of streaming
  useEffect(() => {
    if (!isOpen) return;
    if (isStreaming) return;
    const leftover = pendingTextBufferRef.current.trim();
    if (leftover) {
      pendingTextBufferRef.current = '';
      fetchAndQueueTts(leftover);
    }
    // No additional gating; auto-restart effect handles readiness
  }, [isOpen, isStreaming, fetchAndQueueTts]);

  // Build tool blocks for the latest assistant turn (no assistant text rendered)
  const voiceToolBlocks = useCallback(() => {
    if (!messages || messages.length === 0) return null;
    const lastUserIndex = [...messages].findLastIndex((m) => m.role === 'user');
    const startIndex = Math.max(0, lastUserIndex + 1);
    const processedIds = new Set<string>();
    const parts: React.ReactNode[] = [];

    for (let i = startIndex; i < messages.length; i++) {
      const m = messages[i] as Message;
      if (m.role === 'user') break;

      if (m.role === 'tool_code' && m.tool_id && !processedIds.has(m.tool_id)) {
        const out = messages.find((x) => x.role === 'tool_code_result' && x.tool_id === m.tool_id);
        parts.push(
          <CodeAnalysisBlock key={`v-code-${m.tool_id}`} chatId={activeChatId} toolCodeMessage={m} toolOutputMessage={out} onView={handleOpenViewer} />
        );
        processedIds.add(m.tool_id);
      }

      if (m.role === 'tool_search' && m.tool_id && !processedIds.has(m.tool_id)) {
        const out = messages.find((x) => x.role === 'tool_search_result' && x.tool_id === m.tool_id);
        const isGeoMap = out?.content?.includes('[LOCATION]');
        if (isGeoMap) {
          parts.push(
            <GeolocationBlock key={`v-geo-${m.tool_id}`} toolMessage={m} outputMessage={out} />
          );
        } else {
          parts.push(
            <SearchBlock key={`v-search-${m.tool_id}`} toolSearchMessage={m} toolOutputMessage={out} />
          );
        }
        processedIds.add(m.tool_id);
      }

      if (m.role === 'tool_doc_extract' && m.tool_id && !processedIds.has(m.tool_id)) {
        const out = messages.find((x) => x.role === 'tool_doc_extract_result' && x.tool_id === m.tool_id);
        parts.push(
          <AnalysisBlock key={`v-extract-${m.tool_id}`} toolMessage={m} outputMessage={out} />
        );
        processedIds.add(m.tool_id);
      }

      if (m.role === 'tool_geolocation' && m.tool_id && !processedIds.has(m.tool_id)) {
        const hasResult = messages.some((x) => x.role === 'tool_geolocation_result' && x.tool_id === m.tool_id);
        if (!hasResult) {
          parts.push(
            <GeolocationRequestBlock key={`v-geo-req-${m.tool_id}`} toolMessage={m} />
          );
        }
        processedIds.add(m.tool_id);
      }

      if (m.role === 'tool_integration' && m.tool_id && !processedIds.has(m.tool_id)) {
        const out = messages.find((x) => x.role === 'tool_integration_result' && x.tool_id === m.tool_id);
        if (out?.integrationData?.type === 'google_maps_route') {
          parts.push(
            <GoogleMapsBlock key={`v-maps-${m.tool_id}`} integrationData={out.integrationData} />
          );
        }
        processedIds.add(m.tool_id);
      }

      if (m.role === 'tool_integration_result' && m.tool_id && !processedIds.has(m.tool_id)) {
        if (m.integrationData?.type === 'google_maps_route') {
          parts.push(
            <GoogleMapsBlock key={`v-maps-${m.tool_id}`} integrationData={m.integrationData} />
          );
        }
        processedIds.add(m.tool_id);
      }
    }
    if (parts.length === 0) return null;
    return <div className="voice-tools-pane">{parts}</div>;
  }, [messages, activeChatId, handleOpenViewer]);

  // Mic toggling handled automatically; no manual toggle button is shown.

  // Debug sample button removed

  if (!isOpen) return null;

  let statusText = 'Initializing microphone...';
  let statusClass = 'idle';

  if (isMicReady) {
    if (isSpeaking) {
      statusText = 'Speaking...';
      statusClass = 'speaking';
    } else if (isRecording) {
      statusText = 'Recording... (speak now)';
      statusClass = 'listening';
    } else if (isThinking) {
      statusText = 'Thinking...';
      statusClass = 'listening';
    } else if (isListening && !isRecording) {
      statusText = 'Processing...';
      statusClass = 'listening';
    } else {
      statusText = 'Say something to start';
      statusClass = 'idle';
    }
  }

  return (
    <Portal>
      <div className="voice-chat-overlay">
        <div className="voice-chat-modal" onClick={(e) => e.stopPropagation()}>
        <button className="voice-chat-close-btn" onClick={handleClose}>
          <FiX size={24} />
        </button>

        <div className="voice-chat-content">
          <div className={`ai-orb ${isSpeaking ? 'speaking' : ''} ${isRecording ? 'listening' : ''}`}>
            <div className="orb-inner"></div>
            <div className="orb-glow"></div>
          </div>

          <div className="voice-chat-status">
            <p className={`status-text ${statusClass}`}>{statusText}</p>
          </div>

            {/* Caption removed as requested */}

          <div className="voice-chat-controls">
            <div
              className={`voice-dots ${isThinking ? 'thinking' : ''}`}
              onClick={() => unlockAudioPlayback().catch(() => {})}
              role="button"
              aria-label="Speech status indicator"
              title="Speech status"
            >
              <span className="dot" />
              <span className="dot" />
              <span className="dot" />
            </div>
          </div>

          {voiceToolBlocks()}

          <div className="voice-chat-info">
            <p className="info-text">
              Ask me anything - I can search the internet, execute code, find directions, and more!
            </p>
          </div>
          {/* Debug button removed */}
          <ImageViewer isOpen={isViewerOpen} src={viewerSrc} alt={viewerSrc || ''} onClose={() => setIsViewerOpen(false)} />
          {voiceError && (
            <div className="voice-error-backdrop" role="dialog" aria-modal="true" aria-label="Voice service error">
              <div className="voice-error-card">
                <div className="voice-error-icon"><FiAlertTriangle size={28} /></div>
                <h3 className="voice-error-title">Slow down</h3>
                <p className="voice-error-message">Our voice service is experiencing rate exceed. Please try again later.</p>
                <div className="voice-error-actions">
                  <button className="voice-error-button" onClick={() => { setVoiceError(null); handleClose(); }}>Got it</button>
                </div>
              </div>
            </div>
          )}
        </div>
        </div>
      </div>
    </Portal>
  );
};

export default VoiceChatModal;
- - contexts/
- - - ChatContext.tsx:
// src/contexts/ChatContext.tsx
import {
  createContext,
  useContext,
  useState,
  useCallback,
  useEffect,
  ReactNode,
  useRef,
} from 'react';
import { flushSync } from 'react-dom';
import { useNavigate } from 'react-router-dom';
import type { Message, Attachment } from '../types';
import { useSettings } from './SettingsContext';
import { useNotification } from './NotificationContext';
import api from '../utils/api';
import { fetchPublicConfig } from '../utils/config';
import { scheduleClientNotification } from '../utils/scheduler';

type ChatListItem = {
  _id: string;
  title: string;
  updatedAt: string;
};

interface ChatContextType {
  messages: Message[];
  chatList: ChatListItem[];
  activeChatId: string | null;
  loadChat: (chatId: string) => void;
  clearChat: () => void;
  isLoadingChat: boolean;
  isLoadingChatList: boolean;
  isCreatingChat: boolean;
  isSending: boolean;
  sendMessage: (
    text: string,
    attachments: Attachment[],
    metadata?: Record<string, any>
  ) => Promise<void>;
  stopGeneration: () => void;
  isStreaming: boolean;
  isThinking: boolean;
  isThinkingEnabled: boolean;
  toggleThinking: () => void;
  thinkingContent: string | null;
  editingIndex: number | null;
  startEditing: (index: number) => void;
  cancelEditing: () => void;
  saveAndSubmitEdit: (
    index: number,
    newContent: string,
    metadata?: Record<string, any>
  ) => Promise<void>;
  regenerateResponse: (metadata?: Record<string, any>) => Promise<void>;
  renameChat: (chatId: string, newTitle: string) => Promise<void>;
  deleteChat: (chatId: string) => Promise<void>;
  clearAllChats: () => Promise<void>;
  sendGeolocationResult: (
    chatId: string,
    tool_id: string,
    result:
      | { coordinates: { latitude: number; longitude: number } }
      | { error: string }
  ) => Promise<void>;
}

const ChatContext = createContext<ChatContextType | undefined>(undefined);

export const ChatProvider = ({ children }: { children: ReactNode }) => {
  const navigate = useNavigate();
  const { token, selectedModel, user } = useSettings();
  const { showNotification } = useNotification();

  const [messages, setMessages] = useState<Message[]>([]);
  const [chatList, setChatList] = useState<ChatListItem[]>([]);
  const [activeChatId, setActiveChatId] = useState<string | null>(null);
  const [isLoadingChat, setIsLoadingChat] = useState(false);
  const [isLoadingChatList, setIsLoadingChatList] = useState(true);
  const [isCreatingChat, setIsCreatingChat] = useState(false);
  const [isStreaming, setIsStreaming] = useState(false);
  const [isSending, setIsSending] = useState(false);
  const [editingIndex, setEditingIndex] = useState<number | null>(null);
  const [isThinking, setIsThinking] = useState(false);
  const [thinkingContent, setThinkingContent] = useState<string | null>(null);
  const [isThinkingEnabled, setThinkingEnabled] = useState(false);
  const [reasoningModels, setReasoningModels] = useState<string[]>([]);

  const streamAbortControllerRef = useRef<AbortController | null>(null);
  const messagesRef = useRef<Message[]>([]);

  useEffect(() => {
    messagesRef.current = messages;
  }, [messages]);

  const toggleThinking = () => setThinkingEnabled((prev) => !prev);

  const getLocalTime = () => {
    const now = new Date();
    const padding = (num: number) => String(num).padStart(2, '0');
    const offset = -now.getTimezoneOffset() / 60;
    const sign = offset >= 0 ? '+' : '-';
    return `UTC${sign}${Math.abs(offset)} ${now.getFullYear()}-${padding(now.getMonth()+1)}-${padding(now.getDate())}T${padding(now.getHours())}:${padding(now.getMinutes())}`;
  };

  useEffect(() => {
    const fetchReasoningModels = async () => {
      try {
        const response = await fetchPublicConfig();
        if (response && (response as any).reasoningModels) {
           setReasoningModels((response as any).reasoningModels);
        }
      } catch (error) {
        // Fallback defaults
        setReasoningModels([
          'thinking', 'reasoning', 'o1', 'o3', 'deepseek-reasoner',
          'qwen-plus', 'qwen-turbo', 'qwen-max', 'qwen-vl-plus', 'qwen-vl-max',
          'qwen2.5', 'qwen-qwq', 'claude-3-7-sonnet', 'gemini-2.5'
        ]);
      }
    };
    fetchReasoningModels();
  }, []);

  useEffect(() => {
    const modelName = selectedModel?.toLowerCase() || '';
    const provider = user?.selectedProvider?.toLowerCase() || '';
    const isReasoningModel = 
      provider === 'default' || 
      reasoningModels.some(pattern => modelName.includes(pattern.toLowerCase()));
    setThinkingEnabled(isReasoningModel);
  }, [selectedModel, user?.selectedProvider, reasoningModels]);

  const loadChatList = useCallback(async () => {
    if (!token) {
      setIsLoadingChatList(false);
      return;
    }
    setIsLoadingChatList(true);
    try {
      const response = await api('/chats');
      if (!response.ok) throw new Error('Failed to fetch chat list');
      const data = await response.json();
      setChatList(data);
    } catch (error) {
      showNotification('Could not load chat history.', 'error');
    } finally {
      setIsLoadingChatList(false);
    }
  }, [token, showNotification]);

  useEffect(() => {
    loadChatList();
  }, [loadChatList]);

  const stopGeneration = useCallback(() => {
    if (streamAbortControllerRef.current) {
      streamAbortControllerRef.current.abort();
    }
    setIsStreaming(false);
    setIsThinking(false);
    setThinkingContent(null);
    setMessages((prev) => prev.filter((m) => !m.isWaiting));
    setIsSending(false);
    streamAbortControllerRef.current = null;
  }, []);

  const streamAndSaveResponse = useCallback(
    async (
      chatId: string,
      messageHistory: Message[],
      metadata?: Record<string, any>
    ) => {
      setIsSending(true);
      setIsStreaming(true);
      setIsThinking(false);
      setThinkingContent(null);

      streamAbortControllerRef.current = new AbortController();
      let currentAssistantThinking = '';
      let assistantMessageIndex = -1;
      let streamEndedForClientTool = false;

      // Helper for client-side scheduling inside the stream scope
      const executeClientSchedule = async (tool_id: string, tool_name: string, args: any) => {
        const { task, description, datetime_from } = args;
        const scheduleDate = new Date(datetime_from);
        
        const result = await scheduleClientNotification(task, description, scheduleDate);
        
        let resultContent = '';
        let state: Message['state'] = 'completed';

        if (result.success) {
          const localTimeStr = scheduleDate.toLocaleString();
          resultContent = `Successfully scheduled notification for "${task}" at ${localTimeStr}.`;
        } else {
          state = 'error';
          resultContent = `Error: ${result.error}`;
          if (result.error?.includes('Permission needed')) {
             resultContent += " [SYSTEM NOTE: Please tell the user to click the 'Notifications' bell icon in the sidebar to enable permissions first.]";
          }
        }

        const resultMessage: Message = {
          role: 'tool_integration_result', 
          tool_id,
          tool_name,
          content: resultContent,
        };

        const currentHistory = messagesRef.current.filter(m => !m.isWaiting);
        const messagesForUI = currentHistory.map((m) =>
          m.tool_id === tool_id && m.role === 'tool_integration'
            ? ({ ...m, state } as Message)
            : m
        );
        const historyForBackend = [...messagesForUI, resultMessage];
        setMessages([...messagesForUI, { role: 'assistant', content: '', isWaiting: true }]);
        await streamAndSaveResponse(chatId, historyForBackend, { isContinuation: true });
      };

      try {
        let finMetadata = {...(metadata || {}), client_time: getLocalTime()};

        const response = await api(`/chats/${chatId}/stream`, {
          method: 'POST',
          body: JSON.stringify({ messagesFromClient: messageHistory, finMetadata }),
          signal: streamAbortControllerRef.current.signal,
        });

        if (!response.ok) {
          const errorData = await response
            .json()
            .catch(() => ({ error: 'Streaming failed with status ' + response.status }));
          throw new Error(errorData.error);
        }

        const reader = response.body?.getReader();
        const decoder = new TextDecoder();
        if (!reader) throw new Error('Failed to read stream.');

        let buffer = '';
        while (true) {
          const { done, value } = await reader.read();
          if (done) break;

          buffer += decoder.decode(value, { stream: true });
          let boundary = buffer.indexOf('\n\n');

          while (boundary !== -1) {
            const messageChunk = buffer.substring(0, boundary);
            buffer = buffer.substring(boundary + 2);
            const lines = messageChunk.split('\n');

            for (const line of lines) {
              if (!line.startsWith('data: ')) continue;
              const jsonString = line.substring(6).trim();
              if (jsonString === '{"type":"done"}' || !jsonString) continue;

              try {
                const event = JSON.parse(jsonString);

                if (event.type === 'error') {
                  throw new Error(event.error?.message || 'An error occurred on the server.');
                }

                if (event.type === 'STREAM_END' && event.reason === 'tool_use') {
                  streamEndedForClientTool = true;
                  continue;
                }

                switch (event.type) {
                  case 'TOOL_SCHEDULE_CREATE':
                    streamEndedForClientTool = true;
                    setMessages((prev) => {
                      const newMessages = [...prev];
                      const lastMessage = newMessages[newMessages.length - 1];
                      if (lastMessage?.isWaiting) {
                        newMessages[newMessages.length - 1] = event.message;
                      } else {
                        newMessages.push(event.message);
                      }
                      return newMessages;
                    });
                    
                    if (event.message.tool_arguments) {
                        executeClientSchedule(
                            event.message.tool_id,
                            event.message.tool_name,
                            event.message.tool_arguments
                        );
                    }
                    break;

                  case 'THINKING_START':
                    setIsThinking(true);
                    setThinkingContent('');
                    currentAssistantThinking = '';
                    setMessages((prev) => {
                      const newMessages = [...prev];
                      const lastMessage = newMessages[newMessages.length - 1];
                      if (lastMessage?.isWaiting) {
                        assistantMessageIndex = newMessages.length - 1;
                        newMessages[assistantMessageIndex] = { role: 'assistant', content: '', thinking: '' };
                      } else {
                        assistantMessageIndex = newMessages.length;
                        newMessages.push({ role: 'assistant', content: '', thinking: '' });
                      }
                      return newMessages;
                    });
                    break;

                  case 'THINKING_DELTA':
                    currentAssistantThinking += event.content;
                    setThinkingContent((prev) => (prev || '') + event.content);
                    flushSync(() => {
                      setMessages((prev) => {
                        const newMessages = [...prev];
                        if (assistantMessageIndex === -1 || assistantMessageIndex >= newMessages.length) {
                             const lastIdx = newMessages.length - 1;
                             if (newMessages[lastIdx]?.role === 'assistant') assistantMessageIndex = lastIdx;
                             else {
                                 assistantMessageIndex = newMessages.length;
                                 newMessages.push({ role: 'assistant', content: '', thinking: '' });
                             }
                        }
                        if (newMessages[assistantMessageIndex]) {
                            newMessages[assistantMessageIndex] = {
                                ...newMessages[assistantMessageIndex],
                                thinking: currentAssistantThinking,
                            };
                        }
                        return newMessages;
                      });
                    });
                    break;

                  case 'THINKING_END':
                    setIsThinking(false);
                    break;

                  case 'ASSISTANT_START':
                    setMessages((prev) => {
                      const newMessages = [...prev];
                      const lastMessage = newMessages[newMessages.length - 1];
                      if (lastMessage?.isWaiting) {
                        assistantMessageIndex = newMessages.length - 1;
                        newMessages[assistantMessageIndex] = {
                          role: 'assistant',
                          content: '',
                          thinking: currentAssistantThinking || undefined,
                        };
                      } else if (assistantMessageIndex === -1 || lastMessage.role !== 'assistant') {
                        assistantMessageIndex = newMessages.length;
                        newMessages.push({
                          role: 'assistant',
                          content: '',
                          thinking: currentAssistantThinking || undefined,
                        });
                      }
                      return newMessages;
                    });
                    break;

                  case 'ASSISTANT_DELTA':
                    flushSync(() => {
                      setMessages((prev) => {
                        const newMessages = [...prev];
                        if (assistantMessageIndex === -1 || assistantMessageIndex >= newMessages.length) {
                          assistantMessageIndex = newMessages.length;
                          newMessages.push({ role: 'assistant', content: '', thinking: currentAssistantThinking });
                        }
                        const currentMsg = newMessages[assistantMessageIndex];
                        newMessages[assistantMessageIndex] = {
                          ...currentMsg,
                          content: (currentMsg.content || '') + event.content,
                          thinking: currentAssistantThinking || currentMsg.thinking,
                        };
                        return newMessages;
                      });
                    });
                    break;

                  case 'USER_MESSAGE_ACK':
                    setMessages((prev) => {
                      const newMessages = [...prev];
                      const lastUserMessageIndex = newMessages.findLastIndex((m) => m.role === 'user');
                      if (lastUserMessageIndex !== -1) {
                        newMessages[lastUserMessageIndex] = event.message;
                      }
                      return newMessages;
                    });
                    break;

                  case 'ASSISTANT_COMPLETE':
                    break;

                  case 'TOOL_CODE_CREATE':
                  case 'TOOL_SEARCH_CREATE':
                  case 'TOOL_DOC_EXTRACT_CREATE':
                  case 'TOOL_GEOLOCATION_CREATE':
                  case 'TOOL_INTEGRATION_CREATE':
                    if (event.message && event.message.isClientSideTool) {
                        streamEndedForClientTool = true;
                    }
                    setMessages((prev) => {
                      const newMessages = [...prev];
                      const lastMessage = newMessages[newMessages.length - 1];
                      if (lastMessage?.isWaiting) {
                        newMessages[newMessages.length - 1] = event.message;
                      } else {
                        newMessages.push(event.message);
                      }
                      return newMessages;
                    });
                    break;

                  case 'TOOL_CODE_DELTA':
                  case 'TOOL_SEARCH_DELTA':
                  case 'TOOL_DOC_EXTRACT_DELTA':
                  case 'TOOL_INTEGRATION_DELTA':
                    flushSync(() => {
                      setMessages((prev) => {
                        const newMessages = [...prev];
                        const toolIndex = newMessages.findIndex((m) => m.tool_id === event.tool_id);
                        if (toolIndex !== -1) {
                          newMessages[toolIndex] = {
                            ...newMessages[toolIndex],
                            content: (newMessages[toolIndex].content || '') + event.content,
                          };
                        }
                        return newMessages;
                      });
                    });
                    break;

                  case 'TOOL_CODE_COMPLETE':
                  case 'TOOL_SEARCH_COMPLETE':
                  case 'TOOL_DOC_EXTRACT_COMPLETE':
                  case 'TOOL_INTEGRATION_COMPLETE':
                    setMessages((prev) => {
                      const newMessages = [...prev];
                      const toolIndex = newMessages.findIndex((m) => m.tool_id === event.tool_id);
                      if (toolIndex !== -1) newMessages[toolIndex].state = 'ready_to_execute';
                      return newMessages;
                    });
                    break;

                  case 'TOOL_CODE_STATE_UPDATE':
                  case 'TOOL_SEARCH_STATE_UPDATE':
                  case 'TOOL_DOC_EXTRACT_STATE_UPDATE':
                  case 'TOOL_INTEGRATION_STATE_UPDATE':
                    setMessages((prev) => {
                      const newMessages = [...prev];
                      const toolIndex = newMessages.findIndex((m) => m.tool_id === event.tool_id);
                      if (toolIndex !== -1) newMessages[toolIndex].state = event.state;
                      return newMessages;
                    });
                    break;

                  case 'TOOL_CODE_RESULT':
                  case 'TOOL_SEARCH_RESULT':
                  case 'TOOL_DOC_EXTRACT_RESULT':
                  case 'TOOL_INTEGRATION_RESULT':
                    setMessages((prev) => {
                        const newMessages = [...prev];
                        const toolReqRole = event.type.replace('_RESULT', '').toLowerCase();
                        const toolIndex = newMessages.findIndex(
                            (m) => m.role === toolReqRole && m.tool_id === event.tool_id
                        );
                        if (toolIndex !== -1) newMessages[toolIndex].state = event.state;
                        const resultRole = (toolReqRole + '_result') as Message['role'];
                        newMessages.push({
                            role: resultRole,
                            content: event.result.content,
                            tool_id: event.tool_id,
                            fileOutputs: event.result.fileOutputs || undefined,
                            integrationData: event.result.integrationData || undefined,
                        });
                        return newMessages;
                    });
                    assistantMessageIndex = -1;
                    currentAssistantThinking = '';
                    break;
                }
              } catch (error) {
                throw error;
              }
            }
            boundary = buffer.indexOf('\n\n');
          }
        }
      } catch (error) {
        if (error instanceof DOMException && error.name === 'AbortError') {
          // Handled via abort controller logic
        } else {
          showNotification(error instanceof Error ? error.message : 'Streaming error', 'error');
        }
      } finally {
        if (streamEndedForClientTool) {
          setIsStreaming(false);
          streamAbortControllerRef.current = null;
        } else {
          stopGeneration();
        }
      }
    },
    [stopGeneration, showNotification]
  );

  const sendMessage = async (text: string, attachments: Attachment[] = [], metadata?: Record<string, any>) => {
    if (isStreaming || isSending) return;
    const userMessage: Message = { role: 'user', content: text, attachments };
    const currentMessages = messagesRef.current;
    const originalMessages = currentMessages;

    try {
      if (!activeChatId) {
        setIsCreatingChat(true);
        const initialMessages = [userMessage];
        const createChatResponse = await api('/chats', {
          method: 'POST',
          body: JSON.stringify({ messages: initialMessages }),
        });
        if (!createChatResponse.ok) throw new Error('Failed to create chat.');
        const newChat = await createChatResponse.json();
        setActiveChatId(newChat._id);
        navigate(`/app/c/${newChat._id}`, { replace: true });

        const messagesWithPlaceholder = [...newChat.messages, { role: 'assistant', content: '', isWaiting: true } as Message];
        setMessages(messagesWithPlaceholder);
        
        await streamAndSaveResponse(newChat._id, newChat.messages, { ...metadata, client_time: getLocalTime(), isThinkingEnabled, userMessageAlreadySaved: true });
        await loadChatList();
      } else {
        const updatedMessages = [...currentMessages, userMessage];
        const messagesWithPlaceholder = [...updatedMessages, { role: 'assistant', content: '', isWaiting: true } as Message];
        setMessages(messagesWithPlaceholder);
        await streamAndSaveResponse(activeChatId, updatedMessages, { ...metadata, client_time: getLocalTime(), isThinkingEnabled });
      }
    } catch (error) {
      if (!(error instanceof DOMException && error.name === 'AbortError')) {
        showNotification(error instanceof Error ? error.message : 'Could not send message.', 'error');
      }
      if (activeChatId) setMessages(originalMessages);
      else { setMessages([]); setActiveChatId(null); navigate('/', { replace: true }); }
    } finally {
      setIsCreatingChat(false);
    }
  };

  const sendGeolocationResult = useCallback(async (chatId: string, tool_id: string, result: any) => {
      if (isStreaming) return;
      let result_content;
      if ('coordinates' in result) {
        result_content = `User's location is latitude ${result.coordinates.latitude.toFixed(6)}, longitude ${result.coordinates.longitude.toFixed(6)}.`;
      } else {
        result_content = `Could not get user's location. Error: ${result.error}`;
      }
      
      const currentMessages = messagesRef.current;
      const cleanMessages = currentMessages.filter((m) => !m.isWaiting);
      const originalToolMsg = cleanMessages.find(m => m.tool_id === tool_id && m.role === 'tool_geolocation');
      if (!originalToolMsg) return;

      const resultMessage: Message = {
        role: 'tool_geolocation_result',
        tool_id: tool_id,
        tool_name: originalToolMsg.tool_name,
        content: result_content,
      };

      const messagesForUI = cleanMessages.map((m) =>
        m.tool_id === tool_id ? ({ ...m, state: 'error' in result ? 'error' : 'completed' } as Message) : m
      );

      const historyForBackend = [...messagesForUI, resultMessage];
      setMessages([...messagesForUI, { role: 'assistant', content: '', isWaiting: true }]);
      await streamAndSaveResponse(chatId, historyForBackend, { isContinuation: true });
    },
    [isStreaming, streamAndSaveResponse]
  );

  const loadChat = useCallback(async (id: string) => {
      setIsLoadingChat(true);
      try {
        const response = await api(`/chats/${id}`);
        if (!response.ok) throw new Error('Chat not found');
        const data = await response.json();
        setMessages(data.messages);
        setActiveChatId(data._id);
      } catch (error) {
        navigate('/', { replace: true });
      } finally {
        setIsLoadingChat(false);
      }
    }, [navigate]);

  const clearChat = useCallback(() => { setMessages([]); setActiveChatId(null); setEditingIndex(null); }, []);
  const startEditing = (index: number) => setEditingIndex(index);
  const cancelEditing = () => setEditingIndex(null);

  const saveAndSubmitEdit = async (index: number, newContent: string) => {
    if (!activeChatId) return;
    stopGeneration();
    const historyUpToEdit = messagesRef.current.slice(0, index);
    const updatedUserMessage: Message = { ...messages[index], content: newContent };
    const newHistory = [...historyUpToEdit, updatedUserMessage];
    const messagesForUi = [...newHistory, { role: 'assistant', content: '', isWaiting: true } as Message];
    setMessages(messagesForUi);
    setEditingIndex(null);
    await streamAndSaveResponse(activeChatId, newHistory, { isRegeneration: true, isThinkingEnabled });
  };

  const regenerateResponse = async (metadata?: Record<string, any>) => {
    if (!activeChatId || isStreaming || isSending) return;
    const currentMessages = messagesRef.current;
    const lastUserIndex = currentMessages.findLastIndex((m) => m.role === 'user');
    if (lastUserIndex === -1) return;
    const historyForRegeneration = currentMessages.slice(0, lastUserIndex + 1);
    const messagesWithPlaceholder = [...historyForRegeneration, { role: 'assistant', content: '', isWaiting: true } as Message];
    setMessages(messagesWithPlaceholder);
    await streamAndSaveResponse(activeChatId, historyForRegeneration, { isRegeneration: true, ...metadata, client_time: getLocalTime(), isThinkingEnabled });
  };

  const renameChat = async (chatId: string, newTitle: string) => {
    try {
      await api(`/chats/${chatId}`, { method: 'PUT', body: JSON.stringify({ title: newTitle }) });
      await loadChatList();
      showNotification('Chat renamed!', 'success');
    } catch (e) { showNotification('Rename failed', 'error'); }
  };

  const deleteChat = async (chatId: string) => {
    try {
      await api(`/chats/${chatId}`, { method: 'DELETE' });
      setChatList((prev) => prev.filter((c) => c._id !== chatId));
      if (activeChatId === chatId) { navigate('/', { replace: true }); clearChat(); }
      showNotification('Chat deleted.', 'success');
    } catch (e) { showNotification('Delete failed', 'error'); }
  };

  const clearAllChats = async () => {
    try {
      await api('/chats/all', { method: 'DELETE' });
      setChatList([]); clearChat();
      showNotification('Cleared all chats.', 'success');
    } catch (e) { showNotification('Clear failed', 'error'); }
  };

  const value = {
    messages, chatList, activeChatId, loadChat, clearChat, isLoadingChat, isLoadingChatList, isCreatingChat, isSending,
    sendMessage, isStreaming, editingIndex, startEditing, cancelEditing, saveAndSubmitEdit, regenerateResponse, renameChat,
    isThinking, thinkingContent, isThinkingEnabled, toggleThinking, stopGeneration, deleteChat, clearAllChats, sendGeolocationResult
  };

  return <ChatContext.Provider value={value}>{children}</ChatContext.Provider>;
};

export const useChat = () => {
  const context = useContext(ChatContext);
  if (context === undefined) throw new Error('useChat must be used within a ChatProvider');
  return context;
};
- - - NavigationContext.tsx:
// src/contexts/NavigationContext.tsx
import { createContext, useContext, useState, useCallback, useEffect, useRef, ReactNode } from 'react';
import {
  Position,
  NavigationStep,
  calculateDistance,
  findCurrentStep,
  isOffRoute,
  getNotificationDistance,
  calculateSpeed,
  calculateETA,
} from '../utils/navigationHelpers';

export interface NavigationState {
  isNavigating: boolean;
  currentPosition: Position | null;
  currentStepIndex: number;
  distanceToNextTurn: number;
  totalRemainingDistance: number;
  currentSpeed: number; // meters per second
  averageSpeed: number;
  eta: Date | null;
  heading: number | null; // User's heading in degrees
  offRoute: boolean;
  steps: NavigationStep[];
  destination: Position | null;
  error: string | null;
}

interface NavigationContextType {
  navigation: NavigationState;
  startNavigation: (steps: NavigationStep[], destination: Position) => void;
  stopNavigation: () => void;
  acknowledgeOffRoute: () => void;
}

const NavigationContext = createContext<NavigationContextType | undefined>(undefined);

export const useNavigation = () => {
  const context = useContext(NavigationContext);
  if (!context) {
    throw new Error('useNavigation must be used within NavigationProvider');
  }
  return context;
};

interface NavigationProviderProps {
  children: ReactNode;
}

export const NavigationProvider = ({ children }: NavigationProviderProps) => {
  const [navigation, setNavigation] = useState<NavigationState>({
    isNavigating: false,
    currentPosition: null,
    currentStepIndex: 0,
    distanceToNextTurn: 0,
    totalRemainingDistance: 0,
    currentSpeed: 0,
    averageSpeed: 0,
    eta: null,
    heading: null,
    offRoute: false,
    steps: [],
    destination: null,
    error: null,
  });

  const watchIdRef = useRef<number | null>(null);
  const lastPositionRef = useRef<{ pos: Position; time: number } | null>(null);
  const speedHistoryRef = useRef<number[]>([]);
  const lastNotificationStepRef = useRef<number>(-1);

  // Speech synthesis for voice guidance
  const speakInstruction = useCallback((text: string) => {
    if ('speechSynthesis' in window) {
      window.speechSynthesis.cancel(); // Cancel any ongoing speech
      const utterance = new SpeechSynthesisUtterance(text);
      utterance.rate = 1.0;
      utterance.pitch = 1.0;
      utterance.volume = 1.0;
      window.speechSynthesis.speak(utterance);
    }
  }, []);

  // Send notification (Capacitor or browser)
  const sendNotification = useCallback(async (title: string, body: string) => {
    // Try Capacitor LocalNotifications first (for mobile)
    try {
      const { LocalNotifications } = await import('@capacitor/local-notifications');
      
      // Check and request permission if needed
      const permission = await LocalNotifications.checkPermissions();
      if (permission.display === 'granted') {
        await LocalNotifications.schedule({
          notifications: [
            {
              id: Date.now(),
              title,
              body,
              smallIcon: 'ic_stat_icon_config_sample',
              sound: undefined,
              attachments: undefined,
              actionTypeId: '',
              extra: null,
            },
          ],
        });
        return;
      } else if (permission.display === 'prompt') {
        const requested = await LocalNotifications.requestPermissions();
        if (requested.display === 'granted') {
          await LocalNotifications.schedule({
            notifications: [
              {
                id: Date.now(),
                title,
                body,
                smallIcon: 'ic_stat_icon_config_sample',
                sound: undefined,
                attachments: undefined,
                actionTypeId: '',
                extra: null,
              },
            ],
          });
          return;
        }
      }
    } catch (error) {
      // Capacitor not available, fall back to browser notifications
      console.log('Using browser notifications:', error);
    }

    // Fallback to browser notifications
    if ('Notification' in window && Notification.permission === 'granted') {
      try {
        new Notification(title, {
          body,
          icon: '/icon-192x192.png',
          badge: '/icon-192x192.png',
          tag: 'navigation',
          requireInteraction: false,
        });
      } catch (error) {
        console.error('Notification error:', error);
      }
    }
  }, []);

  // Request notification permission
  const requestNotificationPermission = useCallback(async () => {
    if ('Notification' in window && Notification.permission === 'default') {
      await Notification.requestPermission();
    }
  }, []);

  // Process location update
  const processLocationUpdate = useCallback(
    (position: GeolocationPosition) => {
      const newPos: Position = {
        lat: position.coords.latitude,
        lng: position.coords.longitude,
      };

      setNavigation((prev) => {
        if (!prev.isNavigating || prev.steps.length === 0) return prev;

        const now = Date.now();
        let currentSpeed = 0;
        let averageSpeed = prev.averageSpeed;

        // Calculate speed
        if (lastPositionRef.current) {
          const timeDelta = now - lastPositionRef.current.time;
          if (timeDelta > 0) {
            currentSpeed = calculateSpeed(
              lastPositionRef.current.pos,
              newPos,
              timeDelta
            );

            // Update speed history (keep last 10 readings)
            speedHistoryRef.current.push(currentSpeed);
            if (speedHistoryRef.current.length > 10) {
              speedHistoryRef.current.shift();
            }

            // Calculate average speed
            if (speedHistoryRef.current.length > 0) {
              averageSpeed =
                speedHistoryRef.current.reduce((a, b) => a + b, 0) /
                speedHistoryRef.current.length;
            }
          }
        }

        lastPositionRef.current = { pos: newPos, time: now };

        // Find current step
        const newStepIndex = findCurrentStep(newPos, prev.steps, prev.currentStepIndex);
        const currentStep = prev.steps[newStepIndex];
        const nextStep = prev.steps[newStepIndex + 1];

        // Calculate distance to next turn (end of current step)
        const distanceToNextTurn = calculateDistance(newPos, currentStep.end_location);

        // Calculate total remaining distance
        let totalRemainingDistance = distanceToNextTurn;
        for (let i = newStepIndex + 1; i < prev.steps.length; i++) {
          totalRemainingDistance += prev.steps[i].distance.value;
        }

        // Check if off route
        const offRoute = isOffRoute(newPos, currentStep, nextStep);

        // Calculate ETA
        const eta = averageSpeed > 0 
          ? calculateETA(totalRemainingDistance, averageSpeed)
          : null;

        // Voice guidance: announce turns
        const notificationDist = getNotificationDistance(currentSpeed);
        const shouldNotify =
          distanceToNextTurn <= notificationDist &&
          lastNotificationStepRef.current !== newStepIndex;

        if (shouldNotify && newStepIndex < prev.steps.length - 1) {
          lastNotificationStepRef.current = newStepIndex;
          const instruction = currentStep.instructions
            .replace(/<[^>]*>/g, '') // Remove HTML tags
            .substring(0, 100); // Limit length

          speakInstruction(`In ${Math.round(distanceToNextTurn)} meters, ${instruction}`);
          sendNotification('Turn ahead', instruction);
        }

        // Announce step change
        if (newStepIndex !== prev.currentStepIndex && newStepIndex < prev.steps.length) {
          const instruction = currentStep.instructions.replace(/<[^>]*>/g, '');
          speakInstruction(instruction);
        }

        return {
          ...prev,
          currentPosition: newPos,
          currentStepIndex: newStepIndex,
          distanceToNextTurn,
          totalRemainingDistance,
          currentSpeed,
          averageSpeed,
          eta,
          heading: position.coords.heading,
          offRoute,
        };
      });
    },
    [speakInstruction, sendNotification]
  );

  // Handle geolocation errors
  const handleLocationError = useCallback((error: GeolocationPositionError) => {
    let errorMessage = 'Location error';
    switch (error.code) {
      case error.PERMISSION_DENIED:
        errorMessage = 'Location permission denied';
        break;
      case error.POSITION_UNAVAILABLE:
        errorMessage = 'Location unavailable';
        break;
      case error.TIMEOUT:
        errorMessage = 'Location request timed out';
        break;
    }
    
    setNavigation((prev) => ({ ...prev, error: errorMessage }));
    console.error('Navigation location error:', error);
  }, []);

  // Start navigation
  const startNavigation = useCallback(
    (steps: NavigationStep[], destination: Position) => {
      if (!navigator.geolocation) {
        setNavigation((prev) => ({
          ...prev,
          error: 'Geolocation not supported',
        }));
        return;
      }

      // Request notification permission
      requestNotificationPermission();

      // Reset state
      lastPositionRef.current = null;
      speedHistoryRef.current = [];
      lastNotificationStepRef.current = -1;

      setNavigation({
        isNavigating: true,
        currentPosition: null,
        currentStepIndex: 0,
        distanceToNextTurn: 0,
        totalRemainingDistance: steps.reduce((sum, step) => sum + step.distance.value, 0),
        currentSpeed: 0,
        averageSpeed: 0,
        eta: null,
        heading: null,
        offRoute: false,
        steps,
        destination,
        error: null,
      });

      // Start watching position with high accuracy
      watchIdRef.current = navigator.geolocation.watchPosition(
        processLocationUpdate,
        handleLocationError,
        {
          enableHighAccuracy: true,
          timeout: 10000,
          maximumAge: 0,
        }
      );

      // Initial announcement
      if (steps.length > 0) {
        const firstInstruction = steps[0].instructions.replace(/<[^>]*>/g, '');
        speakInstruction(`Navigation started. ${firstInstruction}`);
        sendNotification('Navigation started', firstInstruction);
      }
    },
    [processLocationUpdate, handleLocationError, speakInstruction, sendNotification, requestNotificationPermission]
  );

  // Stop navigation
  const stopNavigation = useCallback(() => {
    if (watchIdRef.current !== null) {
      navigator.geolocation.clearWatch(watchIdRef.current);
      watchIdRef.current = null;
    }

    // Cancel any speech
    if ('speechSynthesis' in window) {
      window.speechSynthesis.cancel();
    }

    lastPositionRef.current = null;
    speedHistoryRef.current = [];
    lastNotificationStepRef.current = -1;

    setNavigation({
      isNavigating: false,
      currentPosition: null,
      currentStepIndex: 0,
      distanceToNextTurn: 0,
      totalRemainingDistance: 0,
      currentSpeed: 0,
      averageSpeed: 0,
      eta: null,
      heading: null,
      offRoute: false,
      steps: [],
      destination: null,
      error: null,
    });

    sendNotification('Navigation stopped', 'You have ended navigation');
  }, [sendNotification]);

  // Acknowledge off-route warning
  const acknowledgeOffRoute = useCallback(() => {
    setNavigation((prev) => ({ ...prev, offRoute: false }));
  }, []);

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      if (watchIdRef.current !== null) {
        navigator.geolocation.clearWatch(watchIdRef.current);
      }
      if ('speechSynthesis' in window) {
        window.speechSynthesis.cancel();
      }
    };
  }, []);

  return (
    <NavigationContext.Provider
      value={{
        navigation,
        startNavigation,
        stopNavigation,
        acknowledgeOffRoute,
      }}
    >
      {children}
    </NavigationContext.Provider>
  );
};
- - - NotificationContext.tsx:
// src/contexts/NotificationContext.tsx
import { createContext, useState, useRef, useContext, type ReactNode, useCallback, useMemo } from 'react';

interface NotificationContextType {
  showNotification: (message: string, type?: 'success' | 'error') => void;
  notificationMessage: string;
  isNotificationVisible: boolean;
  notificationType: 'success' | 'error';
}

const NotificationContext = createContext<NotificationContextType | undefined>(undefined);

export const NotificationProvider = ({ children }: { children: ReactNode }) => {
  const [notificationMessage, setNotificationMessage] = useState('');
  const [isNotificationVisible, setIsNotificationVisible] = useState(false);
  const [notificationType, setNotificationType] = useState<'success' | 'error'>('success');
  const timeoutRef = useRef<number | null>(null);

  const showNotification = useCallback((message: string, type: 'success' | 'error' = 'success') => {
    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current);
    }
    
    setNotificationMessage(message);
    setNotificationType(type);
    setIsNotificationVisible(true);
    
    timeoutRef.current = window.setTimeout(() => {
      setIsNotificationVisible(false);
    }, 2500);
  }, []);

  const value = useMemo(() => ({ 
    showNotification, 
    notificationMessage, 
    isNotificationVisible, 
    notificationType 
  }), [showNotification, notificationMessage, isNotificationVisible, notificationType]);

  return (
    <NotificationContext.Provider value={value}>
      {children}
    </NotificationContext.Provider>
  );
};

export const useNotification = () => {
  const context = useContext(NotificationContext);
  if (context === undefined) {
    throw new Error('useNotification must be used within a NotificationProvider');
  }
  return context;
};
- - - SettingsContext.tsx:
// src/contexts/SettingsContext.tsx
import { createContext, useState, useEffect, useContext, type ReactNode, useCallback } from 'react';
import api, { API_BASE_URL } from '../utils/api'; 

type Model = {
  id: string;
};

type Modality = 'text' | 'image' | 'code' | 'reasoning';

type ModelConfig = {
  id: string;
  modalities: Modality[];
};

type Theme = 'dark' | 'light';
type VoiceSettings = {
  voiceId: string;
  voiceName?: string;
  ttsModel?: string;
  stability?: number;
  similarity?: number;
};

type ApiKeyEntry = {
  provider: string;
  key: string;
};

type User = {
  _id: string;
  email: string;
  apiKeys: ApiKeyEntry[];
  baseUrl: string;
  selectedProvider: string;
  selectedModel: string;
  theme: Theme;
  quickAccessModels?: string[];
  modelConfigs?: ModelConfig[];
  enabledIntegrations?: string[];
  contextLength?: number;
  maxOutputTokens?: number;
  stripeCustomerId?: string | null;
  subscriptionId?: string | null;
  subscriptionStatus?: 'active' | 'canceled' | 'incomplete' | 'past_due' | 'unpaid' | null;
  planId?: string | null;
  voiceSettings?: VoiceSettings;
};

interface SettingsContextType {
  token: string | null;
  isAuthenticated: boolean;
  loading: boolean;
  user: User | null;
  models: Model[];
  selectedModel: string;
  theme: Theme;
  setTheme: (theme: Theme) => void;
  setModels: (models: Model[]) => void;
  loadUser: () => Promise<void>;
  login: (email: string, password: string) => Promise<void>;
  register: (email: string, password: string) => Promise<void>;
  logout: () => void;
  updateSettings: (settings: Partial<User>) => Promise<void>;
}

const SettingsContext = createContext<SettingsContextType | undefined>(undefined);

export const SettingsProvider = ({ children }: { children: ReactNode }) => {
  const [token, setToken] = useState<string | null>(localStorage.getItem('fexo-token'));
  const [isAuthenticated, setIsAuthenticated] = useState<boolean>(false);
  const [loading, setLoading] = useState<boolean>(true);
  const [user, setUser] = useState<User | null>(null);
  const [models, setModels] = useState<Model[]>([]);
  
  const [theme, setThemeState] = useState<Theme>(() => (localStorage.getItem('fexo-theme') as Theme) || 'light');

  const updateSettings = async (settings: Partial<User>) => {
    if (!token) return;
    try {
      const res = await api('/settings', {
        method: 'PUT',
        body: JSON.stringify(settings),
      });
      if (!res.ok) throw new Error('Failed to update settings');
      const updatedUser = await res.json();
      setUser(updatedUser);
    } catch (err) {
      throw err;
    }
  };

  const setTheme = (newTheme: Theme) => {
    setThemeState(newTheme);
    if (isAuthenticated) {
      updateSettings({ theme: newTheme }).catch(() => {});
    }
  };

  useEffect(() => {
    document.body.setAttribute('data-theme', theme);
    localStorage.setItem('fexo-theme', theme);
  }, [theme]);
  
  const loadUser = useCallback(async () => {
    const currentToken = localStorage.getItem('fexo-token');
    if (currentToken) {
      try {
        const res = await api('/settings');
        if (!res.ok) throw new Error('Failed to load user');
        const userData: User = await res.json();
        setUser(userData);
        setIsAuthenticated(true);
        if (userData.theme) {
          setThemeState(userData.theme);
        }
      } catch (err) {
        localStorage.removeItem('fexo-token');
        setToken(null);
        setIsAuthenticated(false);
      }
    }
    setLoading(false);
  }, []);

  useEffect(() => {
    loadUser();
  }, [loadUser]);

  useEffect(() => {
    const fetchModelsOnLoad = async () => {
      if (user && user.apiKeys && user.apiKeys.length > 0) {
        const provider = user?.selectedProvider;
        
        if (user.apiKeys.some(k => k.provider === provider && k.key)) {
            try {
                const res = await api('/models', { method: 'POST', body: JSON.stringify({ provider }) });
        if (res.ok) {
          const data = await res.json();
          // Deduplicate models by id to avoid React key collisions in selectors
          const seen = new Set<string>();
          const uniqueModels = (Array.isArray(data) ? data : []).filter((m: Model) => {
            if (!m || !m.id) return false;
            if (seen.has(m.id)) return false;
            seen.add(m.id);
            return true;
          });
          setModels(uniqueModels);
        } else {
                    setModels([]);
                }
            } catch (err) {
                setModels([]);
            }
        }
      }
    };
    fetchModelsOnLoad();
  }, [user]);

  const apiAuthRequest = async (endpoint: 'login' | 'register', body: object) => {
    const url = `${API_BASE_URL}/api/auth/${endpoint}`;
    // Changed from console.log to console.debug so they disappear in production via main.tsx override
    console.debug('[AUTH] Attempting request to:', url);
    console.debug('[AUTH] API_BASE_URL:', API_BASE_URL);
    
    const res = await fetch(url, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(body),
    });
    
    console.debug('[AUTH] Response status:', res.status, res.statusText);
    
    const data = await res.json();
    if (!res.ok) {
      throw new Error(data.error || data.errors?.[0]?.msg || 'Authentication failed');
    }
    localStorage.setItem('fexo-token', data.token);
    setToken(data.token);
    await loadUser();
  };

  const login = (email: string, password: string) => apiAuthRequest('login', { email, password });
  const register = (email: string, password: string) => apiAuthRequest('register', { email, password });

  const logout = () => {
    localStorage.removeItem('fexo-token');
    setThemeState('light'); 
    setToken(null);
    setIsAuthenticated(false);
    setUser(null);
    setModels([]);
    setLoading(false);
  };

  return (
    <SettingsContext.Provider 
      value={{ 
        token, isAuthenticated, loading, user,
        models, setModels, theme, setTheme,
        selectedModel: user?.selectedModel || '',
        loadUser, login, register, logout, updateSettings
      }}
    >
      {children}
    </SettingsContext.Provider>
  );
};

export const useSettings = () => {
  const context = useContext(SettingsContext);
  if (context === undefined) {
    throw new Error('useSettings must be used within a SettingsProvider');
  }
  return context;
};
- - - SidePanelContext.tsx:
// src/contexts/SidePanelContext.tsx
import { createContext, useContext, useState, ReactNode } from 'react';

type SidePanelType = 'sources' | 'html_preview' | null;

interface SidePanelContextType {
  isOpen: boolean;
  panelType: SidePanelType;
  panelData: any;
  openPanel: (type: SidePanelType, data: any) => void;
  closePanel: () => void;
}

const SidePanelContext = createContext<SidePanelContextType | undefined>(undefined);

export const SidePanelProvider = ({ children }: { children: ReactNode }) => {
  const [isOpen, setIsOpen] = useState(false);
  const [panelType, setPanelType] = useState<SidePanelType>(null);
  const [panelData, setPanelData] = useState<any>(null);

  const openPanel = (type: SidePanelType, data: any) => {
    setPanelType(type);
    setPanelData(data);
    setIsOpen(true);
  };

  const closePanel = () => {
    setIsOpen(false);
    setPanelType(null);
    setPanelData(null);
  };

  return (
    <SidePanelContext.Provider value={{ isOpen, panelType, panelData, openPanel, closePanel }}>
      {children}
    </SidePanelContext.Provider>
  );
};

export const useSidePanel = () => {
  const context = useContext(SidePanelContext);
  if (context === undefined) {
    throw new Error('useSidePanel must be used within a SidePanelProvider');
  }
  return context;
};
- - css/
- - - AnalysisBlock.css:
/* src/css/AnalysisBlock.css */

.analysis-container {
  margin: 8px 0;
  border-radius: 8px;
  overflow: hidden;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
  background-color: transparent;
  border: none;
  transition: none;
  width: 100%;
}

/* --- Header Styling (Matches Code Block) --- */
.analysis-header {
  display: flex;
  flex-direction: column;
  align-items: flex-start;
  padding: 6px 0;
  background-color: transparent;
  cursor: pointer;
  user-select: none;
  border-radius: 6px;
  width: fit-content;
  max-width: 100%;
}

.analysis-header:hover {
  opacity: 0.9;
}

.analysis-header-content {
  display: flex;
  align-items: center;
  gap: 8px;
  width: 100%;
}

.analysis-header-left {
  display: flex;
  align-items: center;
  font-size: 0.95rem;
  color: var(--primary-text-color);
  font-weight: 500;
}

.analysis-label {
  color: var(--primary-text-color);
  font-weight: 500;
}

.analysis-label.error {
  color: #ef4444;
}

.chevron-icon {
  color: var(--secondary-text-color);
  transition: transform 0.2s ease;
}

.analysis-container.expanded .chevron-icon {
  transform: rotate(180deg);
}

/* --- Expanded Content Area --- */
.analysis-content {
  margin-top: 4px;
  background-color: #0d0d0d;
  border-radius: 8px;
  border: 1px solid #333;
  overflow: hidden;
  animation: expandBlock 0.3s ease-out;
  padding: 8px; /* Padding around the internal card */
}

[data-theme="light"] .analysis-content {
  background-color: #f9f9f9;
  border-color: #e5e7eb;
}

@keyframes expandBlock {
  from { opacity: 0; transform: translateY(-5px); }
  to { opacity: 1; transform: translateY(0); }
}

/* --- File Card Styling --- */
.analysis-file-card {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 10px 12px;
  background-color: #1f2937; /* Dark inner card */
  border: 1px solid #374151;
  border-radius: 6px;
  transition: background-color 0.2s;
}

[data-theme="light"] .analysis-file-card {
  background-color: #ffffff;
  border-color: #e5e7eb;
}

.file-icon-box {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 32px;
  height: 32px;
  background-color: rgba(59, 130, 246, 0.15); /* Blue tint */
  border-radius: 6px;
  color: #60a5fa;
  flex-shrink: 0;
}

[data-theme="light"] .file-icon-box {
  background-color: #eff6ff;
  color: #3b82f6;
}

.analysis-container.state-error .file-icon-box {
  background-color: rgba(239, 68, 68, 0.15);
  color: #f87171;
}

.file-info {
  display: flex;
  flex-direction: column;
  gap: 2px;
  flex: 1;
  min-width: 0;
}

.file-name {
  font-size: 0.9rem;
  color: var(--primary-text-color);
  font-weight: 500;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.file-status {
  font-size: 0.75rem;
  color: var(--secondary-text-color);
}

.file-check-icon {
  color: #10b981; /* Green check */
  flex-shrink: 0;
}

/* Error Details Text */
.analysis-error-details {
  margin-top: 8px;
  padding: 8px;
  background-color: rgba(239, 68, 68, 0.1);
  border-radius: 6px;
  color: #f87171;
  font-size: 0.85rem;
  font-family: var(--font-mono);
  white-space: pre-wrap;
}

/* Animations */
.analysis-label.animate-shine {
  background: linear-gradient(to right, var(--primary-text-color) 20%, var(--secondary-text-color) 50%, var(--primary-text-color) 80%);
  background-size: 200% auto;
  background-clip: text;
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  animation: shine 3s linear infinite;
}

@keyframes shine {
  to {
    background-position: 200% center;
  }
}
- - - AuthPage.css:
/* src/css/AuthPage.css */

@keyframes spin {
  to { transform: rotate(360deg); }
}

@keyframes floatBlob {
  0% { transform: translate(0, 0) scale(1); }
  33% { transform: translate(30px, -50px) scale(1.1); }
  66% { transform: translate(-20px, 20px) scale(0.9); }
  100% { transform: translate(0, 0) scale(1); }
}

.auth-container {
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 100svh; 
  background-color: var(--main-bg-color); 
  position: relative;
  overflow: hidden;
}

.auth-background {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
}

/* Updated to Purple/Pink Accents */
.circle {
  position: absolute;
  border-radius: 50%;
  filter: blur(80px);
  opacity: 0.5;
  animation: floatBlob 20s infinite ease-in-out;
}

.circle-1 {
  width: 400px;
  height: 400px;
  background: #8b5cf6; /* Purple */
  top: -10%;
  left: -10%;
  animation-delay: 0s;
}

.circle-2 {
  width: 350px;
  height: 350px;
  background: #ec4899; /* Pink */
  bottom: -5%;
  right: -5%;
  animation-delay: -5s;
}

.circle-3 {
  width: 300px;
  height: 300px;
  background: #6366f1; /* Indigo */
  top: 40%;
  left: 40%;
  opacity: 0.3;
  animation-delay: -10s;
}

.auth-form-wrapper {
  background-color: var(--main-bg-color);
  /* Add subtle border and shadow */
  border: 1px solid var(--border-color);
  box-shadow: 0 20px 40px -10px rgba(0, 0, 0, 0.1);
  
  padding: 3rem;
  border-radius: 24px;
  width: 90%;
  max-width: 420px;
  text-align: center;
  position: relative;
  z-index: 2;
  transition: opacity 0.3s var(--ease-spring), transform 0.3s var(--ease-spring);
}

[data-theme="dark"] .auth-form-wrapper {
  background-color: rgba(39, 39, 42, 0.8); /* Semi-transparent dark */
  backdrop-filter: blur(12px);
  box-shadow: 0 20px 40px -10px rgba(0, 0, 0, 0.3);
}

.auth-form-wrapper.fading {
  opacity: 0;
  transform: translateY(10px);
}

.auth-logo {
  height: 48px;
  margin-bottom: 1rem;
}

.auth-title {
  font-size: 1.8rem;
  font-weight: 700;
  margin: 0 0 0.5rem 0;
  color: var(--primary-text-color);
}

.auth-subtitle {
  font-size: 1.1rem;
  font-weight: 500;
  color: var(--secondary-text-color);
  margin: 0 0 2rem 0;
}

.auth-form-group {
  margin-bottom: 1.25rem;
  text-align: left;
}

.auth-form-group label {
  display: block;
  margin-bottom: 0.5rem;
  font-weight: 600;
  font-size: 0.875rem;
  color: var(--primary-text-color);
}

.auth-form-group input {
  width: 100%;
  padding: 0.75rem 1rem;
  border-radius: 12px;
  border: 1px solid var(--border-color);
  background-color: var(--input-bg-color);
  color: var(--primary-text-color);
  font-size: 1rem;
  box-sizing: border-box;
  transition: all 0.2s var(--ease-spring);
}

.auth-form-group input:focus {
  outline: none;
  border-color: var(--accent-primary);
  box-shadow: 0 0 0 3px var(--accent-bg);
}

/* Primary Action Button */
.auth-button {
  background-color: var(--accent-primary);
  color: #ffffff;
  padding: 0.75rem 1.5rem; 
  border: none;
  border-radius: 12px;
  cursor: pointer;
  font-weight: 600;
  font-size: 1rem;
  transition: transform 0.2s var(--ease-spring), filter 0.2s ease;
  margin-top: 1.5rem;
  width: 100%;
  display: inline-flex;
  align-items: center;
  justify-content: center;
}

.auth-button:not(:disabled):hover {
  filter: brightness(1.1);
  transform: translateY(-2px);
}

.auth-button:disabled {
  opacity: 0.6;
  cursor: not-allowed;
}

.auth-loader {
  width: 1.2rem;
  height: 1.2rem;
  border: 2px solid rgba(255, 255, 255, 0.3);
  border-top-color: #ffffff;
  border-radius: 50%;
  animation: spin 0.8s linear infinite;
}

.auth-error {
  background-color: rgba(239, 68, 68, 0.1);
  color: #ef4444;
  border: 1px solid rgba(239, 68, 68, 0.2);
  border-radius: 12px;
  padding: 0.75rem;
  margin-bottom: 1.5rem;
  font-size: 0.9rem;
}

/* Toggle between Login/Register */
.auth-toggle {
  margin-top: 2rem;
  font-size: 0.9rem;
  color: var(--secondary-text-color);
}

.auth-toggle button {
  background: none;
  border: none;
  color: var(--accent-primary); /* High contrast accent */
  font-weight: 600;
  cursor: pointer;
  margin-left: 0.5rem;
  padding: 0;
  transition: color 0.2s;
}

.auth-toggle button:hover {
  color: var(--accent-hover);
  text-decoration: underline;
}

@media (max-width: 600px) {
  .auth-background { display: none; }
  .auth-container { background-color: var(--main-bg-color); }
  .auth-form-wrapper {
    width: 100%;
    height: 100%;
    max-width: none;
    border: none;
    box-shadow: none;
    border-radius: 0;
    background: transparent;
    padding: 2rem 1.5rem;
    display: flex;
    flex-direction: column;
    justify-content: center;
  }
}
- - - ChatInput.css:
/* src/css/ChatInput.css */
.chat-input-container {
  width: 100%;
  max-width: 800px;
  margin: 0 auto;
  padding: 0 1rem;
  box-sizing: border-box;
  position: relative;
}

.attachment-preview-area {
  display: flex;
  gap: 8px;
  padding: 8px;
  margin-bottom: 8px;
  background-color: var(--input-bg-color);
  border: 1px solid var(--border-color);
  border-radius: 12px;
  overflow-x: auto;
}

.attachment-thumbnail {
  position: relative;
  flex-shrink: 0;
}

.attachment-thumbnail img {
  width: 60px;
  height: 60px;
  border-radius: 8px;
  object-fit: cover;
  border: 1px solid var(--border-color);
}

.remove-attachment-btn {
  position: absolute;
  top: -4px;
  right: -4px;
  background-color: rgba(0, 0, 0, 0.7);
  color: white;
  border: none;
  border-radius: 50%;
  width: 20px;
  height: 20px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  opacity: 0.8;
  transition: opacity 0.2s, transform 0.2s;
  z-index: 1;
}

.remove-attachment-btn:hover {
  opacity: 1;
  transform: scale(1.1);
}

.chat-input-wrapper {
  display: flex;
  align-items: center; 
  gap: 0;
  background: var(--input-bg-color);
  border: 1px solid var(--border-color);
  border-radius: 16px;
  padding: 8px;
  position: relative;
  transition: border-color 0.2s ease;
}

.chat-input {
  flex-grow: 1;
  background: none;
  border: none;
  outline: none;
  color: var(--primary-text-color);
  font-size: 1rem;
  line-height: 1.5;
  resize: none;
  font-family: inherit;
  margin: 0 8px; 
  padding: 0;
  height: 24px;
  max-height: 120px;
  overflow: hidden;
  word-wrap: break-word;
  align-self: center; 
}

@keyframes slideUpFadeIn {
  from {
    opacity: 0;
    transform: translateY(10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.context-menu {
  position: absolute;
  bottom: calc(100% + 8px); 
  left: 8px;
  background-color: var(--button-hover-bg);
  border: 1px solid var(--border-color);
  border-radius: 12px;
  padding: 8px;
  z-index: 10;
  box-shadow: 0 4px 12px rgba(0,0,0,0.15);
  display: flex;
  flex-direction: column;
  gap: 4px;
  width: 200px;
  animation: slideUpFadeIn 0.2s cubic-bezier(0.4, 0, 0.2, 1) forwards;
}

.context-menu-button {
  display: flex;
  align-items: center;
  gap: 12px;
  width: 100%;
  background: none;
  border: none;
  color: var(--primary-text-color);
  padding: 10px 12px;
  border-radius: 8px;
  text-align: left;
  font-size: 0.95rem;
  font-family: inherit;
  cursor: pointer;
  transition: background-color 0.2s ease;
}

.context-menu-button:hover {
  background-color: var(--main-bg-color);
}

.menu-button-icon {
  color: var(--secondary-text-color);
  flex-shrink: 0;
}

.chat-input.scrollable {
  overflow-y: auto;
}

.chat-input::-webkit-scrollbar {
  width: 6px;
}
.chat-input::-webkit-scrollbar-track {
  background: transparent;
}
.chat-input::-webkit-scrollbar-thumb {
  background-color: var(--border-color);
  border-radius: 3px;
}

.chat-input-button {
  background: none;
  border: none;
  color: var(--secondary-text-color);
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: background-color 0.2s ease-in-out, color 0.2s ease-in-out, opacity 0.2s ease-in-out, transform 0.2s cubic-bezier(0.4, 0, 0.2, 1);
  flex-shrink: 0;
  width: 36px;
  height: 36px;
  padding: 0;
  border-radius: 50%;
}

.chat-input-button:active:not(:disabled) {
  transform: scale(0.95);
}

.chat-input-button svg {
  display: block;
  margin: 0;
  padding: 0;
}

.chat-input-button:hover:not(:disabled) {
  background-color: var(--button-hover-bg);
}

.reasoning-button {
  transition: all 0.2s ease;
}

.reasoning-button .reasoning-icon {
  width: 20px;
  height: 20px;
  fill: var(--secondary-text-color);
  transition: fill 0.2s ease;
}

.reasoning-button.active {
  background-color: var(--accent-bg);
}

.reasoning-button.active .reasoning-icon {
  fill: var(--accent-color);
}

.reasoning-button:hover .reasoning-icon {
  fill: var(--primary-text-color);
}

.reasoning-button.active:hover {
  background-color: var(--accent-hover-bg);
}

.reasoning-button.active:hover .reasoning-icon {
  fill: var(--accent-color);
}

.chat-tool-button svg {
  display: block;
  margin: 0;
  padding: 0;
}

.chat-input-actions {
  display: flex;
  align-items: center;
  /* The gap is now handled by the send-button's margin */
}

.mic-button {
  background-color: #000000 !important;
  color: #ffffff !important;
  border-radius: 50%;
  box-shadow: 0 0 0 0 rgba(16, 185, 129, 0);
  transition: all 0.3s ease, opacity 0.2s ease, transform 0.2s cubic-bezier(0.4, 0, 0.2, 1);
  position: relative;
  /* Ensure width is set for smooth transitions */
  width: 36px;
  margin-left: 8px;
}

.mic-button::before {
  content: '';
  position: absolute;
  inset: -2px;
  border-radius: 50%;
  background: linear-gradient(135deg, #10b981, #059669, #34d399);
  opacity: 0;
  z-index: -1;
  filter: blur(8px);
  transition: opacity 0.3s ease;
}

.mic-button:hover:not(.mic-button-disabled) {
  background-color: #1a1a1a !important;
  box-shadow: 0 0 20px rgba(16, 185, 129, 0.6), 0 0 40px rgba(16, 185, 129, 0.3);
  transform: scale(1.05);
}

.mic-button:hover:not(.mic-button-disabled)::before {
  opacity: 1;
}

.mic-button:active:not(.mic-button-disabled) {
  transform: scale(0.95);
}

.mic-button-disabled {
  opacity: 0.4;
  cursor: not-allowed;
  box-shadow: none;
}

.mic-button-disabled:hover {
  background-color: #000000 !important;
  transform: none;
}

/* Dark theme - white background with inverted colors */
[data-theme="dark"] .mic-button {
  background-color: #ffffff !important;
  color: #000000 !important;
}

[data-theme="dark"] .mic-button::before {
  background: linear-gradient(135deg, #10b981, #059669, #34d399);
}

[data-theme="dark"] .mic-button:hover:not(.mic-button-disabled) {
  background-color: #f0f0f0 !important;
  box-shadow: 0 0 20px rgba(16, 185, 129, 0.6), 0 0 40px rgba(16, 185, 129, 0.3);
}

[data-theme="dark"] .mic-button-disabled {
  background-color: #ffffff !important;
  opacity: 0.4;
}

[data-theme="dark"] .mic-button-disabled:hover {
  background-color: #ffffff !important;
}

/* --- START OF THE FIX --- */
.send-button {
  background-color: #FFFFFF;
  color: #2f2f2f;
  /* ADD width and margin-left to the transition */
  transition: opacity 0.2s ease, transform 0.2s cubic-bezier(0.4, 0, 0.2, 1), background-color 0.2s ease, width 0.3s cubic-bezier(0.4, 0, 0.2, 1), margin-left 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  
  /* HIDDEN STATE: Set initial width and margin to 0 */
  opacity: 0;
  transform: scale(0.7);
  pointer-events: none;
  width: 0;
  margin-left: 0;
  overflow: hidden; /* Prevent icon from showing during shrink */
}

.chat-input-button:not(:disabled).send-button {
  /* VISIBLE STATE: Animate to full width and add a margin */
  opacity: 1;
  transform: scale(1);
  pointer-events: auto;
  width: 36px;
  margin-left: 8px; /* This creates the gap only when the button is visible */
}
/* --- END OF THE FIX --- */


.stop-button {
  border: 1px solid #ef4444;
  color: #ef4444;
  background-color: transparent;
  margin-left: 8px; /* Ensure stop button has a gap */
}
.stop-button:hover {
  background-color: hsla(0, 84%, 60%, 0.1);
  border-color: #dc2626;
  color: #dc2626;
}
[data-theme="light"] .stop-button {
  border-color: #b91c1c;
  color: #b91c1c;
}
[data-theme="light"] .stop-button:hover {
  background-color: #fef2f2;
  border-color: #991b1b;
  color: #991b1b;
}

.chat-tools-section {
  display: flex;
  align-items: center;
  gap: 4px;
  padding: 0 4px 0 0;
}

.chat-tool-button {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 36px;
  height: 36px;
  background: transparent;
  border: none;
  border-radius: 8px;
  color: var(--text-secondary);
  cursor: pointer;
  transition: all 0.15s ease;
  position: relative;
}

.chat-tool-button.active {
  background: var(--accent-bg);
  color: var(--accent-color);
}

.chat-input-divider {
  width: 1px;
  height: 28px;
  background: var(--border-color);
  margin: 0 4px;
  opacity: 0.5;
  align-self: center;
}

.send-button:disabled {
  cursor: not-allowed;
  background-color: #c2c2d6;
}

@keyframes spin {
  to { transform: rotate(360deg); }
}

.button-spinner {
  width: 18px;
  height: 18px;
  border: 2px solid rgba(47, 47, 47, 0.5);
  border-top-color: #2f2f2f;
  border-radius: 50%;
  animation: spin 0.8s linear infinite;
}

[data-theme="dark"] .button-spinner {
    border-color: rgba(255, 255, 255, 0.5);
    border-top-color: #fff;
}

[data-theme="light"] .send-button {
  background-color: var(--primary-text-color);
  color: var(--main-bg-color);
}

[data-theme="light"] .send-button:disabled {
  background-color: #e0e0e0;
  color: #a0a0a0;
}

[data-theme="light"] {
  --accent-bg: rgba(99, 102, 241, 0.1);
  --accent-color: rgb(99, 102, 241);
  --accent-hover-bg: rgba(99, 102, 241, 0.15);
}

[data-theme="dark"] {
  --accent-bg: rgba(139, 92, 246, 0.15);
  --accent-color: rgb(139, 92, 246);
  --accent-hover-bg: rgba(139, 92, 246, 0.2);
}

.attachment-preview-wrapper {
  position: relative;
  flex-shrink: 0;
}

.attachment-file-preview {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 4px;
  width: 60px;
  height: 60px;
  border-radius: 8px;
  border: 1px solid var(--border-color);
  background-color: var(--button-hover-bg);
  padding: 4px;
  box-sizing: border-box;
  overflow: hidden;
}

.file-preview-icon {
  font-size: 24px;
  color: var(--secondary-text-color);
  line-height: 1;
}

.file-preview-name {
  font-size: 10px;
  color: var(--secondary-text-color);
  width: 100%;
  text-align: center;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.chat-input-container {
  position: relative;
}

.chat-input-container.drag-active .chat-input-wrapper {
  border: 2px dashed #10b981;
  transition: border-color 0.3s ease;
}

/* Dark theme adjustment */
[data-theme="dark"] .chat-input-container.drag-active .chat-input-wrapper {
  border-color: #22c55e;
}
- - - ChatMessage.css:
/* src/css/ChatMessage.css */
.chat-message-wrapper {
  padding: 1rem 0;
  position: relative;
}

.chat-message-container {
  max-width: 800px;
  margin: 0 auto;
  display: flex;
  padding: 0 1rem;
}

/* Attachment Layout */
.message-attachments {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
}

.attachment-image-wrapper {
  display: block;
  width: 72px;
  height: 72px;
  flex-shrink: 0;
  border-radius: 12px;
  overflow: hidden;
}

.attachment-image-wrapper img {
  width: 100%;
  height: 100%;
  object-fit: cover;
  cursor: pointer;
  transition: transform 0.2s ease, box-shadow 0.2s ease;
  border: 1px solid var(--border-color);
  display: block;
}

.attachment-image-wrapper:hover img {
  transform: scale(1.05);
  box-shadow: 0 4px 12px rgba(0,0,0,0.2);
}

.message-actions {
  display: flex;
  gap: 0.5rem;
  opacity: 0;
  transition: opacity 0.2s ease-in-out;
  flex-shrink: 0;
}

.chat-message-wrapper:hover .message-actions {
  opacity: 1;
}


.katex {
  font-size: 1.1em;
  color: var(--primary-text-color);
}

.action-button {
  background: var(--main-bg-color);
  border: 1px solid var(--border-color);
  color: var(--secondary-text-color);
  padding: 4px;
  border-radius: 6px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  height: 28px;
  width: 28px;
  transition: all 0.2s ease-in-out;
}

.action-button:hover {
  background: var(--button-hover-bg);
  color: var(--primary-text-color);
}

.assistant .message-content-wrapper {
  flex-grow: 1;
  position: relative;
  padding-bottom: 32px; 
  min-width: 0;
}

.message-content-wrapper.is-thinking {
  padding-bottom: 0;
}

@keyframes shimmer {
  0% { background-position: -200% center; }
  100% { background-position: 200% center; }
}

.thinking-text-shimmer {
  background: linear-gradient(90deg, 
    var(--secondary-text-color) 25%, 
    var(--primary-text-color) 50%, 
    var(--secondary-text-color) 75%
  );
  background-size: 200% 100%;
  -webkit-background-clip: text;
  -moz-background-clip: text;
  background-clip: text;
  color: transparent;
  animation: shimmer 2.5s linear infinite;
}

.inline-thinking-indicator {
  display: flex;
  justify-content: flex-start;
  align-items: center;
  color: var(--secondary-text-color);
  padding: 10px 14px;
}

.thinking-indicator-header {
  display: flex;
  align-items: center;
  gap: 8px;
}

.expand-thinking-button {
  background: transparent;
  border: none;
  color: var(--secondary-text-color);
  cursor: pointer;
  padding: 4px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: background-color 0.2s;
}

.expand-thinking-button:hover {
  background-color: var(--button-hover-bg);
  color: var(--primary-text-color);
}

.thinking-content-details {
  max-height: 0;
  overflow-y: auto;
  transition: max-height 0.3s ease-in-out, padding-top 0.3s ease-in-out, padding-bottom 0.3s ease-in-out, border-top-width 0.3s ease-in-out;
  padding: 0 14px 0 24px;
  background-color: var(--code-block-header);
  color: var(--secondary-text-color);
  font-size: 0.9em;
  line-height: 1.5;
  border-top: 0px solid var(--border-color);
  white-space: pre-wrap;
  word-wrap: break-word;
  position: relative;
}

.thinking-content-details::before {
  content: '';
  position: absolute;
  left: 14px;
  top: 14px;
  bottom: 14px;
  width: 2px;
  background-color: var(--border-color);
  border-radius: 2px;
  opacity: 0;
  transition: opacity 0.3s ease-in-out;
}

.thinking-content-details.expanded {
  max-height: 500px;
  padding-top: 14px;
  padding-bottom: 14px;
  border-top-width: 1px;
}

.thinking-content-details.expanded::before {
  opacity: 1;
}

.thinking-content-details p {
  margin: 0;
}

.thinking-dots {
  display: flex;
  gap: 1px;
}

.thinking-dots span {
  animation: thinking-blink 1.4s infinite both;
}

.thinking-dots span:nth-child(2) {
  animation-delay: 0.2s;
}

.thinking-dots span:nth-child(3) {
  animation-delay: 0.4s;
}

@keyframes thinking-blink {
  0%, 80%, 100% {
    opacity: 0;
  }
  40% {
    opacity: 1;
  }
}

.message-content {
  line-height: 1.6;
  white-space: pre-wrap;
  word-wrap: break-word;
  display: flex;
  flex-direction: column;
  gap: 0.75rem;
}

.assistant .message-content {
  color: var(--primary-text-color);
  flex-grow: 1;
}

.message-content > :first-child { margin-top: 0; }
.message-content > :last-child { margin-bottom: 0; }
.message-content p, .message-content ul, .message-content ol, .message-content blockquote,
.message-content pre, .message-content table, .message-content h1, .message-content h2,
.message-content h3 {
  margin: 0;
}
.message-content h1, .message-content h2, .message-content h3 {
  font-weight: 600;
  line-height: 1.3;
  border-bottom: 1px solid var(--border-color);
  padding-bottom: 0.3em;
}
.message-content h1 { font-size: 1.6em; }
.message-content h2 { font-size: 1.4em; }
.message-content h3 { font-size: 1.2em; }
.message-content ul, .message-content ol { padding-left: 1.75rem; }
.message-content li > p { display: inline; }
.message-content blockquote {
  padding: 0 1em;
  color: var(--secondary-text-color);
  border-left: 0.25em solid var(--border-color);
}
.message-content a { color: #60a5fa; text-decoration: underline; }
.message-content a:hover { color: #93c5fd; }
.message-content table {
  width: auto;
  max-width: 100%;
  border-collapse: collapse;
  border: 1px solid var(--border-color);
}
.message-content th, .message-content td {
  padding: 8px 12px;
  border: 1px solid var(--border-color);
}
.message-content thead { background-color: hsl(0, 0%, 15%); }
.message-content tr:nth-child(2n) { background-color: hsl(0, 0%, 12%); }
.message-content code:not([class*="language-"]) {
  color: #f472b6;
  padding: 0.2em 0.4em;
  margin: 0;
  font-size: 85%;
  border-radius: 6px;
  font-family: var(--font-mono, monospace);
  white-space: pre-wrap;
}

.code-block-wrapper {
  background-color: #0d1117;
  border-radius: 8px;
  overflow: hidden;
  border: 1px solid var(--border-color);
}
.code-block-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 4px 12px;
  font-size: 0.55rem;
  line-height: 1;
  background-color: var(--code-block-header);
  color: var(--secondary-text-color);
}
.language-name { text-transform: lowercase; font-family: var(--font-mono, monospace); }
.copy-code-button {
  display: flex;
  align-items: center;
  gap: 6px;
  background: none;
  border: none;
  color: var(--secondary-text-color);
  cursor: pointer;
  padding: 4px 6px;
  border-radius: 6px;
  transition: background-color 0.2s, color 0.2s;
  font-family: inherit;
  font-size: 0.8rem;
}
.copy-code-button:hover {
  background-color: rgba(255, 255, 255, 0.1);
  color: var(--primary-text-color);
}
.code-block-wrapper > div {
  margin: 0 !important;
  border-radius: 0 !important;
  font-family: var(--font-mono, monospace) !important;
  font-size: 0.9rem !important;
  line-height: 1.5 !important;
  white-space: pre-wrap !important;
  word-break: break-all !important;
}
.code-block-wrapper code {
  font-family: inherit !important;
  white-space: inherit !important;
  word-break: inherit !important;
}

.assistant .message-actions {
  position: absolute;
  left: 0;
  bottom: 0;
}

.user .chat-message-container { flex-direction: column; align-items: flex-end; gap: 0.5rem; }
.user-message-bubble {
  background-color: #2f2f2f;
  color: #ECECEC;
  padding: 0.6rem 1rem;
  border-radius: 1.25rem;
  max-width: 80%;
  flex-grow: 0;
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  overflow: hidden;
  position: relative;
  min-height: 26px;
}
.user .message-content { min-height: inherit; }
.user.editing .user-message-bubble {
  background-color: #424242;
  border-radius: 1.25rem;
  padding: 1rem;
  transform: scale(1.02);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
  border: 1px solid var(--border-color);
  max-width: min(80%, 500px);
  width: max(var(--initial-width, auto), 600px);
  min-height: var(--initial-height, 120px);
}
.user.editing .message-content { opacity: 0; position: absolute; pointer-events: none; }
.message-editor-content { 
  opacity: 0; 
  transform: translateY(10px); 
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); 
  transition-delay: 0.1s; 
  display: flex; 
  flex-direction: column; 
  gap: 1rem; 
  width: 100%; 
  min-height: var(--initial-height, 120px); 
}
.user.editing .message-editor-content { opacity: 1; transform: translateY(0); }
.message-editor-content textarea { 
  background: transparent; 
  border: none; 
  outline: none; 
  resize: none; 
  color: #ECECEC; 
  font-family: inherit; 
  font-size: 1rem; 
  line-height: 1.6; 
  width: 100%; 
  min-height: 120px; 
  max-height: 400px;
  overflow-y: auto;
  transition: height 0.3s cubic-bezier(0.4, 0, 0.2, 1); 
  padding: 0; 
  margin: 0; 
  scrollbar-width: thin;
  scrollbar-color: var(--border-color) transparent;
}
.message-editor-content textarea::-webkit-scrollbar {
  width: 6px;
}
.message-editor-content textarea::-webkit-scrollbar-track {
  background: transparent;
}
.message-editor-content textarea::-webkit-scrollbar-thumb {
  background-color: var(--border-color);
  border-radius: 3px;
}
.user.editing .message-editor-content textarea { height: var(--initial-height, auto); }
.editor-actions { display: flex; justify-content: flex-end; gap: 0.75rem; opacity: 0; transform: translateY(10px); transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); transition-delay: 0.2s; margin-top: 0.5rem; }
.user.editing .editor-actions { opacity: 1; transform: translateY(0); }
.editor-button { border: none; padding: 0.5rem 1rem; border-radius: 0.75rem; font-weight: 500; cursor: pointer; transition: all 0.2s ease-in-out; transform: scale(0.95); }
.user.editing .editor-button { transform: scale(1); }
.editor-button.cancel { background-color: #212121; color: #ECECEC; }
.editor-button.cancel:hover { background-color: #3a3a3a; transform: scale(1.05); }
.editor-button.save { background-color: #ffffff; color: #000000; }
.editor-button.save:hover { background-color: #f0f0f0; transform: scale(1.05); }
.user .message-actions { position: static; transition: opacity 0.2s ease-in-out, transform 0.2s ease-in-out; }
.user.editing .message-actions { opacity: 0; transform: scale(0.8); pointer-events: none; }

@keyframes blink { 50% { opacity: 0; } }
.streaming-cursor {
  display: block;
  width: 2px;
  height: 1em;
  background-color: var(--secondary-text-color);
  animation: blink 1s infinite;
  position: relative;
  top: -1px;
  margin-top: 4px;
}

/* Smooth streaming text animation */
.message-content.is-streaming > * {
  animation: streamTextFadeIn 0.3s ease-out;
}

@keyframes streamTextFadeIn {
  from {
    opacity: 0;
    transform: translateY(2px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

/* Make streaming content appear smoothly */
.message-content.is-streaming {
  animation: none; /* Override to allow child animations */
}

/* Smooth fade for each paragraph/element as it streams */
.message-content.is-streaming p,
.message-content.is-streaming li,
.message-content.is-streaming code,
.message-content.is-streaming pre,
.message-content.is-streaming blockquote,
.message-content.is-streaming h1,
.message-content.is-streaming h2,
.message-content.is-streaming h3,
.message-content.is-streaming h4,
.message-content.is-streaming h5,
.message-content.is-streaming h6 {
  animation: streamElementFadeIn 0.25s ease-out;
}

@keyframes streamElementFadeIn {
  from {
    opacity: 0;
    filter: blur(1px);
  }
  to {
    opacity: 1;
    filter: blur(0);
  }
}

/* --- NEW: Waiting for response indicator --- */
.waiting-indicator {
  display: flex;
  align-items: center;
  gap: 6px;
  /* Match vertical padding of a user bubble for alignment */
  padding: 0.6rem 0;
}

.waiting-indicator .dot {
  width: 10px;
  height: 10px;
  background-color: var(--secondary-text-color);
  border-radius: 50%;
  animation: blink-dots 1.4s infinite both;
  transition: background-color 0.3s;
}

.waiting-indicator .dot:nth-child(2) {
  animation-delay: 0.2s;
}

.waiting-indicator .dot:nth-child(3) {
  animation-delay: 0.4s;
}

@keyframes blink-dots {
  0%, 80%, 100% {
    opacity: 0.3;
    transform: scale(0.9);
  }
  40% {
    opacity: 1;
    transform: scale(1);
  }
}

[data-theme="light"] .waiting-indicator .dot {
  background-color: var(--secondary-text-color);
}

.chat-message-wrapper.assistant .message-content:has(.code-analysis-container.executing) { animation: gentlePulse 2s ease-in-out infinite; }
@keyframes gentlePulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.9; } }

.attachment-image-wrapper.loading, .attachment-image-wrapper.error { background-color: var(--button-hover-bg); display: flex; align-items: center; justify-content: center; color: var(--secondary-text-color); font-size: 0.8rem; padding: 8px; box-sizing: border-box; text-align: center; line-height: 1.2; border: 1px solid var(--border-color); }
.attachment-image-wrapper.error { background-color: rgba(239, 68, 68, 0.1); color: #f87171; border-color: rgba(239, 68, 68, 0.3); }

[data-theme="light"] .assistant .message-content,
[data-theme="light"] .streaming-cursor { color: var(--primary-text-color); }
[data-theme="light"] .user-message-bubble { background-color: var(--assistant-message-bg); color: var(--primary-text-color); }
[data-theme="light"] .user.editing .user-message-bubble { background-color: var(--main-bg-color); border-color: var(--border-color); box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1); }
[data-theme="light"] .message-editor-content textarea { color: var(--primary-text-color); }
[data-theme="light"] .editor-button.cancel { background-color: var(--button-hover-bg); color: var(--primary-text-color); }
[data-theme="light"] .editor-button.cancel:hover { background-color: #e5e7eb; }
[data-theme="light"] .editor-button.save { background-color: var(--primary-text-color); color: var(--main-bg-color); }
[data-theme="light"] .editor-button.save:hover { background-color: #374151; }

[data-theme="light"] .message-content a { color: #2563eb; }
[data-theme="light"] .message-content a:hover { color: #3b82f6; }
[data-theme="light"] .message-content table { border-color: var(--border-color); }
[data-theme="light"] .message-content th, [data-theme="light"] .message-content td { border-color: var(--border-color); }
[data-theme="light"] .message-content thead { background-color: var(--button-hover-bg); }
[data-theme="light"] .message-content tr:nth-child(2n) { background-color: transparent; }
[data-theme="light"] .message-content code:not([class*="language-"]) { color: var(--primary-text-color); }
[data-theme="light"] .code-block-wrapper { background-color: #fafafa; border-color: var(--border-color); }
[data-theme="light"] .code-block-header { background-color: var(--code-block-header); color: var(--code-block-text); }
[data-theme="light"] .code-block-header .language-name { color: var(--code-text); }
[data-theme="light"] .code-block-header .copy-code-button { color: var(--code-text); }
[data-theme="light"] .code-block-header .copy-code-button:hover { background-color: #374151; color: var(--main-bg-color); }

[data-theme="light"] .thinking-content-details {
  background-color: var(--assistant-message-bg);
  color: var(--secondary-text-color);
}

.attachment-file-link {
  display: inline-flex;
  align-items: center;
  gap: 8px;
  padding: 8px 12px;
  background-color: var(--button-hover-bg);
  border-radius: 8px;
  text-decoration: none;
  font-size: 0.9rem;
  border: 1px solid var(--border-color);
  color: var(--primary-text-color);
  transition: background-color 0.2s;
}

.attachment-file-link:hover {
  background-color: var(--main-bg-color);
}

.attachment-file-icon {
  font-size: 18px;
  color: var(--secondary-text-color);
  line-height: 1;
  flex-shrink: 0;
}

.attachment-file-name {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

/* --- NEW: Markdown Image Styling --- */
.markdown-image-wrapper {
  display: block;
  max-width: 450px;
  max-height: 400px;
  width: auto;
  border-radius: 12px;
  overflow: hidden;
  cursor: pointer;
  border: 1px solid var(--border-color);
  margin-top: 0.5rem;
  margin-bottom: 0.5rem;
  transition: transform 0.2s ease, box-shadow 0.2s ease;
  background-color: var(--button-hover-bg);
}

.markdown-image-wrapper:hover {
  transform: scale(1.02);
  box-shadow: 0 4px 12px rgba(0,0,0,0.15);
}

.markdown-image-wrapper img {
  width: 100%;
  height: 100%;
  object-fit: cover;
  display: block;
}

.user .message-content .markdown-image-wrapper {
  align-self: flex-end;
}

.message-content li .markdown-image-wrapper {
  margin-top: 0.75rem;
  margin-bottom: 0.25rem;
}

/* --- START OF FIX --- */
@keyframes spin {
  to { transform: rotate(360deg); }
}

.spinner-icon {
  animation: spin 1s linear infinite;
  display: block; /* Ensures icon is treated as a block for layout */
}

.attachment-file-link.downloading {
  cursor: wait;
  opacity: 0.7;
  pointer-events: none; /* Prevent clicking again while downloading */
}

/* Styling for the text part of a named link */
.chat-link-text {
  color: #60a5fa;
  text-decoration: none;
  border-bottom: 1px dotted #60a5fa;
}
.chat-link-text:hover {
  color: #93c5fd;
  border-bottom-style: solid;
}

/* The standalone icon button (when URL text is hidden) */
.chat-link-icon-only {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  background-color: var(--button-hover-bg);
  border: 1px solid var(--border-color);
  color: #60a5fa; /* Blue accent */
  border-radius: 6px;
  padding: 4px 8px;
  margin: 0 4px;
  transition: all 0.2s ease;
  vertical-align: middle;
  line-height: 0;
  cursor: pointer;
}

.chat-link-icon-only:hover {
  background-color: rgba(96, 165, 250, 0.15); /* Light blue tint */
  transform: translateY(-1px);
  border-color: #60a5fa;
}

/* Adjust icon size inside */
.chat-link-icon-only svg {
  width: 16px;
  height: 16px;
}
- - - ChatView.css:
/* src/css/ChatView.css */

.chat-view-container {
  display: flex;
  flex-direction: column;
  height: 100vh;
  width: 100%;
  overflow: hidden;
  background-color: var(--main-bg-color);
  position: relative;
}

.chat-view-header {
  display: flex;
  justify-content: center;
  padding: 1rem;
  flex-shrink: 0;
  z-index: 5;
}

.chat-view {
  flex-grow: 1;
  position: relative;
  overflow: hidden;
  display: flex;
  flex-direction: column;
}

.chat-content {
  width: 100%;
  overflow-y: auto;
  display: flex;
  flex-direction: column;
  flex-grow: 1;
  padding-bottom: 160px; /* Clearance for input */
  box-sizing: border-box;
  
  /* Smooth scrollbar */
  scrollbar-width: thin;
  scrollbar-color: var(--border-color) transparent;
}

.chat-content::-webkit-scrollbar {
  width: 6px;
}
.chat-content::-webkit-scrollbar-track {
  background: transparent;
}
.chat-content::-webkit-scrollbar-thumb {
  background-color: var(--border-color);
  border-radius: 3px;
}
.chat-content::-webkit-scrollbar-thumb:hover {
  background-color: var(--secondary-text-color);
}

.chat-messages-list {
  padding: 1rem 0;
  max-width: 100%;
}

/* --- Empty State --- */
.empty-chat-container {
  text-align: center;
  margin-bottom: 2rem;
}

.chat-view-container:not(.is-empty) .empty-chat-container {
  display: none;
}

.empty-chat-container h1 {
  font-size: 2rem;
  font-weight: 600;
  color: var(--primary-text-color);
  margin: 0;
  letter-spacing: -0.02em;
}

/* --- Input Area Wrapper --- */
.chat-input-area {
  position: absolute;
  left: 0;
  right: 0;
  bottom: 0;
  display: flex;
  flex-direction: column;
  align-items: center;
  width: 100%;
  max-width: 800px;
  padding: 1rem 0 2rem 0;
  margin: 0 auto;
  z-index: 10;
  /* Fade-to-transparent background behind input for content readability */
  background: linear-gradient(to top, var(--main-bg-color) 60%, transparent 100%);
}

/* Transition for empty state centering */
.chat-view-container.is-empty .chat-input-area {
  top: 0;
  bottom: 0;
  justify-content: center;
  background: none; /* No gradient needed in center */
}

/* --- Scroll to Bottom Button --- */
.scroll-to-bottom {
  position: absolute;
  bottom: 100%;
  left: 50%;
  transform: translateX(-50%);
  margin-bottom: 1rem;
  
  display: flex;
  align-items: center;
  justify-content: center;
  width: 36px;
  height: 36px;
  
  background-color: var(--button-hover-bg);
  border: 1px solid var(--border-color);
  color: var(--secondary-text-color);
  border-radius: 50%;
  cursor: pointer;
  box-shadow: 0 4px 12px rgba(0,0,0,0.1);
  transition: all 0.2s var(--ease-spring);
  z-index: 20;
}

.scroll-to-bottom:hover {
  background-color: var(--accent-bg);
  color: var(--accent-primary);
  border-color: var(--accent-primary);
  transform: translateX(-50%) translateY(-3px);
}

/* --- Loading Overlay --- */
.loading-overlay {
  position: absolute;
  inset: 0;
  background-color: rgba(255, 255, 255, 0.5);
  backdrop-filter: blur(2px);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 20;
}

[data-theme="dark"] .loading-overlay {
  background-color: rgba(0, 0, 0, 0.5);
}

@media (max-width: 768px) {
  .chat-view-header { display: none; }
  
  .chat-view-container:not(.is-empty) .chat-input-area {
    position: fixed;
    bottom: 0;
    background: var(--main-bg-color);
    border-top: 1px solid var(--border-color);
    padding: 0.75rem 1rem max(1rem, env(safe-area-inset-bottom));
    max-width: 100%;
  }
}
- - - CodeAnalysisBlock.css:
/* src/css/CodeAnalysisBlock.css */

.code-analysis-container {
  margin: 8px 0;
  border-radius: 8px;
  overflow: hidden;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
  background-color: transparent;
  border: none;
  transition: none;
  width: 100%; /* Ensure full width */
}

/* --- Header Styling --- */
.analysis-header {
  display: flex;
  flex-direction: column; /* Change to column to stack title and preview */
  align-items: flex-start;
  padding: 6px 0;
  background-color: transparent;
  cursor: pointer;
  user-select: none;
  border-radius: 6px;
  width: fit-content;
  max-width: 100%;
}

.analysis-header:hover {
  opacity: 0.9;
}

.analysis-header-content {
  display: flex;
  align-items: center;
  gap: 8px;
  width: 100%;
}

.analysis-header-left {
  display: flex;
  align-items: center;
  font-size: 0.95rem;
  color: var(--primary-text-color);
  font-weight: 500;
}

.analysis-label {
  color: var(--primary-text-color);
  font-weight: 500;
}

.chevron-icon {
  color: var(--secondary-text-color);
  transition: transform 0.2s ease;
}

.code-analysis-container.expanded .chevron-icon {
  transform: rotate(180deg);
}

/* --- NEW: File Preview Strip (Collapsed State) --- */
.analysis-file-preview {
  display: flex;
  gap: 10px;
  margin-top: 8px;
  padding: 4px 2px; /* Slight padding for shadows */
  overflow-x: auto;
  max-width: 100%;
  scrollbar-width: none; /* Hide scrollbar Firefox */
}

.analysis-file-preview::-webkit-scrollbar {
  display: none; /* Hide scrollbar Chrome/Safari */
}

/* Preview Item Base */
.preview-item {
  flex-shrink: 0;
  border-radius: 6px;
  cursor: pointer;
  transition: transform 0.2s ease, box-shadow 0.2s ease;
  border: 1px solid var(--border-color);
  background-color: var(--button-hover-bg);
  overflow: hidden;
  position: relative;
}

.preview-item:hover {
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(0,0,0,0.1);
  border-color: var(--secondary-text-color);
}

/* Image Preview specific */
.preview-item.image {
  height: 48px;
  width: auto;
  min-width: 48px;
  display: flex;
  align-items: center;
  justify-content: center;
}

.preview-item.image img {
  height: 100%;
  width: auto;
  max-width: 100px;
  object-fit: cover;
  display: block;
}

/* File Chip Preview specific */
.preview-item.file {
  display: flex;
  align-items: center;
  gap: 8px;
  height: 36px; /* Smaller height than images */
  padding: 0 12px;
  margin-top: 6px; /* Align vertically with images roughly */
}

.file-icon-wrapper {
  color: var(--secondary-text-color);
  display: flex;
  align-items: center;
}

.preview-filename {
  font-size: 0.8rem;
  color: var(--primary-text-color);
  white-space: nowrap;
  max-width: 120px;
  overflow: hidden;
  text-overflow: ellipsis;
}

/* --- Expanded Content Area --- */
.analysis-content {
  margin-top: 4px;
  background-color: #0d0d0d;
  border-radius: 8px;
  border: 1px solid #333;
  overflow: hidden;
  animation: expandBlock 0.3s ease-out;
}

[data-theme="light"] .analysis-content {
  background-color: #f9f9f9;
  border-color: #e5e7eb;
}

@keyframes expandBlock {
  from { opacity: 0; transform: translateY(-5px); }
  to { opacity: 1; transform: translateY(0); }
}

/* Inner Code Header */
.code-block-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 8px 16px;
  background-color: #181818;
  border-bottom: 1px solid #333;
  font-size: 0.8rem;
  color: #b0b0b0;
  font-family: var(--font-mono, monospace);
}

[data-theme="light"] .code-block-header {
  background-color: #f1f1f1;
  border-bottom-color: #e5e7eb;
}

.lang-label {
  font-weight: 500;
  text-transform: lowercase;
}

.copy-btn {
  display: flex;
  align-items: center;
  gap: 6px;
  background: none;
  border: none;
  color: var(--code-block-text);
  cursor: pointer;
  font-size: 0.75rem;
  transition: color 0.2s;
}

.copy-btn:hover {
  color: #ffffff;
}

[data-theme="light"] .copy-btn:hover {
  color: #000000;
}

/* Code Body Wrapper */
.code-wrapper {
  margin: 0;
  padding: 0;
  overflow-x: auto;
  background-color: #0d0d0d;
}

[data-theme="light"] .code-wrapper {
  background-color: #f9f9f9;
}

.code-wrapper > div {
  margin: 0 !important;
  border-radius: 0 !important;
  font-family: 'Consolas', 'Monaco', 'Courier New', monospace !important;
  font-size: 0.9rem !important;
  line-height: 1.5 !important;
  background: transparent !important;
  padding: 16px !important;
}

.code-wrapper code {
  font-family: inherit !important;
  text-shadow: none !important;
}

/* Output Section */
.console-output {
  padding: 16px;
  border-top: 1px solid #333;
  background-color: #0d0d0d;
  color: #d4d4d4;
}

[data-theme="light"] .console-output {
  background-color: #f9f9f9;
  border-top-color: #e5e7eb;
  color: #333;
}

.console-header {
  font-size: 0.75rem;
  color: #888;
  margin-bottom: 8px;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  font-weight: 500;
}

.console-text {
  font-family: 'Consolas', 'Monaco', monospace;
  font-size: 0.85rem;
  color: #e0e0e0;
  white-space: pre-wrap;
  word-wrap: break-word;
  margin: 0;
  line-height: 1.4;
}

[data-theme="light"] .console-text {
  color: #333;
}

.console-text.error {
  color: #f87171;
}

.console-files {
  margin-top: 16px;
  display: flex;
  gap: 12px;
  flex-wrap: wrap;
}

.console-image img {
  max-height: 200px;
  border-radius: 6px;
  cursor: pointer;
  border: 1px solid #333;
  transition: transform 0.2s;
}

.console-image img:hover {
  transform: scale(1.02);
}

.console-file {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 8px 12px;
  background-color: #1f2937;
  border: 1px solid #374151;
  border-radius: 6px;
  color: #e5e7eb;
  font-size: 0.9rem;
}

.console-file button {
  display: flex;
  align-items: center;
  color: #9ca3af;
  transition: color 0.2s;
  background: none;
  border: none;
  padding: 4px;
  cursor: pointer;
}

.console-file button:hover {
  color: #fff;
}

.analysis-label.animate-shine {
  background: linear-gradient(to right, var(--primary-text-color) 20%, var(--secondary-text-color) 50%, var(--primary-text-color) 80%);
  background-size: 200% auto;
  background-clip: text;
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  animation: shine 3s linear infinite;
}

@keyframes shine {
  to {
    background-position: 200% center;
  }
}
- - - ConfirmationModal.css:
/* src/css/ConfirmationModal.css */
.confirm-modal-overlay {
  position: fixed;
  inset: 0;
  background-color: hsla(0, 0%, 0%, 0.6);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 2000;
  opacity: 0;
  animation: fadeIn 0.2s ease-out forwards;
}

@keyframes fadeIn {
  to { opacity: 1; }
}

.confirm-modal-content {
  background-color: var(--sidebar-bg-color);
  padding: 1.5rem 2rem;
  border-radius: 12px;
  width: 90%;
  max-width: 400px;
  border: 1px solid var(--border-color);
  color: var(--primary-text-color);
  box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.3);
  transform: scale(0.95);
  opacity: 0;
  animation: scaleIn 0.2s 0.05s ease-out forwards;
}

@keyframes scaleIn {
  to {
    transform: scale(1);
    opacity: 1;
  }
}

.confirm-modal-header {
  display: flex;
  align-items: center;
  gap: 0.75rem;
  padding-bottom: 0.75rem;
  border-bottom: 2px solid var(--border-color);
  margin-bottom: 1rem;
}

.confirm-modal-icon {
  color: var(--secondary-text-color);
  flex-shrink: 0;
}

.confirm-modal-content h3 {
  margin: 0;
  font-size: 1.125rem;
  font-weight: 600;
  text-align: left;
}

.confirm-modal-content p {
  color: var(--secondary-text-color);
  font-size: 0.9rem;
  margin-bottom: 1.5rem;
  line-height: 1.5;
  text-align: left;
}

.confirm-modal-actions {
  display: flex;
  justify-content: flex-end;
  gap: 0.5rem;
}

.confirm-modal-button {
  border: none;
  padding: 0.5rem 1rem;
  border-radius: 9999px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s ease-in-out;
  font-size: 0.875rem;
  min-width: 80px;
}

.confirm-modal-button.cancel {
  background-color: var(--main-bg-color);
  color: #ECECEC;
  border: 1px solid var(--border-color);
}
.confirm-modal-button.cancel:hover {
  background-color: var(--button-hover-bg);
}

.confirm-modal-button.confirm {
  background-color: #ffffff;
  color: #000000;
}
.confirm-modal-button.confirm:hover {
  background-color: #f0f0f0;
}

.confirm-modal-button.confirm.destructive {
  background-color: #ef4444; /* Red for destructive actions */
  color: white;
}
.confirm-modal-button.confirm.destructive:hover {
  background-color: #dc2626; /* Darker red */
}

/* --- LIGHT THEME STYLES --- */
[data-theme="light"] .confirm-modal-content {
  box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.1);
}

[data-theme="light"] .confirm-modal-button.cancel {
  background-color: var(--main-bg-color);
  color: var(--primary-text-color);
}

[data-theme="light"] .confirm-modal-button.confirm {
  background-color: var(--primary-text-color);
  color: var(--main-bg-color);
}

[data-theme="light"] .confirm-modal-button.confirm:hover {
  background-color: #374151; /* Dark gray */
}
- - - CustomModelSelector.css:
.custom-model-selector {
  position: relative;
  width: 100%;
  flex-grow: 1; /* Allows it to take up available space */
}

.custom-model-selector-button {
  width: 100%;
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 0.75rem 1rem;
  background-color: var(--main-bg-color);
  border: 1px solid var(--border-color);
  border-radius: 8px;
  color: var(--primary-text-color);
  font-size: 1rem;
  text-align: left;
  cursor: pointer;
  transition: border-color 0.2s, box-shadow 0.2s;
}

.custom-model-selector-button:not(:disabled):hover,
.custom-model-selector-button:not(:disabled):focus-visible {
  outline: none;
  border-color: #19c37d;
  box-shadow: 0 0 0 2px hsla(145, 63%, 42%, 0.3);
}

.custom-model-selector-button:disabled {
  background-color: var(--input-bg-color);
  cursor: not-allowed;
  opacity: 0.6;
}

.selected-model-name {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.chevron-icon {
  color: var(--secondary-text-color);
  transition: transform 0.2s ease-in-out;
  flex-shrink: 0;
}

.chevron-icon.open {
  transform: rotate(180deg);
}

.custom-model-selector-dropdown {
  position: absolute;
  top: calc(100% + 4px);
  left: 0;
  right: 0;
  max-height: 250px;
  overflow-y: auto;
  background-color: var(--sidebar-bg-color);
  border: 1px solid var(--border-color);
  border-radius: 8px;
  padding: 0.5rem;
  z-index: 1010;
  box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2);
  opacity: 0;
  transform: translateY(-10px);
  animation: dropdown-fade-in 0.2s ease forwards;
}

@keyframes dropdown-fade-in {
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.model-dropdown-item {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 0.75rem;
  padding: 0.75rem;
  border-radius: 6px;
  cursor: pointer;
  transition: background-color 0.2s;
  font-weight: 500;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.model-dropdown-item:not(.empty):hover {
  background-color: var(--button-hover-bg);
}

.model-dropdown-item.selected {
  background-color: var(--button-hover-bg);
  font-weight: 600;
}

.checkmark-icon {
  color: var(--primary-text-color);
  flex-shrink: 0;
}

.model-dropdown-item.empty {
    color: var(--secondary-text-color);
    cursor: default;
}
- - - GeolocationBlock.css:
/* src/css/GeolocationBlock.css */

.geolocation-container {
    padding-bottom: 1rem;
}

.geolocation-container .status-icon-wrapper {
    background-color: hsla(200, 80%, 60%, 0.15);
    color: #38bdf8;
}

[data-theme="light"] .geolocation-container .status-icon-wrapper {
    background-color: hsla(200, 80%, 60%, 0.2);
    color: #0284c7;
}

.geolocation-container.tool-block-container::before {
    display: none;
}

.geolocation-map-wrapper {
    padding: 0 1rem;
    margin-top: 0.75rem;
}

.geolocation-map-wrapper iframe {
    border-radius: 8px;
    border: 1px solid var(--border-color);
    width: 100%;
}
- - - GeolocationRequestBlock.css:
/* src/css/GeolocationRequestBlock.css */

.geolocation-wrapper {
  display: flex;
  flex-direction: column;
  width: 100%;
  margin: 8px 0;
  gap: 10px;
}

/* --- Content Card --- */
.geo-content-card {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 10px 14px;
    border-radius: 16px;
    background-color: var(--main-bg-color);
    border: 1px solid var(--border-color);
    align-self: flex-start;
    max-width: 90%;
    box-shadow: 0 1px 3px rgba(0,0,0,0.05);
}

.geo-icon-circle {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 28px;
    height: 28px;
    border-radius: 50%;
    background-color: rgba(59, 130, 246, 0.1); 
    color: #3b82f6;
    flex-shrink: 0;
}

.geo-text-content {
    display: flex;
    flex-direction: column;
}

.geo-text {
    font-size: 0.9rem;
    font-weight: 500;
    color: var(--primary-text-color);
    line-height: 1.3;
}

/* --- Actions Row --- */
.geo-actions-row {
    display: flex;
    align-items: center;
    justify-content: flex-start;
    gap: 12px;
    padding-left: 2px;
    width: 100%;
}

/* --- Pill Buttons --- */
.geo-square-btn {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 70px; 
    height: 40px;
    border-radius: 16px;
    border: none;
    cursor: pointer;
    transition: transform 0.2s ease, background-color 0.2s ease, color 0.2s ease;
    flex-shrink: 0;
}

/* LIGHT THEME BASE */
.geo-square-btn {
    background-color: #18181b;
    color: #ffffff;
    box-shadow: 0 2px 5px rgba(0,0,0,0.15);
}

.geo-square-btn:active {
    transform: scale(0.95);
}

/* Hover Effects */
.geo-square-btn.deny:hover {
    background-color: #27272a;
    color: #f87171;
}

.geo-square-btn.allow:hover {
    background-color: #22c55e;
    color: white;
}

/* --- DARK THEME ADJUSTMENTS --- */
[data-theme="dark"] .geo-content-card {
    background-color: var(--button-hover-bg);
    border-color: transparent;
}

[data-theme="dark"] .geo-icon-circle {
    background-color: rgba(59, 130, 246, 0.2);
    color: #60a5fa;
}

/* DARK THEME BUTTONS */
[data-theme="dark"] .geo-square-btn {
    background-color: #ffffff;
    color: #000000;
    box-shadow: 0 2px 5px rgba(0,0,0,0.4);
}

[data-theme="dark"] .geo-square-btn.deny:hover {
    background-color: #e5e5e5;
    color: #ef4444;
}

[data-theme="dark"] .geo-square-btn.allow:hover {
    background-color: #22c55e;
    color: #ffffff;
}
- - - GoogleMapsBlock.css:
/* src/css/GoogleMapsBlock.css */

/* --- Main Container --- */
.maps-container {
  margin: 0.5rem;
  border: 1px solid var(--border-color);
  border-radius: 16px;
  background-color: var(--button-hover-bg);
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);
  overflow: hidden;
}

@media (min-width: 768px) {
  .maps-container {
    margin: 1rem 0;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
  }
}

.maps-container.fullscreen {
  position: fixed;
  inset: 0;
  z-index: 9999;
  margin: 0;
  border-radius: 0;
  background: var(--main-bg-color);
  display: flex;
  flex-direction: column;
}

/* --- Header & Controls --- */
.maps-container .tool-block-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 0.75rem;
  border-bottom: 1px solid var(--border-color);
  flex-shrink: 0;
  gap: 0.5rem;
  min-height: 56px;
  box-sizing: border-box;
}

@media (min-width: 768px) {
  .maps-container .tool-block-header {
    padding: 0.75rem 1rem;
  }
}

.maps-container .status {
  color: #4285F4;
  display: flex;
  align-items: center;
  gap: 0.5rem;
  font-weight: 500;
  font-size: 0.9rem;
  flex-shrink: 0;
  min-width: 0;
}

@media (min-width: 768px) {
  .maps-container .status {
    gap: 0.75rem;
    font-size: 1rem;
  }
}

.maps-container .status span {
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.maps-container .status-icon-wrapper {
  color: #4285F4;
  background-color: transparent;
  padding: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  flex-shrink: 0;
}

.maps-container .status-icon-wrapper svg {
  width: 18px;
  height: 18px;
}

@media (min-width: 768px) {
  .maps-container .status-icon-wrapper svg {
    width: 20px;
    height: 20px;
  }
}

.maps-controls {
  display: flex;
  gap: 0.3rem;
  align-items: center;
  flex-wrap: nowrap;
  flex-shrink: 0;
}

@media (min-width: 768px) {
  .maps-controls {
    gap: 0.5rem;
  }
}

.map-control-btn {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 0.25rem;
  padding: 0.5rem;
  background: var(--button-hover-bg);
  border: 1px solid var(--border-color);
  border-radius: 8px;
  color: var(--primary-text-color);
  font-size: 0.75rem;
  cursor: pointer;
  transition: all 0.2s;
  white-space: nowrap;
  min-width: 36px;
  height: 36px;
  flex-shrink: 0;
  box-sizing: border-box;
}

@media (min-width: 480px) {
  .map-control-btn {
    min-width: 38px;
    height: 38px;
  }
}

@media (min-width: 640px) {
  .map-control-btn {
    padding: 0.5rem 0.75rem;
    min-width: auto;
    height: auto;
  }
}

@media (min-width: 768px) {
  .map-control-btn {
    gap: 0.35rem;
    font-size: 0.85rem;
  }
}

.map-control-btn:hover {
  background: var(--main-bg-color);
  border-color: #4285F4;
  transform: translateY(-1px);
}

.map-control-btn:active {
  transform: translateY(0);
}

.map-control-btn.active {
  background: #4285F4;
  color: white;
  border-color: #4285F4;
}

.map-control-btn svg {
  width: 16px;
  height: 16px;
  flex-shrink: 0;
}

.map-control-btn span {
  display: none;
}

@media (min-width: 640px) {
  .map-control-btn span {
    display: inline;
  }
}

/* Extra small screens optimization */
@media (max-width: 360px) {
  .maps-controls {
    gap: 0.25rem;
  }
  
  .map-control-btn {
    padding: 0.4rem;
    min-width: 32px;
    height: 32px;
  }
  
  .map-control-btn svg {
    width: 14px;
    height: 14px;
  }
  
  .maps-container .status {
    font-size: 0.85rem;
  }
  
  .maps-container .status-icon-wrapper svg {
    width: 16px;
    height: 16px;
  }
}

/* --- Main Layout --- */
.maps-container .tool-block-content {
  padding: 0;
  overflow: visible;
}

.maps-container.fullscreen .tool-block-content {
  height: calc(100vh - 56px);
  overflow: auto;
}

.maps-layout {
  display: flex;
  flex-direction: column;
  gap: 0.75rem;
  height: 100%;
  padding: 0.75rem;
  box-sizing: border-box;
}

@media (min-width: 768px) {
  .maps-layout {
    gap: 1rem;
    padding: 1rem;
  }
}

.maps-map-wrapper {
  flex-shrink: 0;
  height: 250px;
  border-radius: 12px;
  overflow: hidden;
  border: 1px solid var(--border-color);
  background-color: var(--button-hover-bg);
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.08);
}

@media (min-width: 640px) {
  .maps-map-wrapper {
    height: 350px;
  }
}

@media (min-width: 768px) {
  .maps-map-wrapper {
    height: 400px;
  }
}

.maps-info-panel {
  width: 100%;
  display: flex;
  flex-direction: column;
  gap: 0.75rem;
}

@media (min-width: 768px) {
  .maps-info-panel {
    gap: 1rem;
  }
}

/* --- Info Panel Sections --- */
.maps-route-summary {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 0.5rem;
}

@media (min-width: 768px) {
  .maps-route-summary {
    gap: 0.75rem;
  }
}

.route-info-item {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  padding: 0.75rem;
  background: var(--main-bg-color);
  border: 1px solid var(--border-color);
  border-radius: 10px;
  transition: all 0.2s;
}

@media (min-width: 768px) {
  .route-info-item {
    gap: 0.75rem;
    padding: 1rem;
  }
}

.route-info-item:hover {
  border-color: #4285F4;
  box-shadow: 0 2px 8px rgba(66, 133, 244, 0.1);
}

.route-icon {
  width: 20px;
  height: 20px;
  color: #4285F4;
  flex-shrink: 0;
}

@media (min-width: 768px) {
  .route-icon {
    width: 24px;
    height: 24px;
  }
}

.route-label {
  font-size: 0.7rem;
  color: var(--secondary-text-color);
  margin-bottom: 0.2rem;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

@media (min-width: 768px) {
  .route-label {
    font-size: 0.75rem;
    margin-bottom: 0.25rem;
  }
}

.route-value {
  font-size: 0.95rem;
  font-weight: 600;
  color: var(--primary-text-color);
}

@media (min-width: 768px) {
  .route-value {
    font-size: 1rem;
  }
}

.maps-locations {
  background: var(--main-bg-color);
  border: 1px solid var(--border-color);
  border-radius: 10px;
  padding: 0.75rem;
}

@media (min-width: 768px) {
  .maps-locations {
    padding: 1rem;
  }
}

.location-item {
  display: flex;
  align-items: flex-start;
  gap: 0.65rem;
}

@media (min-width: 768px) {
  .location-item {
    gap: 0.75rem;
  }
}

.location-marker {
  width: 26px;
  height: 26px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: bold;
  color: white;
  font-size: 0.75rem;
  flex-shrink: 0;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
}

@media (min-width: 768px) {
  .location-marker {
    width: 28px;
    height: 28px;
    font-size: 0.8rem;
  }
}

.location-item.start .location-marker {
  background: #4285F4;
}

.location-item.end .location-marker {
  background: #EA4335;
}

.location-details {
  flex: 1;
  min-width: 0;
}

.location-label {
  font-size: 0.7rem;
  color: var(--secondary-text-color);
  margin-bottom: 0.2rem;
  font-weight: 500;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

@media (min-width: 768px) {
  .location-label {
    font-size: 0.75rem;
    margin-bottom: 0.25rem;
  }
}

.location-address {
  font-size: 0.85rem;
  color: var(--primary-text-color);
  line-height: 1.4;
  word-wrap: break-word;
}

@media (min-width: 768px) {
  .location-address {
    font-size: 0.9rem;
  }
}

.location-divider {
  height: 16px;
  width: 2px;
  background: var(--border-color);
  margin: 0.4rem 0 0.4rem 12px;
}

@media (min-width: 768px) {
  .location-divider {
    height: 20px;
    margin: 0.5rem 0 0.5rem 13px;
  }
}

.maps-directions {
  background: var(--main-bg-color);
  border: 1px solid var(--border-color);
  border-radius: 10px;
  overflow: hidden;
}

.directions-header {
  font-weight: 600;
  color: var(--primary-text-color);
  font-size: 0.85rem;
  padding: 0.75rem;
  border-bottom: 1px solid var(--border-color);
  background: var(--button-hover-bg);
}

@media (min-width: 768px) {
  .directions-header {
    font-size: 0.95rem;
    padding: 1rem;
  }
}

.directions-list {
  display: flex;
  flex-direction: column;
  max-height: 250px;
  overflow-y: auto;
}

@media (min-width: 768px) {
  .directions-list {
    max-height: 300px;
  }
}

/* Scrollbar styling for directions list */
.directions-list::-webkit-scrollbar {
  width: 6px;
}

.directions-list::-webkit-scrollbar-track {
  background: var(--main-bg-color);
}

.directions-list::-webkit-scrollbar-thumb {
  background: var(--border-color);
  border-radius: 3px;
}

.directions-list::-webkit-scrollbar-thumb:hover {
  background: var(--secondary-text-color);
}

.direction-step {
  display: flex;
  gap: 0.65rem;
  padding: 0.65rem 0.75rem;
  border-bottom: 1px solid var(--border-color);
  transition: background 0.2s;
}

@media (min-width: 768px) {
  .direction-step {
    gap: 0.75rem;
    padding: 0.75rem 1rem;
  }
}

.direction-step:last-child {
  border-bottom: none;
}

.direction-step:hover {
  background: var(--button-hover-bg);
}

.step-number {
  width: 22px;
  height: 22px;
  border-radius: 50%;
  background: #4285F4;
  color: white;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 0.75rem;
  font-weight: 600;
  flex-shrink: 0;
  box-shadow: 0 1px 3px rgba(66, 133, 244, 0.3);
}

@media (min-width: 768px) {
  .step-number {
    width: 24px;
    height: 24px;
    font-size: 0.8rem;
  }
}

.step-content {
  flex: 1;
  min-width: 0;
}

.step-instruction {
  font-size: 0.8rem;
  color: var(--primary-text-color);
  margin-bottom: 0.25rem;
  line-height: 1.4;
  word-wrap: break-word;
}

@media (min-width: 768px) {
  .step-instruction {
    font-size: 0.85rem;
  }
}

.step-instruction b {
  font-weight: 600;
  color: #4285F4;
}

.step-distance {
  font-size: 0.7rem;
  color: var(--secondary-text-color);
}

@media (min-width: 768px) {
  .step-distance {
    font-size: 0.75rem;
  }
}

/* Start navigation button */
.start-navigation-btn {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 0.5rem;
  padding: 0.85rem;
  background: linear-gradient(135deg, #34A853 0%, #2d8e47 100%);
  color: white;
  border: none;
  border-radius: 10px;
  font-weight: 600;
  font-size: 0.95rem;
  cursor: pointer;
  transition: all 0.2s;
  width: 100%;
  box-shadow: 0 2px 8px rgba(52, 168, 83, 0.3);
  margin-bottom: 0.75rem;
}

@media (min-width: 768px) {
  .start-navigation-btn {
    padding: 0.75rem;
    margin-bottom: 1rem;
  }
}

.start-navigation-btn:hover {
  background: linear-gradient(135deg, #2d8e47 0%, #1e7e34 100%);
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(52, 168, 83, 0.4);
}

.start-navigation-btn:active {
  transform: translateY(0);
}

.start-navigation-btn svg {
  width: 20px;
  height: 20px;
}

.open-in-maps-btn {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 0.5rem;
  padding: 0.85rem;
  background: linear-gradient(135deg, #4285F4 0%, #3367D6 100%);
  color: white;
  border: none;
  border-radius: 10px;
  font-weight: 500;
  font-size: 0.9rem;
  cursor: pointer;
  transition: all 0.2s;
  width: 100%;
  box-shadow: 0 2px 8px rgba(66, 133, 244, 0.3);
}

@media (min-width: 768px) {
  .open-in-maps-btn {
    padding: 0.75rem;
  }
}

.open-in-maps-btn:hover {
  background: linear-gradient(135deg, #3367D6 0%, #2851A3 100%);
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(66, 133, 244, 0.4);
}

.open-in-maps-btn:active {
  transform: translateY(0);
}

.open-in-maps-btn svg {
  width: 18px;
  height: 18px;
}

/* Error and Loading States */
.maps-loading-state,
.maps-error-state {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100%;
  min-height: 200px;
  padding: 1.5rem;
  text-align: center;
  color: var(--secondary-text-color);
}

@media (min-width: 768px) {
  .maps-loading-state,
  .maps-error-state {
    padding: 2rem;
  }
}

.maps-error-state {
  color: var(--primary-text-color);
}

.maps-error-state svg {
  color: #ef4444;
  margin-bottom: 0.75rem;
  width: 32px;
  height: 32px;
}

@media (min-width: 768px) {
  .maps-error-state svg {
    margin-bottom: 1rem;
    width: 40px;
    height: 40px;
  }
}

.maps-error-state p {
  margin: 0.25rem 0;
  font-size: 0.9rem;
}

@media (min-width: 768px) {
  .maps-error-state p {
    font-size: 1rem;
  }
}

.maps-error-state pre {
  background: var(--button-hover-bg);
  padding: 0.5rem 0.75rem;
  border-radius: 6px;
  font-size: 0.75rem;
  margin-top: 0.75rem;
  color: var(--secondary-text-color);
  border: 1px solid var(--border-color);
  overflow-x: auto;
  max-width: 100%;
}

@media (min-width: 768px) {
  .maps-error-state pre {
    padding: 0.5rem 1rem;
    font-size: 0.8rem;
    margin-top: 1rem;
  }
}

/* --- Tablet & Small Desktop Breakpoint --- */
@media (min-width: 768px) {
  .maps-container.fullscreen .maps-map-wrapper {
    height: 60vh;
  }
}

/* --- Large Desktop Breakpoint --- */
@media (min-width: 1024px) {
  .maps-layout {
    flex-direction: row;
  }

  .maps-map-wrapper {
    flex: 1;
    height: 500px;
  }

  .maps-info-panel {
    width: 360px;
    flex-shrink: 0;
    max-height: 500px;
    overflow-y: auto;
  }

  /* Scrollbar styling for info panel on desktop */
  .maps-info-panel::-webkit-scrollbar {
    width: 6px;
  }

  .maps-info-panel::-webkit-scrollbar-track {
    background: var(--main-bg-color);
    border-radius: 3px;
  }

  .maps-info-panel::-webkit-scrollbar-thumb {
    background: var(--border-color);
    border-radius: 3px;
  }

  .maps-info-panel::-webkit-scrollbar-thumb:hover {
    background: var(--secondary-text-color);
  }

  .maps-container.fullscreen .maps-layout {
    flex-direction: row;
    align-items: flex-start;
  }

  .maps-container.fullscreen .maps-map-wrapper,
  .maps-container.fullscreen .maps-info-panel {
    height: calc(100vh - 56px - 2rem);
    max-height: none;
  }
}

/* Touch device optimizations */
@media (hover: none) and (pointer: coarse) {
  .map-control-btn {
    min-height: 44px;
    min-width: 44px;
  }

  .open-in-maps-btn {
    min-height: 48px;
  }
}
- - - ImageViewer.css:
/* src/css/ImageViewer.css */

/* --- Opening Animations --- */
@keyframes fadeInViewer {
  from { opacity: 0; }
  to { opacity: 1; }
}

@keyframes zoomInViewer {
  from { transform: scale(0.9); opacity: 0; }
  to { transform: scale(1); opacity: 1; }
}

/* --- START OF THE FIX: Closing Animations --- */
@keyframes fadeOutViewer {
  from { opacity: 1; }
  to { opacity: 0; }
}

@keyframes zoomOutViewer {
  from { transform: scale(1); opacity: 1; }
  to { transform: scale(0.9); opacity: 0; }
}
/* --- END OF THE FIX --- */


.image-viewer-overlay {
  position: fixed;
  inset: 0;
  background-color: hsla(0, 0%, 8%, 0.9);
  backdrop-filter: blur(8px);
  z-index: 3000;
  display: flex;
  justify-content: center;
  align-items: center;
  padding: 1rem;
  box-sizing: border-box;
  animation: fadeInViewer 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

.image-viewer-content {
  max-width: 90vw;
  max-height: 90vh;
  display: flex;
  justify-content: center;
  align-items: center;
  animation: zoomInViewer 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

/* --- START OF THE FIX: Add closing animation rules --- */
.image-viewer-overlay.closing {
  /* Use 'forwards' to hold the final state of the animation */
  animation: fadeOutViewer 0.3s cubic-bezier(0.4, 0, 0.2, 1) forwards;
}

.image-viewer-content.closing {
  animation: zoomOutViewer 0.3s cubic-bezier(0.4, 0, 0.2, 1) forwards;
}
/* --- END OF THE FIX --- */


.image-viewer-content img {
  max-width: 100%;
  max-height: 100%;
  object-fit: contain;
  border-radius: 8px;
  box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
}

.image-viewer-actions {
  position: absolute;
  top: 1rem;
  right: 1.5rem;
  display: flex;
  flex-direction: column;
  gap: 0.75rem;
  z-index: 3001;
}

.viewer-action-button {
  display: flex;
  align-items: center;
  gap: 0.75rem;
  background-color: hsla(0, 0%, 15%, 0.8);
  color: #e5e5e5;
  border: 1px solid hsla(0, 0%, 100%, 0.2);
  padding: 0.6rem 1.2rem;
  border-radius: 9999px;
  font-size: 0.9rem;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s ease;
  backdrop-filter: blur(5px);
}

.viewer-action-button:hover {
  background-color: hsla(0, 0%, 25%, 0.9);
  border-color: hsla(0, 0%, 100%, 0.3);
  transform: translateY(-2px);
}

/* --- Responsive Styles for Mobile --- */
@media (max-width: 768px) {
  .image-viewer-actions {
    top: auto;
    bottom: 1rem;
    left: 1rem;
    right: 1rem;
    flex-direction: row-reverse; /* Put Close on the right */
    justify-content: center;
  }
  .viewer-action-button {
    flex-grow: 1;
    justify-content: center;
  }
}
- - - InlineThinking.css:
/* src/css/InlineThinking.css */

.inline-thinking-container {
  margin: 8px 0;
  background-color: transparent !important; /* Ensure transparency override */
  background: none !important;
  border: none;
  overflow: hidden;
  width: 100%;
}

.thinking-header {
  display: flex;
  justify-content: flex-start;
  align-items: center;
  gap: 8px;
  padding: 4px 0;
  width: fit-content;
  cursor: pointer;
  user-select: none;
  background: none;
  border: none;
  transition: opacity 0.2s;
}

.thinking-header:hover {
  opacity: 0.8;
}

.thinking-status {
  display: flex;
  align-items: center;
}

/* Base text style */
.thinking-text-shimmer {
  font-size: 0.95rem;
  font-weight: 500;
  font-style: normal;
  color: var(--secondary-text-color); /* Static color when done */
}

/* Animation only applies when .animate class is present (during streaming) */
.thinking-text-shimmer.animate {
  color: var(--primary-text-color);
  background: linear-gradient(to right, var(--primary-text-color) 20%, var(--secondary-text-color) 50%, var(--primary-text-color) 80%);
  background-size: 200% auto;
  background-clip: text;
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  animation: shine 3s linear infinite;
}

@keyframes shine {
  to {
    background-position: 200% center;
  }
}

.chevron-icon {
  color: var(--secondary-text-color);
  transition: transform 0.3s ease;
  margin-left: 0;
}

.inline-thinking-container.expanded .chevron-icon {
  transform: rotate(180deg);
}

.thinking-content-details {
  max-height: 0;
  opacity: 0;
  overflow: hidden;
  
  margin-left: 4px;
  padding-left: 16px;
  
  /* The expanding line */
  border-left: 2px solid #ffffff; 
  
  color: var(--secondary-text-color);
  font-size: 0.9rem;
  line-height: 1.6;
  white-space: pre-wrap;
  word-wrap: break-word;
  background: transparent !important; /* Explicit transparency */
  
  transition: max-height 0.4s cubic-bezier(0.4, 0, 0.2, 1),
              opacity 0.3s ease,
              padding-top 0.3s ease,
              padding-bottom 0.3s ease;
}

[data-theme="light"] .thinking-content-details {
  border-left-color: #000000;
  color: #4b5563;
}

.inline-thinking-container.expanded .thinking-content-details {
  max-height: 2000px;
  opacity: 1;
  padding-top: 8px;
  padding-bottom: 12px;
}

.thinking-content-details p {
  margin: 0 0 8px 0;
}
.thinking-content-details p:last-child {
  margin-bottom: 0;
}

.streaming-cursor-small {
  display: inline-block;
  width: 4px;
  height: 4px;
  border-radius: 50%;
  background-color: var(--secondary-text-color);
  animation: blink-small 1s infinite;
  margin-left: 4px;
  vertical-align: middle;
}

@keyframes blink-small {
  0%, 100% { opacity: 0.3; }
  50% { opacity: 1; }
}
- - - LandingNav.css:
/* FexoApp/src/css/LandingNav.css */
.landing-nav {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  z-index: 1000;
  background-color: transparent;
  padding: 1rem 2rem;
  box-sizing: border-box;
  transition: background-color 0.3s ease, backdrop-filter 0.3s ease;
}

.landing-nav.scrolled {
  background-color: hsla(0, 0%, 100%, 0.7);
  backdrop-filter: blur(10px);
  border-bottom: 1px solid var(--border-color);
}

[data-theme="dark"] .landing-nav.scrolled {
  background-color: hsla(240, 4%, 13%, 0.7);
}

.landing-nav-container {
  max-width: 1200px;
  margin: 0 auto;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

/* --- START OF THE FIX --- */
.landing-nav-logo {
  display: flex;
  align-items: center;
  font-size: 1.5rem;
  font-weight: 700;
  color: var(--primary-text-color);
  text-decoration: none;
}

.landing-nav-logo img {
  height: 32px;
  transition: filter 0.3s ease-in-out;
}

.landing-nav-logo:hover img {
  filter: drop-shadow(0 0 8px hsla(145, 70%, 55%, 0.6));
}
/* --- END OF THE FIX --- */

.landing-nav-actions {
  display: flex;
  align-items: center;
  gap: 1rem;
}

.landing-nav-button {
  padding: 0.6rem 1.25rem;
  border-radius: 9999px;
  text-decoration: none;
  font-weight: 600;
  font-size: 0.9rem;
  transition: transform 0.2s ease, background-color 0.2s ease, color 0.2s ease;
  display: inline-block;
}

.landing-nav-button:hover {
  transform: translateY(-2px);
}

.landing-nav-button.login {
  background-color: transparent;
  color: var(--primary-text-color);
}

.landing-nav-button.login:hover {
  background-color: var(--button-hover-bg);
}

.landing-nav-button.register {
  background-color: #111827; /* Black background */
  color: #ffffff;
}

.landing-nav-button.register:hover {
  background-color: #374151;
}

[data-theme="dark"] .landing-nav-button.register {
  background-color: #ffffff;
  color: #111827;
}

[data-theme="dark"] .landing-nav-button.register:hover {
  background-color: #e5e7eb;
}

@media (max-width: 768px) {
  .landing-nav {
    padding: 1rem;
  }
  .landing-nav-logo img {
    height: 28px;
  }
  .landing-nav-button {
    padding: 0.5rem 1rem;
    font-size: 0.8rem;
  }
}
- - - LandingPage.css:
/* FexoApp/src/css/LandingPage.css */

.landing-page {
  background-color: var(--main-bg-color);
  color: var(--primary-text-color);
  overflow-x: hidden;
}

/* --- Section Observer Animations --- */
.hero-section,
.features-section,
.how-it-works-section,
.use-cases-section,
.cta-section,
.feature-card,
.timeline-item,
.use-case-card {
  opacity: 0;
  transform: translateY(40px);
  transition: opacity 0.8s cubic-bezier(0.215, 0.610, 0.355, 1), transform 0.8s cubic-bezier(0.215, 0.610, 0.355, 1);
}

.visible {
  opacity: 1;
  transform: translateY(0);
}

.feature-card:nth-child(1) { transition-delay: 0.1s; }
.feature-card:nth-child(2) { transition-delay: 0.2s; }
.feature-card:nth-child(3) { transition-delay: 0.3s; }
.feature-card:nth-child(4) { transition-delay: 0.4s; }

/* --- Hero Section --- */
.hero-section {
  min-height: 100vh;
  display: flex;
  align-items: center;
  justify-content: center;
  text-align: center;
  padding: 6rem 2rem;
  position: relative;
  overflow: hidden;
  box-sizing: border-box;
}

.hero-content {
  max-width: 800px;
  position: relative;
  z-index: 2;
}

.hero-title {
  font-size: 3.5rem;
  font-weight: 800;
  line-height: 1.1;
  letter-spacing: -0.03em;
  margin-bottom: 1.5rem;
  background: linear-gradient(120deg, var(--primary-text-color) 60%, var(--secondary-text-color) 100%);
  -webkit-background-clip: text;
  background-clip: text;
  -webkit-text-fill-color: transparent;
}

.hero-subtitle {
  font-size: 1.25rem;
  line-height: 1.6;
  color: var(--secondary-text-color);
  max-width: 650px;
  margin: 0 auto 2.5rem auto;
  min-height: 96px; /* Reserve space for typing text */
}

@keyframes blink-cursor {
  50% { opacity: 0; }
}

.typing-cursor {
  animation: blink-cursor 1s step-end infinite;
  font-weight: 500;
  color: var(--secondary-text-color);
}

@keyframes aurora-effect {
  from { background-position: 50% 50%, 50% 50%; }
  to { background-position: 350% 50%, 350% 50%; }
}

.hero-background-aurora {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  mix-blend-mode: normal;
  opacity: 0.6;
  z-index: 1;
  background:
    radial-gradient(ellipse 40% 50% at 20% 40%, hsla(145, 63%, 42%, 0.15), transparent),
    radial-gradient(ellipse 40% 50% at 80% 50%, hsla(210, 80%, 70%, 0.15), transparent);
  animation: aurora-effect 20s linear infinite;
}
[data-theme="dark"] .hero-background-aurora {
  mix-blend-mode: color-dodge;
  opacity: 0.3;
}

.cta-button {
  display: inline-flex;
  align-items: center;
  gap: 0.5rem;
  background-color: #111827;
  color: #ffffff;
  padding: 1rem 2.5rem;
  border-radius: 9999px;
  text-decoration: none;
  font-weight: 600;
  font-size: 1rem;
  transition: transform 0.2s ease, background-color 0.2s ease, box-shadow 0.2s ease;
  box-shadow: 0 4px 15px rgba(0,0,0,0.1), 0 0 0 4px var(--main-bg-color), 0 0 0 5px var(--border-color);
}
.cta-button:hover {
  transform: translateY(-3px) scale(1.02);
  background-color: #374151;
  box-shadow: 0 8px 25px rgba(0,0,0,0.15), 0 0 0 4px var(--main-bg-color), 0 0 0 5px var(--border-color);
}
[data-theme="dark"] .cta-button {
  background-color: #ffffff; color: #111827;
  box-shadow: 0 4px 15px rgba(0,0,0,0.2), 0 0 0 4px var(--main-bg-color), 0 0 0 5px var(--border-color);
}
[data-theme="dark"] .cta-button:hover { background-color: #e5e7eb; }

/* --- Shared Section Styles --- */
.section-title { font-size: 2.5rem; font-weight: 700; text-align: center; margin-bottom: 1rem; letter-spacing: -0.02em; }
.section-subtitle { font-size: 1.1rem; color: var(--secondary-text-color); text-align: center; max-width: 600px; margin: 0 auto 4rem auto; }

/* --- Features Section --- */
.features-section { padding: 6rem 2rem; background-color: var(--button-hover-bg); }
.features-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 2rem; max-width: 1200px; margin: 0 auto; }
.feature-card { background-color: var(--main-bg-color); padding: 2rem; border-radius: 16px; border: 1px solid var(--border-color); text-align: left; transition: transform 0.3s ease, box-shadow 0.3s ease; }
.feature-card:hover { transform: translateY(-8px); box-shadow: 0 10px 20px rgba(0,0,0,0.07); }
[data-theme="dark"] .feature-card:hover { box-shadow: 0 10px 20px rgba(0,0,0,0.2); }
.feature-icon { font-size: 2rem; color: #19c37d; margin-bottom: 1rem; }
.feature-title { font-size: 1.25rem; font-weight: 600; margin-bottom: 0.75rem; }
.feature-description { font-size: 0.95rem; line-height: 1.6; color: var(--secondary-text-color); }

/* --- How It Works Section (Timeline) --- */
.how-it-works-section { padding: 6rem 2rem; }
.timeline { position: relative; max-width: 800px; margin: 2rem auto 0; padding: 0; list-style: none; }
.timeline::before {
  content: ''; position: absolute; top: 0; bottom: 0; left: 24px; width: 3px;
  background: linear-gradient(to bottom, #19c37d, #3b82f6, #a855f7);
  border-radius: 3px;
}
.timeline-item { position: relative; padding-left: 70px; margin-bottom: 50px; }
.timeline-item:last-child { margin-bottom: 0; }
.timeline-icon {
  position: absolute; left: 0; top: 0; width: 50px; height: 50px; border-radius: 50%;
  background-color: var(--main-bg-color); border: 3px solid var(--button-hover-bg);
  font-size: 1.5rem; display: flex; align-items: center; justify-content: center;
  box-shadow: 0 0 0 4px var(--main-bg-color);
}
.timeline-title { font-size: 1.4rem; font-weight: 600; margin-bottom: 0.5rem; }
.timeline-description { color: var(--secondary-text-color); line-height: 1.6; }

/* --- Use Cases Section --- */
.use-cases-section { padding: 6rem 2rem; background-color: var(--button-hover-bg); }
.use-cases-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 2rem; max-width: 1200px; margin: 0 auto; }
@keyframes rotate-glow { to { transform: rotate(360deg); } }
.use-case-card {
  position: relative; background-color: var(--main-bg-color); padding: 2rem; border-radius: 16px; border: 1px solid var(--border-color);
  overflow: hidden; transition: transform 0.3s ease, box-shadow 0.3s ease;
}
.use-case-card:hover { transform: translateY(-8px); box-shadow: 0 10px 20px rgba(0,0,0,0.07); }
[data-theme="dark"] .use-case-card:hover { box-shadow: 0 10px 20px rgba(0,0,0,0.2); }
.use-case-glow {
  position: absolute; top: -50%; left: -50%; width: 200%; height: 200%; z-index: 0;
  background: conic-gradient(from 180deg at 50% 50%, transparent, var(--glow-color), transparent);
  animation: rotate-glow 5s linear infinite;
  opacity: 0; transition: opacity 0.4s ease;
}
.use-case-card:hover .use-case-glow { opacity: 0.15; }
.use-case-title, .use-case-description { position: relative; z-index: 1; }
.use-case-title { font-size: 1.5rem; font-weight: 600; margin-bottom: 1rem; }
.use-case-description { color: var(--secondary-text-color); line-height: 1.6; }

/* --- Final CTA & Footer --- */
.cta-section { padding: 6rem 2rem; text-align: center; }
.landing-footer { padding: 2rem; text-align: center; border-top: 1px solid var(--border-color); color: var(--secondary-text-color); font-size: 0.9rem; }

/* --- Responsive Design --- */
@media (max-width: 768px) {
  .hero-title { font-size: 2.5rem; }
  .hero-subtitle { font-size: 1.1rem; min-height: 120px; }
  .section-title { font-size: 2rem; }
  .features-section, .how-it-works-section, .use-cases-section, .cta-section { padding: 4rem 1.5rem; }
  .timeline::before { left: 50%; margin-left: -1.5px; }
  .timeline-item { padding-left: 0; text-align: center; }
  .timeline-icon { position: static; margin: 0 auto 1rem; }
}
- - - MobileHeader.css:
/* src/css/MobileHeader.css */
.mobile-header {
  display: none; /* Hidden by default, shown in media query */
  position: fixed;
  top: 0; /* Default position when no banner is present */
  left: 0;
  right: 0;
  height: 56px;
  background-color: var(--main-bg-color);
  border-bottom: 1px solid var(--border-color);
  padding: 0 1rem;
  align-items: center;
  justify-content: space-between;
  z-index: 500;
  transition: top 0.3s ease-in-out;
}

.mobile-header-button {
  background: none;
  border: none;
  color: var(--primary-text-color);
  padding: 8px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: background-color 0.2s;
  flex-shrink: 0;
}

.mobile-header-button:hover {
  background-color: var(--button-hover-bg);
}

@media (max-width: 768px) {
  .mobile-header {
    display: flex;
  }
}
- - - ModelSelector.css:
.model-selector {
  position: relative;
  display: inline-block;
  font-family: inherit;
}

.model-selector-placeholder {
  height: 38px;
  width: 150px; /* Approximate width */
}

.model-selector-button {
  background: none;
  border: none;
  color: var(--primary-text-color);
  font-size: 1.1rem;
  font-weight: 500;
  display: flex;
  align-items: center;
  gap: 0.5rem;
  padding: 0.5rem 0.75rem;
  border-radius: 8px;
  cursor: pointer;
  transition: background-color 0.2s ease;
}

.model-selector-button:hover {
  background-color: var(--button-hover-bg);
}

.beta-tag {
  position: relative;
  top: 2px;
  font-size: 0.8rem;
  font-weight: 600;
  line-height: 1;
  padding: 3px 9px;
  border-radius: 6px;
  color: var(--primary-text-color); /* Adapts to light/dark theme */
  border: 2px solid #834ab5; /* Bright purple outline */
  background: linear-gradient(111deg, #d2bfe8, #ad6cef);
  display: inline-flex;
  align-items: center;
}


.model-selector-button svg {
  color: var(--secondary-text-color);
  transition: transform 0.2s ease;
}

.model-selector-button svg.open {
  transform: rotate(180deg);
}

.model-selector-dropdown {
  position: absolute;
  top: calc(100% + 8px);
  left: 50%;
  transform: translateX(-50%);
  width: 320px;
  background-color: var(--main-bg-color);
  border: 1px solid var(--border-color);
  border-radius: 12px;
  box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2);
  padding: 0.5rem;
  z-index: 100;
  opacity: 0;
  animation: fadeInDropdown 0.2s ease forwards;
}

@keyframes fadeInDropdown {
  from {
    opacity: 0;
    transform: translateX(-50%) translateY(-10px);
  }
  to {
    opacity: 1;
    transform: translateX(-50%) translateY(0);
  }
}

.model-item {
  display: flex;
  align-items: center;
  padding: 0.75rem;
  border-radius: 8px;
  cursor: pointer;
  transition: background-color 0.2s ease;
  gap: 1rem;
}

.model-item:hover {
  background-color: var(--button-hover-bg);
}

.model-item-icon {
  color: var(--secondary-text-color);
  flex-shrink: 0;
}

.model-item.selected .model-item-icon {
  color: var(--primary-text-color);
}

.model-item-details {
  display: flex;
  flex-direction: column;
  flex-grow: 1;
}

.model-item-name {
  color: var(--primary-text-color);
  font-weight: 500;
}

.model-item-description {
  color: var(--secondary-text-color);
  font-size: 0.875rem;
}

.model-item-check {
  color: var(--primary-text-color);
  flex-shrink: 0;
}

.model-item-empty {
  padding: 1rem;
  text-align: center;
  color: var(--secondary-text-color);
  font-size: 0.9rem;
}
- - - NavigationPanel.css:
/* src/css/NavigationPanel.css */

.navigation-panel {
  position: relative;
  display: flex;
  flex-direction: column;
  gap: 0.75rem;
  padding: 1rem;
  background: var(--main-bg-color);
  border-radius: 12px;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
  border: 1px solid var(--border-color);
}

/* Off-route warning */
.off-route-warning {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  padding: 0.75rem;
  background: linear-gradient(135deg, #ff6b6b 0%, #ee5a52 100%);
  color: white;
  border-radius: 8px;
  font-size: 0.9rem;
  font-weight: 500;
  animation: pulse-warning 2s ease-in-out infinite;
}

@keyframes pulse-warning {
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.02); }
}

.off-route-warning svg {
  flex-shrink: 0;
  width: 20px;
  height: 20px;
}

.off-route-dismiss {
  margin-left: auto;
  background: rgba(255, 255, 255, 0.2);
  border: none;
  border-radius: 50%;
  width: 24px;
  height: 24px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: all 0.2s;
  color: white;
}

.off-route-dismiss:hover {
  background: rgba(255, 255, 255, 0.3);
  transform: scale(1.1);
}

/* Current instruction */
.nav-instruction-container {
  display: flex;
  gap: 1rem;
  align-items: flex-start;
  padding: 1rem;
  background: linear-gradient(135deg, #4285F4 0%, #3367D6 100%);
  border-radius: 12px;
  color: white;
  box-shadow: 0 4px 12px rgba(66, 133, 244, 0.3);
}

.nav-turn-icon {
  font-size: 3rem;
  line-height: 1;
  flex-shrink: 0;
  animation: bounce-icon 2s ease-in-out infinite;
}

@keyframes bounce-icon {
  0%, 100% { transform: translateY(0); }
  50% { transform: translateY(-5px); }
}

.nav-instruction-details {
  flex: 1;
  min-width: 0;
}

.nav-instruction-text {
  font-size: 1.1rem;
  font-weight: 600;
  line-height: 1.4;
  margin-bottom: 0.5rem;
  word-wrap: break-word;
}

@media (min-width: 768px) {
  .nav-instruction-text {
    font-size: 1.25rem;
  }
}

.nav-distance-to-turn {
  font-size: 1.5rem;
  font-weight: 700;
  opacity: 0.95;
  letter-spacing: 0.5px;
}

@media (min-width: 768px) {
  .nav-distance-to-turn {
    font-size: 1.75rem;
  }
}

/* Stats bar */
.nav-stats-bar {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 0.75rem;
}

@media (max-width: 480px) {
  .nav-stats-bar {
    grid-template-columns: 1fr;
    gap: 0.5rem;
  }
}

.nav-stat {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  padding: 0.75rem;
  background: var(--button-hover-bg);
  border: 1px solid var(--border-color);
  border-radius: 8px;
  transition: all 0.2s;
}

.nav-stat:hover {
  border-color: #4285F4;
  box-shadow: 0 2px 8px rgba(66, 133, 244, 0.1);
}

.nav-stat-icon {
  color: #4285F4;
  width: 20px;
  height: 20px;
  flex-shrink: 0;
}

.nav-stat-content {
  flex: 1;
  min-width: 0;
}

.nav-stat-label {
  font-size: 0.7rem;
  color: var(--secondary-text-color);
  text-transform: uppercase;
  letter-spacing: 0.5px;
  margin-bottom: 0.2rem;
}

.nav-stat-value {
  font-size: 1rem;
  font-weight: 600;
  color: var(--primary-text-color);
}

@media (min-width: 768px) {
  .nav-stat-value {
    font-size: 1.1rem;
  }
}

/* Stop button */
.nav-stop-button {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 0.75rem;
  padding: 1rem;
  background: linear-gradient(135deg, #EA4335 0%, #d93025 100%);
  color: white;
  border: none;
  border-radius: 12px;
  font-size: 1rem;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.3s;
  box-shadow: 0 4px 12px rgba(234, 67, 53, 0.3);
  position: relative;
  overflow: hidden;
}

.nav-stop-button::before {
  content: '';
  position: absolute;
  top: 50%;
  left: 50%;
  width: 0;
  height: 0;
  border-radius: 50%;
  background: rgba(255, 255, 255, 0.2);
  transform: translate(-50%, -50%);
  transition: width 0.6s, height 0.6s;
}

.nav-stop-button:hover::before {
  width: 300px;
  height: 300px;
}

.nav-stop-button:hover {
  transform: translateY(-2px);
  box-shadow: 0 6px 16px rgba(234, 67, 53, 0.4);
}

.nav-stop-button:active {
  transform: translateY(0);
}

.nav-stop-icon {
  position: relative;
  width: 28px;
  height: 28px;
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1;
}

.nav-stop-square {
  width: 16px;
  height: 16px;
  background: white;
  border-radius: 3px;
  animation: pulse-stop 1.5s ease-in-out infinite;
}

@keyframes pulse-stop {
  0%, 100% { transform: scale(1); opacity: 1; }
  50% { transform: scale(0.9); opacity: 0.8; }
}

.nav-stop-button span {
  position: relative;
  z-index: 1;
}

/* Progress indicator */
.nav-progress-container {
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
}

.nav-progress-info {
  display: flex;
  justify-content: space-between;
  align-items: center;
  font-size: 0.8rem;
  color: var(--secondary-text-color);
  font-weight: 500;
}

.nav-progress-bar {
  height: 6px;
  background: var(--button-hover-bg);
  border-radius: 3px;
  overflow: hidden;
  border: 1px solid var(--border-color);
}

.nav-progress-fill {
  height: 100%;
  background: linear-gradient(90deg, #4285F4 0%, #34A853 100%);
  border-radius: 3px;
  transition: width 0.5s ease-out;
  position: relative;
}

.nav-progress-fill::after {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  bottom: 0;
  right: 0;
  background: linear-gradient(
    90deg,
    transparent,
    rgba(255, 255, 255, 0.3),
    transparent
  );
  animation: shimmer 2s infinite;
}

@keyframes shimmer {
  0% { transform: translateX(-100%); }
  100% { transform: translateX(100%); }
}

/* Error display */
.nav-error {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  padding: 0.75rem;
  background: rgba(234, 67, 53, 0.1);
  border: 1px solid rgba(234, 67, 53, 0.3);
  border-radius: 8px;
  color: #EA4335;
  font-size: 0.9rem;
}

.nav-error svg {
  width: 18px;
  height: 18px;
  flex-shrink: 0;
}

/* Dark theme adjustments */
[data-theme="dark"] .nav-stop-button {
  box-shadow: 0 4px 12px rgba(234, 67, 53, 0.4);
}

[data-theme="dark"] .nav-instruction-container {
  box-shadow: 0 4px 12px rgba(66, 133, 244, 0.4);
}

/* Touch device optimizations */
@media (hover: none) and (pointer: coarse) {
  .nav-stop-button {
    min-height: 52px;
  }
  
  .off-route-dismiss {
    min-width: 32px;
    min-height: 32px;
  }
}

/* Reduced motion */
@media (prefers-reduced-motion: reduce) {
  .nav-turn-icon,
  .nav-stop-square,
  .off-route-warning {
    animation: none;
  }
  
  .nav-progress-fill::after {
    animation: none;
  }
}
- - - Notification.css:
/* src/css/Notification.css */
.notification-popup {
  position: fixed;
  top: 20px;
  left: 50%;
  transform: translate(-50%, -150%); /* Start above the screen */
  background-color: #424242;
  color: #ECECEC;
  padding: 0.75rem 1.5rem;
  border-radius: 9999px; /* Pill shape */
  font-weight: 500;
  z-index: 2000; /* Above modals */
  opacity: 0;
  transition: transform 0.4s cubic-bezier(0.25, 1, 0.5, 1), opacity 0.4s ease;
  pointer-events: none; /* Don't block clicks */
  border: 1px solid var(--border-color);
}

.notification-popup.visible {
  opacity: 1;
  transform: translate(-50%, 0); /* Slide down into view */
}

.notification-popup.error {
    background-color: hsla(0, 84%, 60%, 0.2);
    color: #f87171;
    border: 1px solid hsla(0, 84%, 60%, 0.5);
}

/* --- LIGHT THEME STYLES --- */
[data-theme="light"] .notification-popup {
  background-color: var(--sidebar-bg-color);
  color: var(--primary-text-color);
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
}

[data-theme="light"] .notification-popup.error {
    background-color: #fef2f2; /* Light red */
    color: #991b1b; /* Dark red text */
    border-color: #fecaca; /* Red border */
}
- - - NotificationsModal.css:
/* FexoApp/src/css/NotificationsModal.css */

.notifications-modal-overlay {
  position: fixed;
  inset: 0;
  background-color: rgba(0, 0, 0, 0.5);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1200; /* Above sidebar */
  opacity: 0;
  animation: fadeIn 0.2s ease-out forwards;
  backdrop-filter: blur(2px);
}

.notifications-modal-content {
  width: 90%;
  max-width: 800px;
  height: 80vh;
  background-color: var(--sidebar-bg-color);
  border: 1px solid var(--border-color);
  border-radius: 16px;
  box-shadow: 0 10px 25px rgba(0,0,0,0.2);
  display: flex;
  overflow: hidden;
  transform: scale(0.95);
  opacity: 0;
  animation: scaleIn 0.2s 0.05s ease-out forwards;
}

/* Sidebar inside modal */
.notif-sidebar {
  width: 200px;
  background-color: var(--main-bg-color);
  border-right: 1px solid var(--border-color);
  display: flex;
  flex-direction: column;
  padding: 1rem;
  flex-shrink: 0;
}

.notif-header {
  margin-bottom: 1.5rem;
  padding-bottom: 1rem;
  border-bottom: 1px solid var(--border-color);
}

.notif-header h2 {
  margin: 0;
  font-size: 1.1rem;
  font-weight: 600;
  color: var(--primary-text-color);
  display: flex;
  align-items: center;
  gap: 8px;
}

.notif-tabs {
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
}

.notif-tab-btn {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 10px 12px;
  border-radius: 8px;
  color: var(--secondary-text-color);
  font-size: 0.9rem;
  font-weight: 500;
  transition: all 0.2s;
  text-align: left;
}

.notif-tab-btn:hover {
  background-color: var(--button-hover-bg);
  color: var(--primary-text-color);
}

.notif-tab-btn.active {
  background-color: var(--button-hover-bg);
  color: #19c37d; /* Green accent */
  font-weight: 600;
}

.notif-count-badge {
  margin-left: auto;
  background-color: var(--border-color);
  color: var(--primary-text-color);
  font-size: 0.75rem;
  padding: 2px 6px;
  border-radius: 10px;
}

.notif-tab-btn.active .notif-count-badge {
  background-color: #19c37d;
  color: white;
}

/* Main Content Area */
.notif-main {
  flex: 1;
  display: flex;
  flex-direction: column;
  background-color: var(--sidebar-bg-color);
  position: relative;
}

.notif-main-header {
  padding: 1rem 1.5rem;
  border-bottom: 1px solid var(--border-color);
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.notif-main-header h3 {
  margin: 0;
  font-size: 1.1rem;
  color: var(--primary-text-color);
}

.close-modal-btn {
  color: var(--secondary-text-color);
  padding: 6px;
  border-radius: 50%;
  transition: background-color 0.2s;
}

.close-modal-btn:hover {
  background-color: var(--button-hover-bg);
  color: var(--primary-text-color);
}

.notif-list {
  flex: 1;
  overflow-y: auto;
  padding: 1.5rem;
  display: flex;
  flex-direction: column;
  gap: 1rem;
}

/* Empty State */
.notif-empty {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100%;
  color: var(--secondary-text-color);
  gap: 1rem;
}

.notif-empty svg {
  width: 48px;
  height: 48px;
  opacity: 0.5;
}

/* Task Card */
.task-card {
  background-color: var(--main-bg-color);
  border: 1px solid var(--border-color);
  border-radius: 12px;
  padding: 1rem;
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  gap: 1rem;
  transition: transform 0.2s, border-color 0.2s;
}

.task-card:hover {
  border-color: var(--secondary-text-color);
  transform: translateY(-1px);
}

.task-info h4 {
  margin: 0 0 0.25rem 0;
  color: var(--primary-text-color);
  font-size: 1rem;
}

.task-desc {
  margin: 0 0 0.75rem 0;
  color: var(--secondary-text-color);
  font-size: 0.9rem;
  line-height: 1.4;
}

.task-meta {
  display: flex;
  align-items: center;
  gap: 1rem;
  font-size: 0.8rem;
  color: var(--secondary-text-color);
}

.task-time {
  display: flex;
  align-items: center;
  gap: 4px;
  background-color: var(--button-hover-bg);
  padding: 2px 8px;
  border-radius: 4px;
}

.task-actions {
  display: flex;
  gap: 0.5rem;
}

.task-action-btn {
  padding: 6px;
  border-radius: 6px;
  color: var(--secondary-text-color);
  transition: all 0.2s;
}

.task-action-btn:hover {
  background-color: var(--button-hover-bg);
  color: var(--primary-text-color);
}

.task-action-btn.delete:hover {
  color: #ef4444;
  background-color: rgba(239, 68, 68, 0.1);
}

.status-completed {
  color: #10b981; /* Green text */
  font-weight: 500;
}

@media (max-width: 768px) {
  .notifications-modal-content {
    flex-direction: column;
    height: 90vh;
  }
  .notif-sidebar {
    width: 100%;
    flex-direction: row;
    align-items: center;
    padding: 0.75rem;
    overflow-x: auto;
    border-right: none;
    border-bottom: 1px solid var(--border-color);
  }
  .notif-header {
    margin: 0;
    padding: 0;
    border: none;
    margin-right: 1rem;
  }
  .notif-header h2 span { display: none; } /* Hide text on mobile */
  .notif-tabs {
    flex-direction: row;
    flex: 1;
  }
}
- - - PricingPage.css:
/* src/css/PricingPage.css */
.pricing-page-container {
  width: 100%;
  height: 100%;
  padding: 2rem;
  box-sizing: border-box;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  background-color: var(--main-bg-color);
  color: var(--primary-text-color);
  animation: fadeInPage 0.5s ease-out;
  overflow-y: auto;
}

@keyframes fadeInPage {
  from { opacity: 0; transform: translateY(10px); }
  to { opacity: 1; transform: translateY(0); }
}

.pricing-header {
  text-align: center;
  margin-bottom: 3rem;
}
.pricing-header h1 {
  font-size: 2.5rem;
  font-weight: 700;
  margin-bottom: 0.5rem;
}
.pricing-header p {
  font-size: 1.1rem;
  color: var(--secondary-text-color);
  max-width: 500px;
}

.pricing-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
  gap: 2rem;
  width: 100%;
  max-width: 700px;
}

.pricing-card {
  background-color: var(--sidebar-bg-color);
  border: 1px solid var(--border-color);
  border-radius: 16px;
  padding: 2rem;
  display: flex;
  flex-direction: column;
  transition: transform 0.2s ease, box-shadow 0.2s ease;
}

.pricing-card.pro {
  border-color: #834ab5;
  box-shadow: 0 0 20px hsla(268, 48%, 53%, 0.3);
}

.pricing-card h3 {
  font-size: 1.5rem;
  font-weight: 600;
  margin: 0 0 1rem 0;
}

.price {
  font-size: 2.5rem;
  font-weight: 700;
  margin-bottom: 1.5rem;
}
.price span {
  font-size: 1rem;
  font-weight: 500;
  color: var(--secondary-text-color);
  margin-left: 0.5rem;
}

.features-list {
  list-style: none;
  padding: 0;
  margin: 0 0 2rem 0;
  flex-grow: 1;
}
.features-list li {
  display: flex;
  align-items: center;
  gap: 0.75rem;
  margin-bottom: 0.75rem;
  font-size: 0.95rem;
}
.features-list svg {
  color: #19c37d;
  flex-shrink: 0;
}

.subscribe-button {
  width: 100%;
  padding: 0.75rem;
  border-radius: 8px;
  font-weight: 600;
  font-size: 1rem;
  cursor: pointer;
  transition: all 0.2s ease;
}

.pricing-card.free .subscribe-button {
  background-color: var(--button-hover-bg);
  color: var(--secondary-text-color);
  cursor: default;
}

.pricing-card.pro .subscribe-button {
  background-color: #834ab5;
  color: white;
}
.pricing-card.pro .subscribe-button:hover:not(:disabled) {
  background-color: #6d3a9c;
  transform: translateY(-2px);
}
.subscribe-button:disabled {
  opacity: 0.6;
  cursor: not-allowed;
}

.pricing-card.current .subscribe-button {
    background-color: transparent;
    border: 1px solid #19c37d;
    color: #19c37d;
}
- - - ProviderSelector.css:
/* src/css/ProviderSelector.css */
.provider-selector {
  position: relative;
  width: 100%;
}

.provider-selector-button {
  width: 100%;
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 0.75rem 1rem;
  background-color: var(--main-bg-color);
  border: 1px solid var(--border-color);
  border-radius: 8px;
  color: var(--primary-text-color);
  font-size: 1rem;
  cursor: pointer;
  text-align: left;
  transition: border-color 0.2s, box-shadow 0.2s;
}

.provider-selector-button:hover,
.provider-selector-button:focus-visible {
  outline: none;
  border-color: #19c37d;
  box-shadow: 0 0 0 2px hsla(145, 63%, 42%, 0.3);
}

.provider-info {
  display: flex;
  align-items: center;
  gap: 0.75rem;
  font-weight: 500;
}

.provider-icon {
  width: 20px;
  height: 20px;
  color: var(--primary-text-color); /* Icon color matches the theme */
}

.chevron-icon {
  color: var(--secondary-text-color);
  transition: transform 0.2s ease-in-out;
}

.chevron-icon.open {
  transform: rotate(180deg);
}

.provider-selector-dropdown {
  position: absolute;
  top: calc(100% + 4px);
  left: 0;
  right: 0;
  background-color: var(--sidebar-bg-color);
  border: 1px solid var(--border-color);
  border-radius: 8px;
  padding: 0.5rem;
  z-index: 1010;
  box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2);
  opacity: 0;
  transform: translateY(-10px);
  animation: dropdown-fade-in 0.2s ease forwards;
}

@keyframes dropdown-fade-in {
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.provider-item {
  display: flex;
  align-items: center;
  gap: 0.75rem;
  padding: 0.75rem;
  border-radius: 6px;
  cursor: pointer;
  transition: background-color 0.2s;
  font-weight: 500;
}

.provider-item:hover {
  background-color: var(--button-hover-bg);
}

.provider-item.selected {
  background-color: var(--button-hover-bg);
  font-weight: 600;
}
- - - RenameModal.css:
/* src/css/RenameModal.css */
.rename-modal-overlay {
  position: fixed;
  inset: 0;
  background-color: hsla(0, 0%, 0%, 0.6);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 2000;
  opacity: 0;
  animation: fadeIn 0.2s ease-out forwards;
}

.rename-modal-content {
  background-color: var(--sidebar-bg-color);
  padding: 1.5rem 2rem;
  border-radius: 12px;
  width: 90%;
  max-width: 400px;
  border: 1px solid var(--border-color);
  color: var(--primary-text-color);
  box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.3);
  transform: scale(0.95);
  opacity: 0;
  animation: scaleIn 0.2s 0.05s ease-out forwards;
}

.rename-modal-header {
  display: flex;
  align-items: center;
  gap: 0.75rem;
  padding-bottom: 0.75rem;
  border-bottom: 2px solid var(--border-color);
  margin-bottom: 1rem;
}

.rename-modal-icon {
  color: var(--secondary-text-color);
  flex-shrink: 0;
}

.rename-modal-content h3 {
  margin: 0;
  font-size: 1.125rem;
  font-weight: 600;
  text-align: left;
}

.rename-modal-content input {
  width: 100%;
  padding: 0.75rem 1rem;
  border-radius: 8px;
  border: 1px solid var(--border-color);
  background-color: var(--main-bg-color);
  color: var(--primary-text-color);
  font-size: 1rem;
  box-sizing: border-box;
  transition: border-color 0.2s, box-shadow 0.2s;
  margin-bottom: 1.5rem;
}

.rename-modal-content input:focus {
  outline: none;
  border-color: #19c37d;
  box-shadow: 0 0 0 2px hsla(145, 63%, 42%, 0.3);
}

.rename-modal-actions {
  display: flex;
  justify-content: flex-end;
  gap: 0.5rem;
}

.rename-modal-button {
  border: none;
  padding: 0.5rem 1rem;
  border-radius: 9999px;
  font-weight: 500;
  cursor: pointer;
  transition: background-color 0.2s ease-in-out;
  font-size: 0.875rem;
  min-width: 80px;
}

.rename-modal-button.cancel {
  background-color: var(--main-bg-color);
  color: #ECECEC;
  border: 1px solid var(--border-color);
}
.rename-modal-button.cancel:hover {
  background-color: var(--button-hover-bg);
}

.rename-modal-button.save {
  background-color: #ffffff;
  color: #000000;
}
.rename-modal-button.save:hover {
  background-color: #f0f0f0;
}

/* --- LIGHT THEME STYLES --- */
[data-theme="light"] .rename-modal-content {
  box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.1);
}

[data-theme="light"] .rename-modal-content input:focus {
  box-shadow: 0 0 0 2px hsla(145, 63%, 42%, 0.4);
}

[data-theme="light"] .rename-modal-button.save {
  background-color: var(--primary-text-color);
  color: var(--main-bg-color);
}

[data-theme="light"] .rename-modal-button.save:hover {
  background-color: #374151; /* Dark gray */
}
- - - SearchBlock.css:
/* src/css/SearchBlock.css */

/* The line that appears during/after search */
.search-indicator {
  display: flex;
  align-items: center;
  gap: 8px;
  background-color: transparent;
  color: var(--secondary-text-color);
  font-size: 0.95rem;
  margin-bottom: 8px;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
}

/* Search Icon (Static, no spinner) */
.search-icon-wrapper {
  display: flex;
  align-items: center;
  justify-content: center;
  color: var(--primary-text-color);
}

/* The text "Searching for..." or "Searched..." */
.search-text {
  color: var(--secondary-text-color);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  max-width: 100%;
}

/* The sources section at the bottom of the message */
.message-sources-section {
  display: flex;
  align-items: center;
  /* No border-top, just inline with actions */
  margin-top: 0; 
  padding-top: 0;
}

/* Sources button style - circular favicons row */
.sources-trigger {
  display: flex;
  align-items: center;
  gap: -8px; /* Overlap slightly */
  background: none;
  border: none;
  cursor: pointer;
  padding: 6px;
  border-radius: 20px;
  transition: background-color 0.2s;
  margin-right: 4px;
}

.sources-trigger:hover {
  background-color: var(--button-hover-bg);
}

.source-favicon-stack {
  width: 16px;
  height: 16px;
  border-radius: 50%;
  border: 2px solid var(--main-bg-color);
  background-color: var(--button-hover-bg);
  object-fit: cover;
  /* Negative margin for stacking effect */
  margin-left: -8px; 
}

.source-favicon-stack:first-child {
  margin-left: 0;
}

.sources-count {
  font-size: 0.8rem;
  color: var(--secondary-text-color);
  margin-left: 8px;
  font-weight: 750;
}
- - - SettingsModal.css:
/* Fexo/src/css/SettingsModal.css */

/* --- OVERLAY & MODAL CONTAINER --- */
.modal-overlay {
  position: fixed;
  inset: 0;
  background-color: hsla(0, 0%, 0%, 0.5); /* Semi-transparent black */
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
  opacity: 0;
  animation: fadeIn 0.3s cubic-bezier(0.4, 0, 0.2, 1) forwards;
}

.modal-content {
  background-color: var(--sidebar-bg-color);
  border-radius: 16px;
  width: 90%;
  max-width: 720px; /* Increased width for two columns */
  min-height: 480px;
  max-height: 90vh; /* Prevent modal from being too tall on mobile */
  border: 1px solid var(--border-color);
  color: var(--primary-text-color);
  box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.3), 0 8px 10px -6px rgba(0, 0, 0, 0.3);
  transform: scale(0.95);
  opacity: 0;
  animation: scaleIn 0.3s 0.1s cubic-bezier(0.4, 0, 0.2, 1) forwards;
  display: flex; /* <-- Flex layout */
  overflow: hidden; /* <-- Hide overflowing content */
}

/* --- ANIMATIONS --- */
@keyframes fadeIn { to { opacity: 1; } }
@keyframes fadeOut { from { opacity: 1; } to { opacity: 0; } }

@keyframes scaleIn {
  to {
    transform: scale(1);
    opacity: 1;
  }
}
@keyframes scaleOut {
  from { transform: scale(1); opacity: 1; }
  to { transform: scale(0.95); opacity: 0; }
}

/* Closing animation states */
.modal-overlay.closing { animation: fadeOut 0.3s cubic-bezier(0.4, 0, 0.2, 1) forwards; }
.modal-content.closing { animation: scaleOut 0.3s cubic-bezier(0.4, 0, 0.2, 1) forwards; }

/* --- SETTINGS LAYOUT --- */
.settings-sidebar {
  width: 200px;
  flex-shrink: 0;
  background-color: var(--main-bg-color); /* Slightly different bg */
  padding: 1rem;
  border-right: 1px solid var(--border-color);
  display: flex;
  flex-direction: column;
}

.settings-sidebar h2 {
  font-size: 1.1rem;
  padding: 0 0.5rem 1rem 0.5rem;
  margin: 0 0 1rem 0;
  border-bottom: 1px solid var(--border-color);
}

.settings-tab-button {
  display: flex;
  align-items: center;
  gap: 0.75rem;
  width: 100%;
  padding: 0.6rem 0.75rem;
  border: none;
  background: none;
  border-radius: 8px;
  color: var(--secondary-text-color);
  font-size: 0.9rem;
  font-weight: 500;
  text-align: left;
  cursor: pointer;
  transition: all 0.2s;
}

.input-wrapper {
  position: relative;
  display: flex;
  align-items: center;
}

.input-wrapper input {
  /* Add padding to the right to prevent text from overlapping the button */
  padding-right: 40px !important;
}

.visibility-toggle-btn {
  position: absolute;
  right: 12px;
  top: 50%;
  transform: translateY(-50%);
  background: none;
  border: none;
  color: var(--secondary-text-color);
  cursor: pointer;
  padding: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: color 0.2s ease;
}

.visibility-toggle-btn:hover {
  color: var(--primary-text-color);
}

.settings-tab-button:hover {
  background-color: var(--button-hover-bg);
  color: var(--primary-text-color);
}

.settings-tab-button.active {
  background-color: var(--button-hover-bg);
  color: var(--primary-text-color);
  font-weight: 600;
}

.settings-tab-button.active svg {
  color: var(--primary-text-color);
}

.settings-content {
  flex-grow: 1;
  padding: 2rem;
  overflow-y: auto;
  overflow-x: hidden; /* avoid horizontal scroll within modal */
  box-sizing: border-box;
}

.settings-content h3 {
  margin: 0 0 0.5rem 0;
  font-size: 1.25rem;
  font-weight: 600;
}
.settings-content p {
  color: var(--secondary-text-color);
  font-size: 0.9rem;
  margin: 0 0 2rem 0;
}

.form-group .description {
  font-size: 0.9rem;
  color: var(--secondary-text-color);
  margin-bottom: 0.75rem;
  line-height: 1.3; /* Add consistent line-height */
}

/* --- Model Search Input Styles --- */
.model-search-wrapper {
  position: relative;
  margin-bottom: 0.75rem;
}

.model-search-input {
  width: 100%;
  /* Padding for clear button on the right, standard padding on left */
  padding: 0.75rem 2.75rem 0.75rem 1rem;
  border-radius: 8px;
  border: 1px solid var(--border-color);
  background-color: var(--main-bg-color);
  color: var(--primary-text-color);
  font-size: 0.9rem;
  box-sizing: border-box;
  transition: border-color 0.2s, box-shadow 0.2s;
}

.model-search-input:focus {
  outline: none;
  border-color: #19c37d;
  box-shadow: 0 0 0 2px hsla(145, 63%, 42%, 0.3);
}

.model-search-clear-btn {
  position: absolute;
  top: 50%;
  right: 12px;
  transform: translateY(-50%) scale(0.8); /* Initial state: scaled down */
  background: none;
  border: none;
  color: var(--secondary-text-color);
  cursor: pointer;
  padding: 4px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  opacity: 0; /* Initial state: invisible */
  pointer-events: none; /* Initial state: not clickable */
  transition: opacity 0.15s ease, transform 0.15s ease;
}

.model-search-clear-btn.visible {
  opacity: 1; /* Visible state */
  transform: translateY(-50%) scale(1); /* Visible state: normal size */
  pointer-events: auto; /* Visible state: clickable */
}

.model-search-clear-btn:hover {
  background-color: var(--button-hover-bg);
  color: var(--primary-text-color);
}

.no-models-found {
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100%;
  min-height: 60px;
  color: var(--secondary-text-color);
  font-style: italic;
  font-size: 0.9rem;
  user-select: none;
}


/* --- QUICK ACCESS LIST & CUSTOM CHECKBOX --- */
.quick-access-list {
  display: flex;
  flex-direction: column;
  gap: 0.25rem; /* Reduced gap between items */
  max-height: 150px;
  overflow-y: auto;
  overflow-x: hidden; /* Hide horizontal scrollbar */
  background-color: var(--input-bg-color);
  padding: 0.5rem;
  border-radius: 8px;
  border: 1px solid var(--border-color);
  width: 100%;
}

.quick-access-row {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 0.5rem;
  border-radius: 4px;
  transition: background-color 0.2s ease;
}

.quick-access-row:hover {
  background-color: var(--button-hover-bg);
}

.quick-access-item {
  display: flex;
  align-items: center; /* Vertically center checkbox and text */
  gap: 0.75rem; /* Increased space between checkbox and text */
  padding: 0.25rem 0.5rem;
  cursor: pointer;
  user-select: none;
  background: none;
  width: 100%;
  min-width: 0;
  flex-grow: 1;
}

.quick-access-item input[type="checkbox"] {
  position: absolute;
  opacity: 0;
  width: 0;
  height: 0;
  cursor: pointer;
}

.checkbox-visual {
  flex-shrink: 0;
  width: 18px;
  height: 18px;
  border: 2px solid #b0b4c3;
  border-radius: 4px;
  background-color: transparent;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s ease;
  position: relative;
}

.quick-access-item input[type="checkbox"]:checked + .checkbox-visual {
  background-color: #374151; 
  border-color: #374151;
}

.checkbox-visual::after {
  content: '';
  display: none;
  width: 5px;
  height: 10px;
  border: solid white;
  border-width: 0 2px 2px 0;
  transform: rotate(45deg);
}

.quick-access-item input[type="checkbox"]:checked + .checkbox-visual::after {
  display: block;
}

.model-name-text {
  color: var(--primary-text-color);
  white-space: nowrap;
  text-overflow: ellipsis;
  overflow: hidden;
  flex: 1;
  min-width: 0;
  font-size: 0.9rem;
  line-height: 1.3;
}

/* --- Model Config Button and Menu --- */
.model-config-wrapper {
  position: relative;
  flex-shrink: 0;
}

.model-config-button {
  display: flex;
  align-items: center;
  justify-content: center;
  background: none;
  border: none;
  color: var(--secondary-text-color);
  padding: 4px;
  border-radius: 4px;
  cursor: pointer;
  transition: color 0.2s;
}

.quick-access-row:hover .model-config-button {
  color: var(--primary-text-color);
}
.model-config-button:disabled {
  opacity: 0.3;
  cursor: not-allowed;
}

.model-config-menu {
  position: absolute;
  top: calc(100% + 4px);
  right: 0;
  z-index: 1050;
  background-color: var(--main-bg-color);
  border-radius: 8px;
  border: 1px solid var(--border-color);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
  padding: 6px;
  display: flex;
  flex-direction: column;
  gap: 4px;
  width: 120px;
}

.config-menu-item {
  display: flex;
  align-items: center;
  gap: 0.75rem;
  padding: 6px 8px;
  border-radius: 4px;
  cursor: pointer;
  font-size: 0.9rem;
}
.config-menu-item:hover {
  background-color: var(--button-hover-bg);
}
.config-menu-item input[type="checkbox"] {
  position: absolute; opacity: 0;
}
.config-menu-item input[type="checkbox"]:checked + .checkbox-visual {
  background-color: #374151; border-color: #374151;
}
.config-menu-item input[type="checkbox"]:checked + .checkbox-visual::after {
  display: block;
}

/* --- FORM ELEMENTS --- */
.form-group { margin-bottom: 1.25rem; }
.form-group label { margin-bottom: 0.5rem; font-weight: 500; font-size: 0.875rem; color: var(--primary-text-color); display: flex; }
.form-group input, .form-group select { width: 100%; padding: 0.75rem 1rem; border-radius: 8px; border: 1px solid var(--border-color); background-color: var(--main-bg-color); color: var(--primary-text-color); font-size: 1rem; box-sizing: border-box; transition: border-color 0.2s, box-shadow 0.2s; }
.form-group input:focus, .form-group select:focus { outline: none; border-color: #19c37d; box-shadow: 0 0 0 2px hsla(145, 63%, 42%, 0.3); }

/* Style for hidden API key input */
.form-group .input-wrapper input.input-hidden {
  -webkit-text-security: disc;
  letter-spacing: 3px;
}

/* Ensure placeholder text is not affected */
.form-group .input-wrapper input.input-hidden::placeholder {
  -webkit-text-security: none;
  letter-spacing: normal;
}


/* --- MODEL SELECTION ROW --- */
.model-select-wrapper { display: flex; align-items: center; gap: 0.75rem; }
.model-select-wrapper select { flex-grow: 1; }
.refresh-button { flex-shrink: 0; display: flex; align-items: center; justify-content: center; width: 48px; height: 48px; background-color: var(--main-bg-color); border: 1px solid var(--border-color); color: var(--primary-text-color); border-radius: 8px; cursor: pointer; transition: all 0.2s; }
.refresh-button:hover:not(:disabled) { background-color: var(--button-hover-bg); border-color: #19c37d; }
.refresh-button:disabled { opacity: 0.5; cursor: not-allowed; }
.refresh-button[disabled]:hover { border-color: var(--border-color); }

/* --- ERROR TEXT --- */
.error-text { color: #f87171; font-size: 0.8rem; margin-top: 0.5rem; padding-left: 0.25rem; }

/* --- ACTION BUTTONS --- */
.modal-actions { margin-top: 2rem; display: flex; justify-content: flex-end; gap: 0.75rem; flex-wrap: wrap; }
.modal-button { border: none; padding: 0.5rem 1rem; border-radius: 0.75rem; font-weight: 500; cursor: pointer; transition: all 0.2s ease-in-out; font-size: 0.9rem; }
.modal-button:hover:not(:disabled) { transform: scale(1.05); }
.modal-button-cancel { background-color: var(--main-bg-color); color: var(--primary-text-color); border: 1px solid var(--border-color); }
.modal-button-cancel:hover { background-color: var(--button-hover-bg); }
.modal-button-save { background-color: #ffffff; color: #000000; }
.modal-button-save:hover { background-color: #f0f0f0; }

/* --- APPEARANCE TAB STYLES --- */
.theme-options { display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; }
.theme-card { border: 2px solid var(--border-color); border-radius: 12px; padding: 1rem; cursor: pointer; transition: all 0.2s ease-in-out; }
.theme-card:hover { border-color: #19c37d; transform: translateY(-2px); }
.theme-card.selected { border-color: #19c37d; box-shadow: 0 0 0 2px hsla(145, 63%, 42%, 0.3); }
.theme-preview { height: 80px; border-radius: 8px; margin-bottom: 1rem; display: flex; align-items: center; justify-content: center; font-weight: 600; }
.theme-card[data-theme-name="light"] .theme-preview { background-color: #ffffff; border: 1px solid #e5e7eb; color: #111827; }
.theme-card[data-theme-name="dark"] .theme-preview { background-color: #212121; border: 1px solid hsl(0, 0%, 22%); color: #e5e5e5; }
.theme-card span { font-weight: 500; color: var(--primary-text-color); }

/* --- Context Length Slider & Input Styles --- */
.label-with-value {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 0.25rem;
}

.context-value-span {
  font-family: var(--font-mono, monospace);
  font-size: 0.9rem;
  font-weight: 600;
  color: var(--primary-text-color);
  background-color: var(--button-hover-bg);
  padding: 2px 8px;
  border-radius: 6px;
  cursor: text;
  min-width: 50px;
  text-align: center;
  transition: background-color 0.2s;
}

.context-value-span:hover {
  background-color: var(--border-color);
}

.context-value-input {
  font-family: var(--font-mono, monospace);
  font-size: 0.9rem;
  font-weight: 600;
  color: var(--primary-text-color);
  background-color: var(--main-bg-color);
  border: 1px solid #19c37d;
  box-shadow: 0 0 0 2px hsla(145, 63%, 42%, 0.3);
  border-radius: 6px;
  padding: 1px 7px;
  width: 80px;
  text-align: center;
  outline: none;
}

/* Hide the default number input spinners */
.context-value-input::-webkit-outer-spin-button,
.context-value-input::-webkit-inner-spin-button {
  -webkit-appearance: none;
  margin: 0;
}
.context-value-input[type=number] {
  appearance: textfield; /* Firefox */
}

.context-slider-group {
  padding-top: 8px;
}

.context-slider {
  -webkit-appearance: none;
  appearance: none;
  width: 100%;
  height: 6px;
  background: var(--border-color);
  outline: none;
  border-radius: 3px;
  opacity: 0.9;
  transition: opacity .2s;
}

.context-slider:hover {
  opacity: 1;
}

.context-slider::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 20px;
  height: 20px;
  background: #ffffff;
  cursor: pointer;
  border-radius: 50%;
  border: 2px solid var(--primary-text-color);
  transition: background-color 0.2s, border-color 0.2s;
}

.context-slider::-moz-range-thumb {
  width: 20px;
  height: 20px;
  background: #ffffff;
  cursor: pointer;
  border-radius: 50%;
  border: 2px solid var(--primary-text-color);
  transition: background-color 0.2s, border-color 0.2s;
}

[data-theme="light"] .context-slider::-webkit-slider-thumb {
  background: var(--primary-text-color);
  border-color: #ffffff;
}
[data-theme="light"] .context-slider::-moz-range-thumb {
  background: var(--primary-text-color);
  border-color: #ffffff;
}

/* --- START: UPDATED SUBSCRIPTION TAB STYLES --- */
.subscription-info-card {
  background-color: var(--main-bg-color);
  border: 1px solid var(--border-color);
  border-radius: 12px;
  padding: 1.5rem;
  margin-top: 1rem;
  border-left-width: 4px;
  transition: border-color 0.3s ease;
}

.subscription-info-card.free { border-left-color: var(--secondary-text-color); }
.subscription-info-card.active { border-left-color: #19c37d; /* Green */ }
.subscription-info-card.canceled { border-left-color: #9ca3af; /* Gray */ }
.subscription-info-card.warning { border-left-color: #f59e0b; /* Amber */ }

.plan-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 0.5rem;
}

.plan-header h4 {
  margin: 0;
  font-size: 1.2rem;
  font-weight: 600;
}

.status-badge {
  font-size: 0.8rem;
  font-weight: 600;
  padding: 4px 10px;
  border-radius: 9999px;
  text-transform: uppercase;
  letter-spacing: 0.05em;
}

.status-badge.free { background-color: hsla(220, 10%, 50%, 0.15); color: var(--secondary-text-color); }
.status-badge.active { background-color: hsla(145, 63%, 42%, 0.15); color: #19c37d; }
.status-badge.canceled { background-color: hsla(220, 10%, 50%, 0.15); color: #9ca3af; }
.status-badge.warning { background-color: hsla(38, 92%, 50%, 0.15); color: #f59e0b; }

.plan-description {
  color: var(--secondary-text-color);
  font-size: 0.9rem;
  margin-bottom: 1.5rem;
  margin-top: 0.5rem; /* Ensure consistent spacing */
}

.plan-features-list {
  list-style: none;
  padding: 0;
  margin: 0 0 1.5rem 0;
  display: flex;
  flex-direction: column;
  gap: 0.75rem;
}

.plan-features-list li {
  display: flex;
  align-items: flex-start;
  gap: 0.75rem;
  font-size: 0.9rem;
  line-height: 1.4;
}

.plan-features-list li svg {
  color: #19c37d;
  margin-top: 2px;
  flex-shrink: 0;
}

.plan-actions {
  margin-top: 1rem;
  border-top: 1px solid var(--border-color);
  padding-top: 1.5rem;
}

.sub-button {
  width: 100%;
  padding: 0.75rem;
  border-radius: 8px;
  font-weight: 600;
  border: none;
  cursor: pointer;
  transition: all 0.2s;
}

.sub-button:not(:disabled):hover {
  transform: translateY(-2px);
  filter: brightness(1.1);
}

.sub-button.manage {
  background-color: var(--button-hover-bg);
  color: var(--primary-text-color);
  border: 1px solid var(--border-color);
}
.sub-button.manage:hover {
  background-color: var(--border-color);
}

.sub-button.upgrade {
  background-color: #834ab5; /* Purple */
  color: white;
}
.sub-button.warning {
  background-color: #f59e0b; /* Amber */
  color: var(--sidebar-bg-color);
}
[data-theme="light"] .sub-button.warning {
  color: var(--primary-text-color);
}

.upgrade-prompt {
  display: flex;
  align-items: center;
  gap: 0.75rem;
  background-color: hsla(268, 48%, 53%, 0.1);
  border: 1px solid hsla(268, 48%, 53%, 0.3);
  padding: 0.75rem 1rem;
  border-radius: 8px;
  margin-bottom: 1.5rem;
}
.upgrade-prompt > svg {
  color: #c084fc; /* Light purple */
}
.upgrade-prompt > span {
  font-weight: 500;
  font-size: 0.9rem;
  color: var(--primary-text-color);
  flex-grow: 1;
}
.upgrade-prompt > button {
  background-color: #834ab5;
  color: white;
  border: none;
  padding: 0.4rem 0.8rem;
  border-radius: 6px;
  font-weight: 500;
  cursor: pointer;
  transition: background-color 0.2s;
}
.upgrade-prompt > button:hover {
  background-color: #6d3a9c;
}

.integrations-list {
  display: flex;
  flex-direction: column;
  gap: 1rem;
}

.integration-card {
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 1rem;
  background-color: var(--main-bg-color);
  padding: 1rem;
  border: 1px solid var(--border-color);
  border-radius: 12px;
}

.integration-info h4 {
  font-size: 1rem;
  font-weight: 600;
  margin: 0 0 0.25rem 0;
}
.integration-info p {
  font-size: 0.85rem;
  color: var(--secondary-text-color);
  margin: 0;
}

/* --- Toggle Switch Styles --- */
.switch {
  position: relative;
  display: inline-block;
  width: 44px;
  height: 24px;
}
.switch input { 
  opacity: 0;
  width: 0;
  height: 0;
}
.slider {
  position: absolute;
  cursor: pointer;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: var(--border-color);
  transition: .4s;
}
.slider:before {
  position: absolute;
  content: "";
  height: 18px;
  width: 18px;
  left: 3px;
  bottom: 3px;
  background-color: white;
  transition: .4s;
}
input:checked + .slider {
  background-color: #19c37d; /* Green */
}
input:disabled + .slider {
  cursor: not-allowed;
  background-color: var(--button-hover-bg);
}
input:checked + .slider:before {
  transform: translateX(20px);
}
.slider.round {
  border-radius: 34px;
}
.slider.round:before {
  border-radius: 50%;
}

/* --- END: UPDATED SUBSCRIPTION TAB STYLES --- */

/* --- LIGHT THEME STYLES --- */
[data-theme="light"] .modal-content { box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.1), 0 8px 10px -6px rgba(0, 0, 0, 0.1); }
[data-theme="light"] .form-group input:focus, [data-theme="light"] .form-group select:focus { box-shadow: 0 0 0 2px hsla(145, 63%, 42%, 0.4); }
[data-theme="light"] .modal-button-save { background-color: var(--primary-text-color); color: var(--main-bg-color); }
[data-theme="light"] .modal-button-save:hover { background-color: #374151; }
[data-theme="light"] .quick-access-item input[type="checkbox"]:checked + .checkbox-visual { background-color: #374151; border-color: #374151; }
[data-theme="light"] .config-menu-item input[type="checkbox"]:checked + .checkbox-visual { background-color: #374151; border-color: #374151; }
[data-theme="light"] .context-value-span {
  background-color: #e5e7eb;
}
[data-theme="light"] .context-value-span:hover {
  background-color: #d1d5db;
}

/* --- RESPONSIVE SETTINGS --- */
@media (max-width: 768px) {
  .modal-content { width: 95vw; max-width: 480px; min-height: 450px; max-height: 85vh; }
  .settings-sidebar { width: 60px; padding: 1rem 0.5rem; }
  .settings-sidebar h2 { display: none; }
  .settings-tab-button { justify-content: center; gap: 0; }
  .settings-tab-button span { display: none; }
  .settings-content { padding: 1.5rem; }
  .modal-actions { flex-direction: column-reverse; gap: 0.5rem; margin-top: 1.5rem; }
  .modal-button { width: 100%; padding: 0.75rem; }
  .theme-options { grid-template-columns: 1fr; }
}
- - - Sidebar.css:
/* src/css/Sidebar.css */
.sidebar {
  width: 260px;
  background-color: var(--sidebar-bg-color);
  color: var(--primary-text-color);
  display: flex;
  flex-direction: column;
  padding: 0;
  border-right: 1px solid var(--border-color);
  transition: width 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  flex-shrink: 0; 
}

.sidebar.is-collapsed {
  width: 80px;
}

.sidebar-overlay {
  display: none;
}

.sidebar-top {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 0.75rem 1rem;
  min-height: 56px;
  box-sizing: border-box;
  position: relative;
  transition: justify-content 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

.sidebar-logo-link {
  display: flex;
  align-items: center;
  gap: 10px;
  min-width: 0; 
}

.sidebar-logo {
  height: 32px;
  flex-shrink: 0;
  transition: filter 0.3s ease-in-out;
}

.sidebar-logo-link:hover .sidebar-logo {
  filter: drop-shadow(0 0 10px hsla(145, 70%, 55%, 0.7));
}

.sidebar-logo-text {
  font-size: 1.1rem;
  font-weight: 600;
  white-space: nowrap;
  overflow: hidden;
  color: var(--primary-text-color);
  transition: opacity 0.2s ease, width 0.3s cubic-bezier(0.4, 0, 0.2, 1), margin-left 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

.sidebar.is-collapsed .sidebar-top {
  justify-content: center;
  padding: 0.75rem 0;
}

.sidebar.is-collapsed .sidebar-logo-link {
  cursor: default;
}

.sidebar.is-collapsed .sidebar-logo {
  transition: opacity 0.2s ease-in-out, filter 0.3s ease-in-out;
}

.sidebar.is-collapsed .sidebar-logo-text {
  opacity: 0;
  width: 0;
  margin-left: -10px;
}

.sidebar.is-collapsed .collapse-button {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  opacity: 0;
  pointer-events: none;
  background-color: var(--button-hover-bg);
  transition: opacity 0.2s ease-in-out;
}

.sidebar.is-collapsed .sidebar-top:hover .sidebar-logo {
  opacity: 0;
}

.sidebar.is-collapsed .sidebar-top:hover .collapse-button {
  opacity: 1;
  pointer-events: auto;
}

.sidebar-nav {
  padding: 0.5rem 0;
}

/* --- VISIBLE DIVIDER --- */
.sidebar-divider {
  height: 1px;
  background-color: var(--border-color);
  margin: 8px 12px;
  list-style: none;
}

.sidebar-button {
  background: none;
  border: none;
  color: var(--primary-text-color);
  display: flex;
  align-items: center;
  padding: 10px 12px;
  border-radius: 8px;
  cursor: pointer;
  width: calc(100% - 16px); /* Account for margin */
  margin: 0 8px; /* Center buttons horizontally */
  text-align: left;
  transition: background-color 0.2s, padding 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  font-size: 0.9rem;
}

.sidebar-button:hover {
  background-color: var(--button-hover-bg);
}

.sidebar-button span {
  margin-left: 12px;
  font-weight: 500;
  transition: opacity 0.2s ease, width 0.3s cubic-bezier(0.4, 0, 0.2, 1), margin-left 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  white-space: nowrap;
  overflow: hidden;
}

.sidebar.is-collapsed .sidebar-button {
  justify-content: center;
  padding: 10px;
}

.sidebar.is-collapsed .sidebar-button span {
  opacity: 0;
  width: 0;
  margin-left: 0;
}

.collapse-button {
  display: flex;
  width: auto;
  padding: 10px;
}

.mobile-close-button {
  display: none;
}

.collapse-button svg {
  transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}
.sidebar.is-collapsed .collapse-button svg {
  transform: rotate(180deg);
}

/* Specific styles for the NEW CHAT button */
.new-chat-button {
  background-color: var(--button-hover-bg);
  font-weight: 600;
}

.new-chat-button:hover {
  background-color: var(--border-color); /* Slightly darker hover for prominence */
}

.sidebar.is-collapsed .new-chat-button {
  justify-content: center;
}

.sidebar-conversations {
  flex-grow: 1;
  padding: 1rem 0.5rem; 
  overflow-y: auto;
  transition: opacity 0.2s ease 0.1s;
}

.sidebar.is-collapsed .sidebar-conversations {
  opacity: 0;
  pointer-events: none;
}

.sidebar-conversations::-webkit-scrollbar {
  width: 6px;
}

.sidebar-conversations::-webkit-scrollbar-track {
  background: transparent;
}

.sidebar-conversations::-webkit-scrollbar-thumb {
  background-color: var(--border-color);
  border-radius: 3px;
}

.sidebar-conversations::-webkit-scrollbar-thumb:hover {
  background-color: var(--secondary-text-color);
}

.convos-header {
  font-size: 0.8rem;
  font-weight: 500;
  color: var(--secondary-text-color);
  padding: 0 12px 8px 12px;
}

@keyframes shimmer {
  100% {
    transform: translateX(100%);
  }
}

@keyframes fadeInList {
  to { opacity: 1; }
}

.convo-list-loading {
  display: flex;
  flex-direction: column;
  gap: 2px;
}

.convo-list-item-skeleton {
  width: 100%;
  height: 35px; 
  border-radius: 6px;
  background-color: var(--button-hover-bg);
  position: relative;
  overflow: hidden;
}

.convo-list-item-skeleton::after {
  content: '';
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  transform: translateX(-100%);
  background: linear-gradient(90deg, 
    transparent 25%, 
    hsla(0, 0%, 100%, 0.1) 50%, 
    transparent 75%
  );
  animation: shimmer 1.5s infinite;
}

[data-theme="light"] .convo-list-item-skeleton::after {
   background: linear-gradient(90deg, 
    transparent 25%, 
    rgba(0,0,0,0.05) 50%, 
    transparent 75%
  );
}

.convo-list {
  list-style: none;
  padding: 0;
  margin: 0;
  display: flex;
  flex-direction: column;
  gap: 2px; 
  opacity: 0;
  animation: fadeInList 0.4s 0.1s ease forwards;
}

.convo-list li {
  position: relative;
  border-radius: 6px; 
  transition: background-color 0.2s;
  display: flex;
  align-items: center;
}

.convo-list li:hover {
  background-color: var(--button-hover-bg);
}

.convo-list li a {
  padding: 8px 12px;
  border-radius: 6px;
  color: var(--primary-text-color);
  text-decoration: none;
  font-size: 0.9rem;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  flex-grow: 1;
  min-width: 0; 
}

.chat-item-menu-trigger {
  background: none;
  border: none;
  color: var(--secondary-text-color);
  cursor: pointer;
  padding: 4px;
  border-radius: 6px;
  display: flex;
  align-items: center;
  justify-content: center;
  opacity: 1;
  pointer-events: auto;
  transition: background-color 0.2s, color 0.2s;
  flex-shrink: 0;
  margin-right: 8px;
}

.chat-item-menu-trigger:hover,
.chat-item-menu-trigger.active {
  background-color: var(--button-hover-bg);
  color: var(--primary-text-color);
}

@keyframes menu-pop-in {
  to {
    opacity: 1;
    transform: translateY(0) scale(1);
  }
}

.chat-item-actions-menu {
  position: absolute;
  top: 40px; 
  right: 8px;
  width: 160px;
  z-index: 20;
  background-color: hsl(220, 13%, 15%);
  border-radius: 10px;
  border: 1px solid var(--border-color);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
  padding: 6px;
  opacity: 0;
  transform: translateY(-10px) scale(0.95);
  transform-origin: top right;
  animation: menu-pop-in 0.15s cubic-bezier(0.4, 0, 0.2, 1) forwards;
}

.menu-action-button {
  display: flex;
  align-items: center;
  gap: 10px;
  width: 100%;
  padding: 8px 10px;
  background: none;
  border: none;
  cursor: pointer;
  text-align: left;
  color: var(--primary-text-color);
  font-size: 0.875rem;
  border-radius: 6px;
  transition: background-color 0.2s;
}

.menu-action-button:hover {
  background-color: var(--button-hover-bg);
}

.menu-action-button.destructive {
  color: #f43f5e;
}
.menu-action-button.destructive:hover {
  background-color: hsla(349, 89%, 60%, 0.1);
  color: #be123c;
}

.menu-button.destructive {
  color: #f43f5e;
}

.menu-button.destructive:hover {
  background-color: hsla(349, 89%, 60%, 0.1);
  color: #be123c;
}

.user-profile-menu-divider {
  height: 1px;
  background-color: var(--border-color);
  margin: 0.5rem;
}


.sidebar-footer {
  padding: 1rem;
  margin-top: auto; 
  border-top: 1px solid var(--border-color);
}

.user-profile-wrapper {
  position: relative; 
}

.user-profile-menu {
  position: absolute;
  bottom: calc(100% + 8px); 
  left: 0;
  width: 228px; 
  background-color: var(--sidebar-bg-color); 
  border-radius: 12px;
  border: 1px solid var(--border-color);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
  padding: 0.5rem;
  display: flex;
  flex-direction: column;
  gap: 4px;
  z-index: 10;
  opacity: 0;
  transform: translateY(10px) scale(0.95);
  transform-origin: bottom center;
  pointer-events: none;
  transition: opacity 0.2s cubic-bezier(0.4, 0, 0.2, 1), transform 0.2s cubic-bezier(0.4, 0, 0.2, 1);
}

.user-profile-menu.open {
  opacity: 1;
  transform: translateY(0) scale(1);
  pointer-events: auto;
}

.menu-button {
  display: flex;
  align-items: center;
  gap: 12px;
  width: 100%;
  padding: 10px 12px;
  border: none;
  background-color: transparent;
  color: var(--primary-text-color);
  font-size: 0.9rem;
  font-weight: 500;
  border-radius: 8px;
  cursor: pointer;
  text-align: left;
  transition: background-color 0.2s ease;
}

.menu-button > svg {
  font-size: 16px;
}

.menu-button:hover {
  background-color: var(--button-hover-bg);
}

.menu-button > svg {
  flex-shrink: 0;
  color: var(--secondary-text-color);
}

.user-profile {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 8px;
  border-radius: 8px;
  transition: background-color 0.2s ease, justify-content 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  cursor: pointer;
}

.sidebar.is-collapsed .user-profile {
  justify-content: center;
  gap: 0;
}

.user-profile:hover {
  background-color: var(--button-hover-bg);
}

.user-avatar {
  width: 32px;
  height: 32px;
  border-radius: 50%;
  background-color: #19c37d; /* Green accent */
  color: var(--sidebar-bg-color);
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: 600;
  font-size: 1rem;
  flex-shrink: 0;
}

.user-name {
  flex-grow: 1;
  font-weight: 500;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  transition: opacity 0.2s ease, width 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

.sidebar.is-collapsed .user-name {
  opacity: 0;
  width: 0;
}

.user-options-button {
  background: none;
  border: none;
  color: var(--secondary-text-color);
  cursor: pointer;
  padding: 4px;
  border-radius: 4px;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: background-color 0.2s, color 0.2s, opacity 0.3s ease;
  pointer-events: none; /* Button inside a clickable parent */
}

.sidebar.is-collapsed .user-options-button {
  opacity: 0;
  width: 0;
  padding: 0;
}


.convo-list li a.active {
  background-color: var(--button-hover-bg);
  font-weight: 500;
}

[data-theme="light"] .user-profile-menu,
[data-theme="light"] .chat-item-actions-menu {
  background-color: var(--sidebar-bg-color);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
}

[data-theme="light"] .menu-button {
  color: var(--primary-text-color);
}

[data-theme="light"] .menu-button > svg {
  color: var(--secondary-text-color);
}

.upgrade-banner-wrapper {
  position: relative;
  margin-bottom: 1rem;
}

.upgrade-banner {
  display: flex;
  align-items: center;
  gap: 0.75rem;
  background-color: hsla(268, 48%, 53%, 0.15);
  border: 1px solid hsla(268, 48%, 53%, 0.4);
  padding: 0.75rem 1rem;
  border-radius: 10px;
  cursor: pointer;
  transition: all 0.2s ease-in-out;
}

.upgrade-banner:hover {
  background-color: hsla(268, 48%, 53%, 0.25);
  border-color: hsla(268, 48%, 53%, 0.6);
  transform: translateY(-1px);
}

.upgrade-banner > svg {
  color: #c084fc; /* Light purple */
  flex-shrink: 0;
}

.upgrade-banner > span {
  font-weight: 600;
  font-size: 0.9rem;
  color: var(--primary-text-color);
}

.dismiss-banner-btn {
  position: absolute;
  top: 0;
  right: 0;
  transform: translate(40%, -40%);
  background-color: transparent; /* No background */
  color: var(--secondary-text-color);
  width: 24px;
  height: 24px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  z-index: 1;
  opacity: 0; /* Hidden by default */
  pointer-events: none; /* Not clickable when hidden */
  transition: opacity 0.2s ease, color 0.2s ease, transform 0.2s ease;
}

.upgrade-banner-wrapper:hover .dismiss-banner-btn {
  opacity: 1; /* Show on hover */
  pointer-events: auto; /* Clickable on hover */
}

.dismiss-banner-btn:hover {
  background-color: transparent; /* Explicitly keep background transparent on hover */
  color: var(--primary-text-color);
  transform: translate(40%, -40%) scale(1.1);
}

@media (max-width: 768px) {
  .app-container {
    --sidebar-width: 0;
  }
  
  .sidebar {
    position: fixed;
    top: 0;
    left: 0;
    height: 100%;
    z-index: 1100; 
    transform: translateX(-100%);
    transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    border-right: 1px solid var(--border-color);
  }

  .sidebar.mobile-open {
    transform: translateX(0);
    box-shadow: 4px 0px 15px -5px rgba(0,0,0,0.2);
  }

  .sidebar-overlay {
    display: block;
    position: fixed;
    inset: 0;
    background-color: rgba(0, 0, 0, 0.5);
    z-index: 1050;
    animation: fadeIn 0.3s ease-in-out;
  }
  
  @keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
  }

  .collapse-button {
    display: none;
  }
  
  .mobile-close-button {
    display: flex;
    width: auto;
    padding: 10px;
  }
  
  .sidebar.is-collapsed {
    width: 260px;
  }
  .sidebar.is-collapsed .sidebar-top {
    justify-content: space-between;
    padding: 0.75rem 1rem;
  }
  .sidebar.is-collapsed .sidebar-button span,
  .sidebar.is-collapsed .user-name {
    opacity: 1;
    width: auto;
  }
  .sidebar.is-collapsed .sidebar-button span {
    margin-left: 12px;
  }
  .sidebar.is-collapsed .sidebar-conversations {
    opacity: 1;
    pointer-events: auto;
  }
  .sidebar.is-collapsed .user-profile {
    justify-content: flex-start;
    gap: 12px;
  }
  .sidebar.is-collapsed .user-options-button {
    opacity: 1;
    width: auto;
    padding: 4px;
  }
}
- - - SidePanel.css:
/* src/css/SidePanel.css */

/* --- Animations --- */
@keyframes slideInRight {
  from { transform: translateX(100%); }
  to { transform: translateX(0); }
}

@keyframes slideOutRight {
  from { transform: translateX(0); }
  to { transform: translateX(100%); }
}

@keyframes fadeInOverlay {
  from { opacity: 0; }
  to { opacity: 1; }
}

@keyframes fadeOutOverlay {
  from { opacity: 1; }
  to { opacity: 0; }
}

/* --- Mobile specific animations --- */
@keyframes slideUpPanel { 
  from { transform: translateY(100%); } 
  to { transform: translateY(0); } 
}

@keyframes slideDownPanel { 
  from { transform: translateY(0); } 
  to { transform: translateY(100%); } 
}

.side-panel-container {
  position: fixed;
  top: 0;
  right: 0;
  bottom: 0;
  width: 350px;
  background-color: var(--main-bg-color);
  border-left: 1px solid var(--border-color);
  z-index: 2000;
  
  /* Flexbox Configuration */
  display: flex;
  flex-direction: column;
  
  /* Force full height constraints */
  height: 100vh;
  max-height: 100vh;
  overflow: hidden;
  
  box-shadow: -5px 0 20px rgba(0,0,0,0.1);
  /* Entrance Animation */
  animation: slideInRight 0.3s cubic-bezier(0.16, 1, 0.3, 1) forwards;
}

/* Exit Animation Class */
.side-panel-container.closing {
  animation: slideOutRight 0.3s cubic-bezier(0.4, 0, 0.2, 1) forwards;
}

.side-panel-overlay {
  position: fixed;
  inset: 0;
  background: transparent;
  z-index: 1999;
  /* Entrance Animation */
  animation: fadeInOverlay 0.3s ease forwards;
}

/* Exit Animation Class */
.side-panel-overlay.closing {
  animation: fadeOutOverlay 0.3s ease forwards;
}

.side-panel-content {
  display: flex;
  flex-direction: column;
  height: 100%;
  min-height: 0;
  overflow: hidden;
}

.side-panel-header {
  flex: 0 0 auto;
  padding: 16px;
  border-bottom: 1px solid var(--border-color);
  display: flex;
  justify-content: space-between;
  align-items: center;
  background-color: var(--main-bg-color);
}

.side-panel-header h3 { margin: 0; font-size: 1.1rem; font-weight: 600; }
.close-panel-btn { cursor: pointer; color: var(--secondary-text-color); }

.sources-list {
  flex: 1;
  overflow-y: auto;
  min-height: 0;
  padding: 16px;
  padding-right: 12px;
  display: flex;
  flex-direction: column;
  gap: 12px;
  padding-bottom: 40px;
  scrollbar-width: thin;
  scrollbar-color: var(--secondary-text-color) transparent;
}

/* --- Scrollbar Styles --- */
.sources-list::-webkit-scrollbar {
  width: 8px;
  height: 8px;
  display: block;
}
.sources-list::-webkit-scrollbar-track {
  background: transparent;
  margin: 4px 0;
}
.sources-list::-webkit-scrollbar-thumb {
  background-color: #d1d5db;
  border-radius: 4px;
  border: 2px solid var(--main-bg-color);
}
[data-theme="dark"] .sources-list::-webkit-scrollbar-thumb {
  background-color: #52525b;
}
.sources-list::-webkit-scrollbar-thumb:hover {
  background-color: var(--secondary-text-color);
}

/* --- Item Styles --- */
.source-card {
  display: block;
  padding: 12px;
  background-color: var(--button-hover-bg);
  border-radius: 8px;
  border: 1px solid transparent;
  text-decoration: none;
  color: inherit;
  transition: all 0.2s;
  flex-shrink: 0; 
}
.source-card:hover {
  background-color: var(--input-bg-color);
  border-color: var(--border-color);
  transform: translateY(-1px);
}
.source-card-header {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 6px;
}
.source-favicon img { width: 16px; height: 16px; border-radius: 2px; }
.source-title { font-weight: 600; font-size: 0.9rem; overflow: hidden; white-space: nowrap; text-overflow: ellipsis; }
.source-snippet { font-size: 0.8rem; color: var(--secondary-text-color); line-height: 1.4; display: -webkit-box; -webkit-box-orient: vertical; overflow: hidden; margin-bottom: 8px; }
.source-url { font-size: 0.75rem; color: var(--secondary-text-color); display: flex; align-items: center; gap: 4px; }

/* Mobile styles */
@media (max-width: 768px) {
  .side-panel-container {
    width: 100%;
    top: auto;
    height: 80vh;
    border-radius: 16px 16px 0 0;
    border-left: none;
    border-top: 1px solid var(--border-color);
    animation: slideUpPanel 0.3s cubic-bezier(0.16, 1, 0.3, 1) forwards;
  }
  
  .side-panel-container.closing {
    animation: slideDownPanel 0.3s cubic-bezier(0.4, 0, 0.2, 1) forwards;
  }

  .side-panel-overlay { background: rgba(0,0,0,0.4); }
}
- - - StreamingText.css:
/* src/css/StreamingText.css */

.streaming-text-container {
  position: relative;
}

.markdown-body {
  position: relative;
}

/* Enable GPU acceleration for smoother rendering */
.streaming-text-container .markdown-body {
  will-change: transform, opacity;
  transform: translateZ(0);
}

/* Smooth fade animation when new content is added */
.streaming-text-container.content-updating .markdown-body {
  animation: smoothFadeIn 0.3s ease-out;
}

@keyframes smoothFadeIn {
  0% {
    opacity: 0.7;
    transform: translateY(1px);
  }
  100% {
    opacity: 1;
    transform: translateY(0);
  }
}
- - - SubscriptionSuccessOverlay.css:
/* src/css/SubscriptionSuccessOverlay.css */
.sub-success-overlay {
  position: fixed;
  inset: 0;
  /* Ensure this is above all other app overlays (use very high z-index) */
  z-index: 2147483000;
  display: grid;
  place-items: center;
}

.sub-success-backdrop {
  position: absolute;
  inset: 0;
  /* Solid, theme-matched backdrop */
  background: var(--overlay-scrim);
  backdrop-filter: blur(4px);
  animation: fadeIn 200ms ease forwards;
  z-index: 0;
}

.sub-success-card {
  position: relative;
  width: min(560px, 92vw);
  /* Force fully opaque, theme-matched card to prevent underlying bleed-through */
  background: var(--main-bg-color);
  color: var(--primary-text-color);
  border-radius: 16px;
  box-shadow: 0 20px 60px rgba(0,0,0,0.35);
  padding: 28px 28px 24px;
  transform: translateY(10px) scale(0.98);
  opacity: 0;
  animation: popIn 320ms cubic-bezier(.2,.8,.2,1) forwards;
  z-index: 1; /* Above backdrop */
  isolation: isolate; /* ensure no backdrop/filter blending leaks */
}

.sub-success-card .icon-wrap {
  width: 60px; height: 60px;
  border-radius: 50%;
  display: grid; place-items: center;
  margin: 0 auto 12px;
  color: #19c37d;
  background: radial-gradient( circle at 30% 30%, rgba(25,195,125,0.25), rgba(25,195,125,0.05) );
}

.sub-success-card .title {
  text-align: center;
  margin: 6px 0 4px;
  font-size: 24px;
  letter-spacing: 0.2px;
}

.sub-success-card .subtitle {
  text-align: center;
  opacity: 0.8;
  margin: 0 0 14px;
}

.sub-success-card .feature-list {
  margin: 8px 0 18px;
  padding-left: 18px;
  display: grid;
  gap: 8px;
}

.sub-success-card .feature-list li {
  line-height: 1.4;
}

.sub-success-card .cta-button {
  display: block;
  width: 100%;
  padding: 12px 16px;
  border-radius: 10px;
  border: none;
  background: linear-gradient(135deg, #19c37d, #10b981);
  color: #ffffff;
  font-weight: 600;
  cursor: pointer;
  transition: filter 120ms ease, transform 120ms ease;
}

.sub-success-card .cta-button:hover { filter: brightness(1.05); transform: translateY(-1px); }
.sub-success-card .cta-button:active { transform: translateY(0); }

/* Confetti sprinkle */
.confetti { position: absolute; inset: 0; pointer-events: none; overflow: hidden; }
.confetti span {
  position: absolute;
  top: -10px; left: 50%;
  width: 8px; height: 12px;
  background: currentColor;
  border-radius: 2px;
  opacity: 0.9;
  animation: confettiFall 1200ms ease-out forwards;
}
.confetti span:nth-child(1){ left: 40%; background: #19c37d; animation-delay: 80ms; transform: rotate(12deg); }
.confetti span:nth-child(2){ left: 50%; background: #06b6d4; animation-delay: 120ms; transform: rotate(-8deg); }
.confetti span:nth-child(3){ left: 60%; background: #f59e0b; animation-delay: 160ms; transform: rotate(18deg); }
.confetti span:nth-child(4){ left: 45%; background: #8b5cf6; animation-delay: 200ms; transform: rotate(-16deg); }
.confetti span:nth-child(5){ left: 55%; background: #ef4444; animation-delay: 240ms; transform: rotate(10deg); }

@keyframes confettiFall {
  0% { transform: translateY(-20px) rotate(0deg); opacity: 0; }
  15% { opacity: 1; }
  100% { transform: translateY(220px) rotate(260deg); opacity: 0; }
}

@keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
@keyframes popIn { from { opacity: 0; transform: translateY(10px) scale(0.98);} to { opacity: 1; transform: translateY(0) scale(1);} }
- - - Tooltip.css:
/* src/css/Tooltip.css */

.tooltip-container {
  display: inline-flex;
  justify-content: center;
  align-items: center;
}

/* UPDATED: Changed to position: fixed */
.tooltip-content {
  position: fixed; /* Use fixed positioning to escape clipping contexts */
  
  /* The 'top' and 'left' will be set by inline styles from the component */
  
  background-color: var(--tooltip-bg-color);
  color: var(--tooltip-text-color);
  padding: 6px 12px;
  border-radius: 9999px; /* Pill shape */
  
  font-size: 0.8rem;
  font-weight: 500;
  font-family: inherit;
  white-space: nowrap;
  
  z-index: 9999; /* Ensure it's on top of everything */
  
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.2s ease-out, transform 0.2s ease-out;
  
  /* UPDATED: Start slightly higher for the downward animation */
  transform: translateY(-4px);
}

.tooltip-content.visible {
  opacity: 1;
  transform: translateY(0);
}
- - - VoiceChatModal.css:
/* src/css/VoiceChatModal.css */

.voice-chat-overlay {
  position: fixed;
  top: 0;
  left: var(--sidebar-width, 260px); /* Start after sidebar on desktop */
  right: 0;
  bottom: 0;
  background-color: rgba(0, 0, 0, 0.85);
  backdrop-filter: blur(12px);
  display: block;
  z-index: 9999;
  animation: fadeIn 0.3s ease-in-out;
  overflow: hidden;
  transition: left 0.3s cubic-bezier(0.4, 0, 0.2, 1); /* Smooth transition when sidebar collapses */
}

@keyframes fadeIn {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}

.voice-chat-modal {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  width: 100%;
  height: 100%;
  background: var(--main-bg-color);
  border-radius: 0;
  box-shadow: none;
  display: flex;
  flex-direction: column;
  overflow: hidden;
  animation: slideInRight 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

@keyframes slideInRight {
  from {
    opacity: 0;
    transform: translateX(50px);
  }
  to {
    opacity: 1;
    transform: translateX(0);
  }
}

@keyframes slideUpModal {
  from {
    opacity: 0;
    transform: translateY(100%);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

/* Mobile drag grip - hidden on desktop */
.voice-chat-modal::before {
  content: '';
  position: absolute;
  top: 12px;
  left: 50%;
  transform: translateX(-50%);
  width: 48px;
  height: 5px;
  background-color: var(--border-color);
  border-radius: 10px;
  opacity: 0;
  z-index: 10;
  transition: opacity 0.2s ease;
  pointer-events: none;
}

/* Show grip only on mobile */
@media (max-width: 768px) {
  .voice-chat-modal::before {
    opacity: 0.6;
  }

  .voice-chat-modal:hover::before {
    opacity: 0.8;
  }
}

.voice-chat-close-btn {
  position: absolute;
  top: 20px;
  right: 20px;
  background: var(--button-hover-bg);
  border: 1px solid var(--border-color);
  color: var(--secondary-text-color);
  cursor: pointer;
  width: 44px;
  height: 44px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s ease;
  z-index: 100;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
}

.voice-chat-close-btn:hover {
  background-color: rgba(239, 68, 68, 0.1);
  border-color: rgba(239, 68, 68, 0.3);
  color: #ef4444;
  transform: scale(1.05) rotate(90deg);
}

.voice-chat-close-btn:active {
  transform: scale(0.95) rotate(90deg);
}

.voice-chat-content {
  flex: 1;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: flex-start;
  padding: 100px 40px 40px; /* More top padding for close button */
  gap: 28px;
  overflow-y: auto;
  width: 100%;
  min-height: 100%;
  box-sizing: border-box;
}

/* AI Orb Styles */
.ai-orb {
  position: relative;
  width: 220px;
  height: 220px;
  display: block;
  margin: 20px auto;
  flex-shrink: 0;
  z-index: 1;
}

.orb-inner {
  position: absolute;
  width: 100%;
  height: 100%;
  background: linear-gradient(135deg, #10b981 0%, #059669 50%, #34d399 100%);
  border-radius: 50%;
  box-shadow: 0 0 40px rgba(16, 185, 129, 0.5), 0 0 80px rgba(16, 185, 129, 0.3);
  transition: all 0.3s ease;
  z-index: 1;
}

.orb-glow {
  position: absolute;
  width: 130%;
  height: 130%;
  background: radial-gradient(circle, rgba(16, 185, 129, 0.4) 0%, transparent 70%);
  border-radius: 50%;
  animation: glow 2s ease-in-out infinite;
  z-index: 0;
}

@keyframes glow {
  0%, 100% {
    transform: scale(1);
    opacity: 0.6;
  }
  50% {
    transform: scale(1.15);
    opacity: 0.9;
  }
}

/* Removed expanding pulse ring for a cleaner look */

/* Speaking state */
.ai-orb.speaking .orb-inner {
  background: linear-gradient(135deg, #f59e0b 0%, #f97316 50%, #fbbf24 100%);
  box-shadow: 0 0 70px rgba(245, 158, 11, 0.8), 0 0 120px rgba(245, 158, 11, 0.5);
  animation: speakingPulse 0.9s ease-in-out infinite;
}

@keyframes speakingPulse {
  0%, 100% {
    transform: scale(1);
  }
  50% {
    transform: scale(1.12);
  }
}

.ai-orb.speaking .orb-glow {
  background: radial-gradient(circle, rgba(245, 158, 11, 0.5) 0%, transparent 70%);
  animation: speakingGlow 0.9s ease-in-out infinite;
}

@keyframes speakingGlow {
  0%, 100% {
    transform: scale(1.05);
    opacity: 0.8;
  }
  50% {
    transform: scale(1.28);
    opacity: 1;
  }
}

/* Listening state */
.ai-orb.listening .orb-inner {
  background: linear-gradient(135deg, #10b981 0%, #059669 50%, #34d399 100%);
  box-shadow: 0 0 70px rgba(16, 185, 129, 0.8), 0 0 120px rgba(16, 185, 129, 0.5);
  animation: listeningPulse 1.2s ease-in-out infinite;
}

@keyframes listeningPulse {
  0%, 100% {
    transform: scale(1);
  }
  50% {
    transform: scale(1.08);
  }
}

.ai-orb.listening .orb-glow {
  background: radial-gradient(circle, rgba(16, 185, 129, 0.5) 0%, transparent 70%);
}

.ai-orb.listening .orb-pulse {
  animation: pulse 1s ease-out infinite;
  border-color: rgba(16, 185, 129, 0.8);
}

/* Status Text */
.voice-chat-status {
  min-height: 30px;
  display: flex;
  align-items: center;
  justify-content: center;
}

.status-text {
  font-size: 1.2rem;
  font-weight: 500;
  color: var(--secondary-text-color);
  margin: 0;
  animation: fadeIn 0.3s ease;
}

.status-text.listening {
  color: #10b981;
  font-weight: 600;
}

.status-text.speaking {
  color: #f59e0b;
  font-weight: 600;
}

/* Transcript Display */
.transcript-display,
.response-display {
  width: 90%;
  max-width: 500px;
  padding: 16px;
  background-color: var(--button-hover-bg);
  border: 1px solid var(--border-color);
  border-radius: 16px;
  animation: slideIn 0.3s ease;
  box-sizing: border-box;
}

@keyframes slideIn {
  from {
    opacity: 0;
    transform: translateY(10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.transcript-label,
.response-label {
  font-size: 0.85rem;
  font-weight: 600;
  color: var(--secondary-text-color);
  margin: 0 0 8px 0;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.transcript-text,
.response-text {
  font-size: 1rem;
  color: var(--primary-text-color);
  margin: 0;
  line-height: 1.5;
}

/* Controls */
.voice-chat-controls {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 12px;
  margin: 0 0 20px 0; /* 20px gap above the info text */
  z-index: 5;
}

/* Three-dots speech indicator */
.voice-dots {
  display: flex;
  align-items: flex-end;
  justify-content: center;
  gap: 14px;
  height: 28px; /* vertical room for stretch */
  cursor: pointer; /* clickable to unlock audio only */
}

.voice-dots .dot {
  width: 12px;
  height: 12px;
  background: #000; /* bold black dots */
  border-radius: 50%;
  transform-origin: bottom center;
}

.voice-dots.thinking .dot {
  animation: dotStretch 900ms ease-in-out infinite;
}

.voice-dots.thinking .dot:nth-child(2) {
  animation-delay: 150ms;
}

.voice-dots.thinking .dot:nth-child(3) {
  animation-delay: 300ms;
}

@keyframes dotStretch {
  0%, 80%, 100% {
    transform: translateY(0) scaleY(1);
  }
  40% {
    transform: translateY(-6px) scaleY(1.5);
  }
}

.voice-control-btn {
  width: 90px;
  height: 90px;
  border-radius: 50%;
  border: none;
  background: linear-gradient(135deg, #10b981 0%, #059669 100%);
  color: white;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  box-shadow: 0 6px 25px rgba(16, 185, 129, 0.4), 0 0 0 0 rgba(16, 185, 129, 0.7);
  transition: all 0.3s ease;
  position: relative;
}

.voice-control-btn::before {
  content: '';
  position: absolute;
  inset: -6px;
  border-radius: 50%;
  background: linear-gradient(135deg, #10b981 0%, #059669 100%);
  opacity: 0;
  filter: blur(12px);
  transition: opacity 0.3s ease;
  z-index: -1;
}

.voice-control-btn:hover:not(:disabled) {
  transform: scale(1.08);
  box-shadow: 0 8px 35px rgba(16, 185, 129, 0.6), 0 0 60px rgba(16, 185, 129, 0.4);
}

.voice-control-btn:hover:not(:disabled)::before {
  opacity: 1;
}

.voice-control-btn:active:not(:disabled) {
  transform: scale(0.95);
}

.voice-control-btn.active {
  background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
  box-shadow: 0 6px 25px rgba(239, 68, 68, 0.5), 0 0 0 0 rgba(239, 68, 68, 0.7);
  animation: activePulse 1.5s ease-in-out infinite;
}

.voice-control-btn.active::before {
  background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
}

.voice-debug-btn {
  background: linear-gradient(135deg, #10b981 0%, #059669 100%);
  color: white;
  border: none;
  border-radius: 12px;
  padding: 12px 24px;
  font-size: 0.9rem;
  font-weight: 500;
  cursor: pointer;
  box-shadow: 0 4px 15px rgba(16, 185, 129, 0.3);
  transition: all 0.2s ease;
  position: relative;
  overflow: hidden;
}

.voice-debug-btn::before {
  content: '';
  position: absolute;
  top: 50%;
  left: 50%;
  width: 0;
  height: 0;
  border-radius: 50%;
  background: rgba(255, 255, 255, 0.2);
  transform: translate(-50%, -50%);
  transition: width 0.3s ease, height 0.3s ease;
}

.voice-debug-btn:hover {
  transform: translateY(-2px);
  box-shadow: 0 6px 20px rgba(16, 185, 129, 0.4), 0 0 30px rgba(16, 185, 129, 0.2);
}

.voice-debug-btn:hover::before {
  width: 300px;
  height: 300px;
}

.voice-debug-btn:active {
  transform: translateY(0);
  box-shadow: 0 3px 10px rgba(16, 185, 129, 0.3);
}

/* Voice tools pane inside modal */
.voice-tools-pane {
  width: 100%;
  max-width: 900px;
  margin: 8px auto 0;
  display: flex;
  flex-direction: column;
  gap: 14px;
}

/* Voice error modal */
.voice-error-backdrop {
  position: fixed;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  background: rgba(0,0,0,0.35);
  backdrop-filter: blur(6px);
  z-index: 1000;
}

.voice-error-card {
  position: relative;
  width: min(520px, 92vw);
  border-radius: 20px;
  padding: 22px 22px 18px;
  animation: errorPop 220ms ease-out;
  box-shadow: 0 14px 40px rgba(0,0,0,0.28);
}

/* Theme-contrasted solid card: reverse scheme for emphasis */
[data-theme="dark"] .voice-error-card {
  background: #ffffff; /* solid light card in dark theme */
  color: #0f172a; /* slate-900 text */
  border: 1px solid #e5e7eb; /* light border */
}

[data-theme="light"] .voice-error-card {
  background: #0f172a; /* solid dark card in light theme */
  color: #f8fafc; /* near-white text */
  border: 1px solid rgba(255,255,255,0.15);
}

@keyframes errorPop {
  from { transform: scale(0.96); opacity: 0; }
  to { transform: scale(1); opacity: 1; }
}

.voice-error-icon {
  width: 48px;
  height: 48px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 12px;
  margin-bottom: 12px;
  color: #f59e0b;
  background: radial-gradient(90px 90px at 20% 20%, rgba(245,158,11,0.22), transparent 60%),
              linear-gradient(135deg, rgba(245,158,11,0.18), rgba(245,158,11,0.06));
}

.voice-error-title {
  margin: 0 0 6px 0;
  font-size: 1.25rem;
  font-weight: 800;
}

.voice-error-message {
  margin: 0 0 16px 0;
  font-size: 0.98rem;
}

[data-theme="dark"] .voice-error-message { color: #334155; } /* slate-600 on light card */
[data-theme="light"] .voice-error-message { color: rgba(248,250,252,0.82); }

.voice-error-actions {
  display: flex;
  justify-content: flex-end;
}

.voice-error-button {
  background: linear-gradient(135deg, #10b981 0%, #059669 100%);
  color: white;
  border: none;
  border-radius: 10px;
  padding: 10px 16px;
  font-size: 0.95rem;
  font-weight: 600;
  cursor: pointer;
  box-shadow: 0 6px 20px rgba(16,185,129,0.35);
  transition: transform 0.15s ease, box-shadow 0.15s ease;
}

.voice-error-button:hover { transform: translateY(-1px); box-shadow: 0 8px 26px rgba(16,185,129,0.45); }
.voice-error-button:active { transform: translateY(0); box-shadow: 0 4px 14px rgba(16,185,129,0.3); }

@keyframes activePulse {
  0%, 100% {
    box-shadow: 0 6px 25px rgba(239, 68, 68, 0.5), 0 0 40px rgba(239, 68, 68, 0.7);
  }
  50% {
    box-shadow: 0 8px 35px rgba(239, 68, 68, 0.7), 0 0 70px rgba(239, 68, 68, 0.9);
  }
}

/* Info Text */
.voice-chat-info {
  margin-top: auto;
  padding: 20px 20px 0;
  text-align: center;
  width: 100%;
  max-width: 600px;
  box-sizing: border-box;
}

.info-text {
  font-size: 0.9rem;
  color: var(--secondary-text-color);
  margin: 0;
  line-height: 1.5;
}

/* Bottom-center caption synced with speech */
.voice-caption {
  margin-top: 12px;
  text-align: center;
  padding: 4px 8px;
  font-weight: 800; /* bold */
  font-size: clamp(16px, 2.6vw, 28px);
  color: #000; /* bold black text requested */
  pointer-events: none;
  max-width: min(800px, 92%);
  align-self: center;
  line-height: 1.35;
  overflow-wrap: anywhere;
  word-break: break-word;
  white-space: normal;
}

@media (max-width: 768px) {
  .voice-caption { font-size: clamp(16px, 3.6vw, 24px); }
}

/* Dark theme adjustments */
[data-theme="dark"] .voice-chat-overlay {
  background-color: rgba(0, 0, 0, 0.9);
}

[data-theme="dark"] .ai-orb.speaking .orb-inner {
  box-shadow: 0 0 80px rgba(245, 158, 11, 0.8), 0 0 120px rgba(245, 158, 11, 0.5);
}

[data-theme="dark"] .ai-orb.listening .orb-inner {
  box-shadow: 0 0 90px rgba(16, 185, 129, 0.9), 0 0 140px rgba(16, 185, 129, 0.6);
}

/* Light theme adjustments */
[data-theme="light"] .voice-chat-overlay {
  background-color: rgba(255, 255, 255, 0.92);
}

[data-theme="light"] .voice-chat-modal {
  box-shadow: 0 -10px 60px rgba(0, 0, 0, 0.1);
  border-top: 1px solid var(--border-color);
}

[data-theme="light"] .ai-orb .orb-inner {
  box-shadow: 0 0 50px rgba(16, 185, 129, 0.4), 0 0 90px rgba(16, 185, 129, 0.2);
}

[data-theme="light"] .ai-orb.speaking .orb-inner {
  box-shadow: 0 0 70px rgba(245, 158, 11, 0.6), 0 0 110px rgba(245, 158, 11, 0.3);
}

[data-theme="light"] .ai-orb.listening .orb-inner {
  box-shadow: 0 0 80px rgba(16, 185, 129, 0.7), 0 0 120px rgba(16, 185, 129, 0.4);
}

/* Responsive */
@media (max-width: 768px) {
  .voice-chat-modal {
    border-top-left-radius: 28px;
    border-top-right-radius: 28px;
  }

  .voice-chat-content {
    padding: 50px 28px 32px;
  }

  .ai-orb {
    width: 180px;
    height: 180px;
  }

  .voice-control-btn {
    width: 80px;
    height: 80px;
  }

  .transcript-display,
  .response-display {
    padding: 14px;
    font-size: 0.95rem;
  }

  .voice-chat-close-btn {
    top: 16px;
    right: 16px;
    width: 40px;
    height: 40px;
  }
}

@media (max-width: 480px) {
  .voice-chat-modal {
    border-top-left-radius: 24px;
    border-top-right-radius: 24px;
  }

  .voice-chat-content {
    padding: 50px 20px 28px;
    gap: 20px;
  }

  .ai-orb {
    width: 160px;
    height: 160px;
  }

  .voice-control-btn {
    width: 70px;
    height: 70px;
  }

  .status-text {
    font-size: 1rem;
  }

  .transcript-display,
  .response-display {
    padding: 12px;
    font-size: 0.9rem;
  }

  .voice-chat-close-btn {
    top: 14px;
    right: 14px;
    width: 36px;
    height: 36px;
  }

  .voice-chat-modal::before {
    top: 10px;
    width: 40px;
    height: 4px;
  }
}

/* Mobile - Full screen overlay is now automatically handled by --sidebar-width being 0 on mobile */
- - - VoiceSettings.css:
/* src/css/VoiceSettings.css */

.voice-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
  gap: 14px;
  margin: 12px 0 20px;
}

.voice-card {
  border: 1px solid var(--border-color);
  border-radius: 14px;
  padding: 14px;
  background: var(--button-hover-bg);
  transition: transform 0.18s ease, box-shadow 0.18s ease, border-color 0.18s ease;
  cursor: pointer;
}

.voice-card.selected {
  border-color: #19c37d;
  box-shadow: 0 6px 24px rgba(25,195,125,0.25);
}

.voice-card:hover { transform: translateY(-2px); }

.voice-card-header { display: flex; align-items: center; gap: 10px; }
.voice-card-header h4 { margin: 0; font-weight: 600; }

.voice-gender {
  width: 10px; height: 10px; border-radius: 50%;
  background: #64748b;
}
.voice-gender.female { background: #ec4899; }
.voice-gender.male   { background: #3b82f6; }

.voice-desc { margin: 8px 0 12px; color: var(--secondary-text-color); font-size: 0.9rem; }

.voice-actions { display: flex; justify-content: space-between; align-items: center; gap: 10px; }
.preview-btn {
  display: inline-flex; align-items: center; gap: 6px;
  border: 1px solid var(--border-color);
  background: var(--main-bg-color);
  color: var(--primary-text-color);
  padding: 6px 10px; border-radius: 10px; cursor: pointer;
}
.preview-btn:hover { background: var(--button-hover-bg); }
.select-radio { display: inline-flex; align-items: center; gap: 6px; }

.voice-sliders { display: grid; grid-template-columns: repeat(2, 1fr); gap: 16px; margin-bottom: 12px; }
.slider-group label { display: flex; justify-content: space-between; margin-bottom: 6px; color: var(--secondary-text-color); }
.slider-group input[type="range"] { width: 100%; }

@media (max-width: 768px) {
  .voice-grid { grid-template-columns: 1fr; }
  .voice-sliders { grid-template-columns: 1fr; }
}
- - index.css:
/* src/index.css */
/* * {
  outline: 1px solid red;
} */

/* Remove mobile tap highlight (blue rectangles) */
* {
  -webkit-tap-highlight-color: transparent;
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

/* Allow text selection where needed */
input, textarea, [contenteditable] {
  -webkit-user-select: text;
  -moz-user-select: text;
  -ms-user-select: text;
  user-select: text;
}

/* Basic reset and font setup */
body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  transition: background-color 0.3s ease, color 0.3s ease;
}

/* 
  Remove default button styling to let components handle it.
  This prevents conflicts with your custom .sidebar-button styles.
*/
button {
  border: none;
  margin: 0;
  padding: 0;
  width: auto;
  overflow: visible;
  background: transparent;
  color: inherit;
  font: inherit;
  line-height: normal;
  cursor: pointer;
  transition: all 0.2s ease;
}

/* Basic link styling */
a {
  color: inherit;
  text-decoration: none;
}

/* Remove list styles */
ul, ol {
  list-style: none;
  padding: 0;
  margin: 0;
}
- - main.tsx:
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import { BrowserRouter } from 'react-router-dom';
import './index.css'
import App from './App.tsx'
import { SettingsProvider } from './contexts/SettingsContext.tsx'
import { NotificationProvider } from './contexts/NotificationContext.tsx'
import { NavigationProvider } from './contexts/NavigationContext.tsx'

// --- PRODUCTION LOGGING SUPPRESSION ---
if (import.meta.env.PROD) {
  // Save the original error logger just in case you need it for a monitoring service (like Sentry)
  // const originalError = console.error;

  // Override console methods to do nothing in production
  console.log = () => {};
  console.info = () => {};
  console.debug = () => {};
  console.warn = () => {};
  
  // Optionally suppress errors too, though usually not recommended:
  // console.error = () => {};
}

if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('/sw.js')
      .then(registration => {
        // This log will now automatically be suppressed in PROD
        console.log('SW registered with scope: ', registration.scope);
      })
      .catch(registrationError => {
        // Errors are usually preserved
        console.error('SW registration failed: ', registrationError);
      });
  });
}

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <BrowserRouter>
      <NotificationProvider>
        <SettingsProvider>
          <NavigationProvider>
            <App />
          </NavigationProvider>
        </SettingsProvider>
      </NotificationProvider>
    </BrowserRouter>
  </StrictMode>,
)
- - pages/
- - - AuthPage.tsx:
// src/pages/AuthPage.tsx
import { useState, type FormEvent, useEffect } from 'react';
import { useSettings } from '../contexts/SettingsContext';
import { Link } from 'react-router-dom';
import '../css/AuthPage.css';

const AuthPage = () => {
  const [isLogin, setIsLogin] = useState(true);
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const { login, register, isAuthenticated } = useSettings();
  const [isFading, setIsFading] = useState(false);

  useEffect(() => {
    if (isAuthenticated) {
      // Redirect handled by router
    }
  }, [isAuthenticated]);

  const handleSubmit = async (e: FormEvent) => {
    e.preventDefault();
    setError('');
    
    if (!email || !password) {
      setError('Email and password are required.');
      return;
    }

    setIsLoading(true);
    
    try {
      if (isLogin) {
        await login(email, password);
      } else {
        await register(email, password);
      }
    } catch (err: any) {
      setError(err.message || 'An error occurred.');
      setIsLoading(false);
    }
  };

  const handleToggleForm = () => {
    setError('');
    setIsFading(true);
    setTimeout(() => {
      setIsLogin(prev => !prev);
      setIsFading(false);
    }, 300);
  };

  return (
    <div className="auth-container">
      <div className="auth-background">
        <div className="circle circle-1"></div>
        <div className="circle circle-2"></div>
        <div className="circle circle-3"></div>
      </div>
      
      <div className={`auth-form-wrapper ${isFading ? 'fading' : ''}`}>
        {/* --- START OF THE FIX --- */}
        <img src="/worksparkai.svg" alt="Workspark AI Logo" className="auth-logo" />
        {/* --- END OF THE FIX --- */}
        <h2 className="auth-subtitle">{isLogin ? 'Welcome Back' : 'Create Account'}</h2>
        
        <form onSubmit={handleSubmit}>
          {error && <p className="auth-error">{error}</p>}
          <div className="auth-form-group">
            <label htmlFor="email">Email</label>
            <input
              type="email"
              id="email"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              required
              disabled={isLoading}
            />
          </div>
          <div className="auth-form-group">
            <label htmlFor="password">Password</label>
            <input
              type="password"
              id="password"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              required
              disabled={isLoading}
            />
          </div>
          
          {isLogin && (
            <div style={{ textAlign: 'right', marginBottom: '16px' }}>
              <Link 
                to="/forgot-password" 
                style={{ 
                  color: 'var(--accent-primary)', 
                  fontSize: '14px',
                  textDecoration: 'none',
                  fontWeight: '500'
                }}
              >
                Forgot Password?
              </Link>
            </div>
          )}
          
          <button type="submit" className="auth-button" disabled={isLoading}>
            {isLoading ? (
              <div className="auth-loader"></div>
            ) : isLogin ? (
              'Login'
            ) : (
              'Register'
            )}
          </button>
        </form>

        <p className="auth-toggle">
          {isLogin ? "Don't have an account?" : 'Already have an account?'}
          <button onClick={handleToggleForm} disabled={isLoading}>
            {isLogin ? 'Register' : 'Login'}
          </button>
        </p>
      </div>
    </div>
  );
};

export default AuthPage;
- - - ChatPage.tsx:
// src/pages/ChatPage.tsx
import { useEffect } from 'react';
import { useParams } from 'react-router-dom';
import { useChat } from '../contexts/ChatContext';
import ChatView from '../components/ChatView';

const ChatPage = () => {
  const { 
    messages, 
    activeChatId, 
    loadChat, 
    clearChat, 
    isLoadingChat, 
    isCreatingChat,
    isThinkingEnabled,
    toggleThinking,
    isSending,
    isThinking,
    sendMessage,
    stopGeneration, // <-- NEW

    isStreaming, 
    editingIndex, 
    startEditing, 
    cancelEditing, 
    saveAndSubmitEdit, 
    regenerateResponse,
  } = useChat();
  
  const { chatId } = useParams<{ chatId: string }>();

  useEffect(() => {
    if (isCreatingChat) return;
    if (chatId && chatId !== activeChatId) {
      loadChat(chatId);
      return;
    }
    if (!chatId && activeChatId) {
      clearChat();
    }
  }, [chatId, activeChatId, isCreatingChat, loadChat, clearChat]);

  return (
    <ChatView 
      messages={messages}
      isThinkingEnabled={isThinkingEnabled}
      toggleThinkingEnabled={toggleThinking}
      activeChatId={activeChatId}
      isStreaming={isStreaming}
      isLoading={isLoadingChat}
      isSending={isSending}
      isThinking={isThinking}
      onSendMessage={sendMessage}
      onStopGeneration={stopGeneration} // <-- NEW
      onRegenerate={regenerateResponse}
      editingIndex={editingIndex}
      onStartEdit={startEditing}
      onCancelEdit={cancelEditing}
      onSaveEdit={saveAndSubmitEdit}
    />
  );
};

export default ChatPage;
- - - ForgotPasswordPage.tsx:
// src/pages/ForgotPasswordPage.tsx
import { useState, type FormEvent } from 'react';
import { Link } from 'react-router-dom';
import { API_BASE_URL } from '../utils/api';
import '../css/AuthPage.css';

const ForgotPasswordPage = () => {
  const [email, setEmail] = useState('');
  const [message, setMessage] = useState('');
  const [error, setError] = useState('');
  const [isLoading, setIsLoading] = useState(false);

  const handleSubmit = async (e: FormEvent) => {
    e.preventDefault();
    setError('');
    setMessage('');
    
    if (!email) {
      setError('Email is required.');
      return;
    }

    setIsLoading(true);
    
    try {
      const res = await fetch(`${API_BASE_URL}/api/auth/forgot-password`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ email }),
      });
      
      const data = await res.json();
      
      if (!res.ok) {
        throw new Error(data.error || 'Failed to send reset email');
      }
      
      setMessage(data.message);
      setEmail(''); // Clear the form
    } catch (err: any) {
      setError(err.message || 'An error occurred.');
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="auth-container">
      <div className="auth-background">
        <div className="circle circle-1"></div>
        <div className="circle circle-2"></div>
        <div className="circle circle-3"></div>
      </div>
      
      <div className="auth-form-wrapper">
        <img src="/worksparkai.svg" alt="Workspark AI Logo" className="auth-logo" />
        <h2 className="auth-subtitle">Reset Your Password</h2>
        <p style={{ 
          color: 'var(--text-secondary)', 
          fontSize: '14px', 
          marginBottom: '20px',
          textAlign: 'center' 
        }}>
          Enter your email address and we'll send you a link to reset your password.
        </p>
        
        <form onSubmit={handleSubmit}>
          {error && (
            <div style={{
              padding: '12px',
              marginBottom: '16px',
              backgroundColor: '#fee',
              border: '1px solid #fcc',
              borderRadius: '8px',
              color: '#c33',
              fontSize: '14px'
            }}>
              {error}
            </div>
          )}
          
          {message && (
            <div style={{
              padding: '12px',
              marginBottom: '16px',
              backgroundColor: '#efe',
              border: '1px solid #cfc',
              borderRadius: '8px',
              color: '#3c3',
              fontSize: '14px'
            }}>
              {message}
            </div>
          )}
          
          <div className="auth-form-group">
            <label htmlFor="email">Email Address</label>
            <input
              type="email"
              id="email"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              placeholder="your@email.com"
              required
              disabled={isLoading}
            />
          </div>
          
          <button type="submit" className="auth-button" disabled={isLoading}>
            {isLoading ? (
              <div className="auth-loader"></div>
            ) : (
              'Send Reset Link'
            )}
          </button>
        </form>

        <div style={{ marginTop: '20px', textAlign: 'center' }}>
          <Link 
            to="/login" 
            style={{ 
              color: 'var(--accent-primary)', 
              textDecoration: 'none',
              fontSize: '14px',
              fontWeight: '500'
            }}
          >
            ← Back to Login
          </Link>
        </div>
      </div>
    </div>
  );
};

export default ForgotPasswordPage;
- - - LandingPage.tsx:
// FexoApp/src/pages/LandingPage.tsx
import { useEffect, useRef, useState } from 'react';
import { Link } from 'react-router-dom';
import LandingNav from '../components/LandingNav';
import { FiCode, FiSearch, FiFileText, FiShare2, FiArrowRight } from 'react-icons/fi';
import '../css/LandingPage.css';

const features = [
  {
    icon: <FiCode />,
    title: 'Stateful Code Interpreter',
    description: 'Go beyond chat. Execute Python code in a persistent, stateful environment. Perfect for data analysis, prototyping, and complex problem-solving.',
  },
  {
    icon: <FiSearch />,
    title: 'Live Web Research',
    description: 'Stay up-to-date with integrated Google Search for both text and images. Get current information, find data, and see the world without leaving your chat.',
  },
  {
    icon: <FiFileText />,
    title: 'Intelligent Document Analysis',
    description: "Instantly extract and understand insights from your documents. Workspark AI can read and analyze PDF and PowerPoint files, summarizing content on demand.",
  },
  {
    icon: <FiShare2 />,
    title: 'Multi-Model Freedom',
    description: "Don't get locked in. Bring your own API key for OpenAI, Anthropic, Gemini, or any compatible endpoint. You have full control over your tools.",
  },
];

const steps = [
  {
    icon: '💬',
    title: 'Start with a Prompt',
    description: 'Describe your task, ask a question, or upload your files. Use natural language to explain what you need.',
  },
  {
    icon: '🧠',
    title: 'AI Analyzes & Plans',
    description: 'Workspark AI interprets your request and determines the best tools for the job, whether it\'s running code, searching the web, or analyzing a document.',
  },
  {
    icon: '🛠️',
    title: 'Tools Are Executed',
    description: 'The AI transparently uses its tools. Watch as it writes and runs Python code, pulls live data, or extracts text from your PDFs.',
  },
  {
    icon: '📊',
    title: 'Receive Your Results',
    description: 'Get your answer, generated data, plots, or files, all within the same conversational interface. Iterate and refine as needed.',
  },
];

const useCases = [
    {
        title: "Data Scientists",
        description: "Quickly clean, analyze, and visualize datasets without switching contexts. Prototype models and generate plots on the fly.",
        color: "hsla(210, 80%, 70%, 1)"
    },
    {
        title: "Developers",
        description: "Scaffold new projects, debug code snippets, and interact with APIs using the persistent Python environment.",
        color: "hsla(145, 63%, 60%, 1)"
    },
    {
        title: "Researchers & Students",
        description: "Summarize research papers, extract data from PDFs, and perform web searches to gather information for your projects.",
        color: "hsla(300, 70%, 70%, 1)"
    }
];

// A hook for the typing effect
const useTypingEffect = (text: string, duration: number, startDelay: number) => {
    const [typedText, setTypedText] = useState('');
    const [hasStarted, setHasStarted] = useState(false);

    useEffect(() => {
        const startTimer = setTimeout(() => {
            setHasStarted(true);
        }, startDelay);

        return () => clearTimeout(startTimer);
    }, [startDelay]);
    
    useEffect(() => {
        if (hasStarted && text) {
            setTypedText('');
            let i = 0;
            const interval = setInterval(() => {
                if(i < text.length) {
                    setTypedText(prev => prev + text.charAt(i));
                    i++;
                } else {
                    clearInterval(interval);
                }
            }, duration / text.length);
            return () => clearInterval(interval);
        }
    }, [text, duration, hasStarted]);

    return typedText;
};


const LandingPage = () => {
  const sectionsRef = useRef<(HTMLElement | null)[]>([]);

  // Typing effect for the hero subtitle
  const heroSubtitleText = "A seamless fusion of large language models and powerful development tools. Analyze data, search the web, and build with a persistent coding environment at your fingertips.";
  const typedSubtitle = useTypingEffect(heroSubtitleText, 2000, 500);


  useEffect(() => {
    // --- START OF THE FIX ---
    // Capture the current sections in a local variable.
    const currentSections = sectionsRef.current;

    const observer = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            entry.target.classList.add('visible');
            observer.unobserve(entry.target);
          }
        });
      },
      { threshold: 0.1 }
    );

    // Use the local variable to set up the observers.
    currentSections.forEach((section) => {
      if (section) observer.observe(section);
    });

    // Use the same local variable in the cleanup function.
    return () => {
      currentSections.forEach((section) => {
        if (section) observer.unobserve(section);
      });
    };
    // --- END OF THE FIX ---
  }, []);

  return (
    <div className="landing-page">
      <LandingNav />
      
      <main>
        <section className="hero-section" ref={(el) => { sectionsRef.current[0] = el; }}>
          <div className="hero-background-aurora"></div>
          <div className="hero-content">
            <h1 className="hero-title">The AI Copilot That Actually Builds With You</h1>
            <p className="hero-subtitle">
              {typedSubtitle}
              <span className="typing-cursor">|</span>
            </p>
            <div className="hero-cta">
              <Link to="/register" className="cta-button">
                Get Started for Free <FiArrowRight />
              </Link>
            </div>
          </div>
        </section>

        <section className="features-section" id="features" ref={(el) => { sectionsRef.current[1] = el; }}>
          <h2 className="section-title">A Toolkit for Modern Development</h2>
          <p className="section-subtitle">Everything you need, integrated and intelligent.</p>
          <div className="features-grid">
            {features.map((feature, index) => (
              <div key={index} className="feature-card" ref={(el) => { sectionsRef.current[2 + index] = el; }}>
                <div className="feature-icon">{feature.icon}</div>
                <h3 className="feature-title">{feature.title}</h3>
                <p className="feature-description">{feature.description}</p>
              </div>
            ))}
          </div>
        </section>
        
        <section className="how-it-works-section" ref={(el) => { sectionsRef.current[6] = el; }}>
            <h2 className="section-title">Simple Workflow, Powerful Results</h2>
            <p className="section-subtitle">Four steps from idea to execution.</p>
            <div className="timeline">
                {steps.map((step, index) => (
                    <div key={index} className="timeline-item" ref={(el) => { sectionsRef.current[7 + index] = el; }}>
                        <div className="timeline-icon">{step.icon}</div>
                        <div className="timeline-content">
                            <h3 className="timeline-title">{step.title}</h3>
                            <p className="timeline-description">{step.description}</p>
                        </div>
                    </div>
                ))}
            </div>
        </section>

        <section className="use-cases-section" ref={(el) => { sectionsRef.current[11] = el; }}>
          <h2 className="section-title">Designed For Doers</h2>
          <p className="section-subtitle">Whether you're a developer, analyst, or researcher, Workspark accelerates your workflow.</p>
          <div className="use-cases-grid">
            {useCases.map((useCase, index) => (
              <div key={index} className="use-case-card" style={{ '--glow-color': useCase.color } as React.CSSProperties} ref={(el) => { sectionsRef.current[12 + index] = el; }}>
                <div className="use-case-glow"></div>
                <h3 className="use-case-title">{useCase.title}</h3>
                <p className="use-case-description">{useCase.description}</p>
              </div>
            ))}
          </div>
        </section>

        <section className="cta-section" ref={(el) => { sectionsRef.current[15] = el; }}>
            <h2 className="section-title">Ready to build faster?</h2>
            <p className="section-subtitle">
                Sign up now and experience a more powerful way to interact with AI.
            </p>
            <Link to="/register" className="cta-button">
                Create Your Account <FiArrowRight />
            </Link>
        </section>
      </main>

      <footer className="landing-footer">
          <p>&copy; {new Date().getFullYear()} Workspark AI. All rights reserved.</p>
      </footer>
    </div>
  );
};

export default LandingPage;
- - - MainAppLayout.tsx:
// src/pages/MainAppLayout.tsx
import { useEffect, useState, Suspense } from 'react';
import { Outlet, useNavigate, useLocation } from 'react-router-dom';
import Sidebar from '../components/Sidebar';
import SettingsModal from '../components/SettingsModal';
import Notification from '../components/Notification';
import { ChatProvider } from '../contexts/ChatContext';
import { SidePanelProvider } from '../contexts/SidePanelContext'; 
import SidePanel from '../components/SidePanel'; 
import MobileHeader from '../components/MobileHeader';
import '../css/MobileHeader.css';
import SubscriptionSuccessOverlay from '../components/SubscriptionSuccessOverlay';
import '../css/SubscriptionSuccessOverlay.css';

const RouteFallback = () => (
  <div style={{
    display: 'flex',
    justifyContent: 'center',
    alignItems: 'center',
    width: '100%',
    height: '100%'
  }}>
    <div className="bouncing-loader">
      <div></div>
      <div></div>
      <div></div>
    </div>
  </div>
);

const MainAppLayout = () => {
  const [isSettingsOpen, setIsSettingsOpen] = useState(false);
  const [isMobileSidebarOpen, setMobileSidebarOpen] = useState(false);
  const [isSidebarCollapsed, setIsSidebarCollapsed] = useState(false);
  const [showSubOverlay, setShowSubOverlay] = useState(false);
  const navigate = useNavigate();
  const location = useLocation();

  useEffect(() => {
    const params = new URLSearchParams(location.search);
    if (params.has('sub_success')) {
      setShowSubOverlay(true);
      const cleanPath = location.pathname;
      navigate(cleanPath, { replace: true });
    }
  }, [location.search, location.pathname, navigate]);

  return (
    <>
      {showSubOverlay && (
        <SubscriptionSuccessOverlay onClose={() => setShowSubOverlay(false)} />
      )}
      
      <ChatProvider>
        <SidePanelProvider>
          <Notification />
          <SidePanel /> 

          <MobileHeader 
            onToggleSidebar={() => setMobileSidebarOpen(true)}
            onNewChat={() => {
              navigate('/app');
              setMobileSidebarOpen(false);
            }}
          />
          <div className="app-container">
            <Sidebar 
              onOpenSettings={() => setIsSettingsOpen(true)} 
              isMobileOpen={isMobileSidebarOpen}
              onClose={() => setMobileSidebarOpen(false)}
              isCollapsed={isSidebarCollapsed}
              onToggleCollapse={() => setIsSidebarCollapsed(prev => !prev)}
            />
            <Suspense fallback={<RouteFallback />}>
              <Outlet />
            </Suspense>
          </div>
          <SettingsModal
            isOpen={isSettingsOpen}
            onClose={() => setIsSettingsOpen(false)}
          />
        </SidePanelProvider>
      </ChatProvider>
    </>
  );
};

export default MainAppLayout;
- - - PricingPage.tsx:
// src/pages/PricingPage.tsx
import { useState } from 'react';
import { loadStripe } from '@stripe/stripe-js';
import { useSettings } from '../contexts/SettingsContext';
import { useNotification } from '../contexts/NotificationContext';
import '../css/PricingPage.css';
import { FiCheckCircle } from 'react-icons/fi';
import api from '../utils/api';
import { fetchPublicConfig } from '../utils/config';

const PricingPage = () => {
  const { user } = useSettings();
  const { showNotification } = useNotification();
  const [isLoading, setIsLoading] = useState(false);

  const plans = [
    {
      name: 'Free',
      price: '$0',
      features: [
        'Standard default model',
        'Code Interpreter & File Analysis',
        'Web Search capabilities',
        'Bring your own API keys',
        'Community support',
      ],
      isCurrent: !user?.subscriptionStatus || user.subscriptionStatus !== 'active',
    },
    {
      name: 'Pro',
      price: '$18',
      priceId: 'price_1S98QdJHhdy0TngLXWUWBrzD',
      features: [
        'Premium default model (GPT-5)',
        'Code Interpreter & File Analysis',
        'Web Search capabilities',
        'Bring your own API keys',
        'Voice chat included',
        'Priority support',
      ],
      isCurrent: user?.subscriptionStatus === 'active',
    },
  ];

  const handleSubscribe = async (priceId: string) => {
    if (!priceId) return;
    setIsLoading(true);
    try {
      const publishableKey = (import.meta as any).env?.VITE_STRIPE_PUBLISHABLE_KEY || (await fetchPublicConfig()).stripePublicKey;
      if (!publishableKey) throw new Error('Stripe publishable key is missing.');
      const response = await api('/stripe/create-checkout-session', {
        method: 'POST',
        body: JSON.stringify({ priceId }),
      });
      const data = await response.json();
      if (!response.ok) throw new Error(data.msg || 'Could not start subscription.');
      const stripe = await loadStripe(publishableKey);
      if (stripe) {
        await stripe.redirectToCheckout({ sessionId: data.sessionId });
      }
    } catch (error) {
      showNotification(error instanceof Error ? error.message : 'An unknown error occurred.', 'error');
      setIsLoading(false);
    }
  };

  return (
    <div className="pricing-page-container">
      <div className="pricing-header">
        <h1>Choose Your Plan</h1>
        <p>Unlock powerful features and accelerate your workflow with Workspark AI Pro.</p>
      </div>
      <div className="pricing-grid">
        {plans.map((plan) => (
          <div key={plan.name} className={`pricing-card ${plan.name === 'Pro' ? 'pro' : ''} ${plan.isCurrent ? 'current' : ''}`}>
            <h3>{plan.name}</h3>
            <div className="price">
              {plan.price}<span>{plan.name === 'Pro' ? '/ month' : ''}</span>
            </div>
            <ul className="features-list">
              {plan.features.map((feature, i) => (
                <li key={i}><FiCheckCircle /> {feature}</li>
              ))}
            </ul>
            <button
              className="subscribe-button"
              disabled={isLoading || plan.isCurrent || !plan.priceId}
              onClick={() => plan.priceId && handleSubscribe(plan.priceId)}
            >
              {plan.isCurrent ? 'Current Plan' : (plan.priceId ? 'Upgrade to Pro' : 'Your Plan')}
            </button>
          </div>
        ))}
      </div>
    </div>
  );
};

export default PricingPage;
- - - ResetPasswordPage.tsx:
// src/pages/ResetPasswordPage.tsx
import { useState, type FormEvent, useEffect } from 'react';
import { useNavigate, useSearchParams, Link } from 'react-router-dom';
import { API_BASE_URL } from '../utils/api';
import '../css/AuthPage.css';

const ResetPasswordPage = () => {
  const [searchParams] = useSearchParams();
  const navigate = useNavigate();
  const [password, setPassword] = useState('');
  const [confirmPassword, setConfirmPassword] = useState('');
  const [message, setMessage] = useState('');
  const [error, setError] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [token, setToken] = useState<string | null>(null);

  useEffect(() => {
    const tokenFromUrl = searchParams.get('token');
    if (!tokenFromUrl) {
      setError('Invalid reset link. Please request a new password reset.');
    } else {
      setToken(tokenFromUrl);
    }
  }, [searchParams]);

  const handleSubmit = async (e: FormEvent) => {
    e.preventDefault();
    setError('');
    setMessage('');
    
    if (!password || !confirmPassword) {
      setError('Both password fields are required.');
      return;
    }

    if (password.length < 6) {
      setError('Password must be at least 6 characters long.');
      return;
    }

    if (password !== confirmPassword) {
      setError('Passwords do not match.');
      return;
    }

    if (!token) {
      setError('Invalid reset token.');
      return;
    }

    setIsLoading(true);
    
    try {
      const res = await fetch(`${API_BASE_URL}/api/auth/reset-password`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ token, password }),
      });
      
      const data = await res.json();
      
      if (!res.ok) {
        throw new Error(data.error || 'Failed to reset password');
      }
      
      setMessage('Password reset successful! Redirecting to login...');
      
      // Redirect to login after 2 seconds
      setTimeout(() => {
        navigate('/login');
      }, 2000);
    } catch (err: any) {
      setError(err.message || 'An error occurred.');
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="auth-container">
      <div className="auth-background">
        <div className="circle circle-1"></div>
        <div className="circle circle-2"></div>
        <div className="circle circle-3"></div>
      </div>
      
      <div className="auth-form-wrapper">
        <img src="/worksparkai.svg" alt="Workspark AI Logo" className="auth-logo" />
        <h2 className="auth-subtitle">Set New Password</h2>
        <p style={{ 
          color: 'var(--text-secondary)', 
          fontSize: '14px', 
          marginBottom: '20px',
          textAlign: 'center' 
        }}>
          Please enter your new password below.
        </p>
        
        <form onSubmit={handleSubmit}>
          {error && (
            <div style={{
              padding: '12px',
              marginBottom: '16px',
              backgroundColor: '#fee',
              border: '1px solid #fcc',
              borderRadius: '8px',
              color: '#c33',
              fontSize: '14px'
            }}>
              {error}
            </div>
          )}
          
          {message && (
            <div style={{
              padding: '12px',
              marginBottom: '16px',
              backgroundColor: '#efe',
              border: '1px solid #cfc',
              borderRadius: '8px',
              color: '#3c3',
              fontSize: '14px'
            }}>
              ✓ {message}
            </div>
          )}
          
          <div className="auth-form-group">
            <label htmlFor="password">New Password</label>
            <input
              type="password"
              id="password"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              placeholder="At least 6 characters"
              required
              disabled={isLoading || !token}
              minLength={6}
            />
          </div>
          
          <div className="auth-form-group">
            <label htmlFor="confirmPassword">Confirm Password</label>
            <input
              type="password"
              id="confirmPassword"
              value={confirmPassword}
              onChange={(e) => setConfirmPassword(e.target.value)}
              placeholder="Re-enter your password"
              required
              disabled={isLoading || !token}
              minLength={6}
            />
          </div>
          
          <button 
            type="submit" 
            className="auth-button" 
            disabled={isLoading || !token}
          >
            {isLoading ? (
              <div className="auth-loader"></div>
            ) : (
              'Reset Password'
            )}
          </button>
        </form>

        <div style={{ marginTop: '20px', textAlign: 'center' }}>
          <Link 
            to="/login" 
            style={{ 
              color: 'var(--accent-primary)', 
              textDecoration: 'none',
              fontSize: '14px',
              fontWeight: '500'
            }}
          >
            ← Back to Login
          </Link>
        </div>
      </div>
    </div>
  );
};

export default ResetPasswordPage;
- - routing/
- - - PrivateRoute.tsx:
// 📁 src/routing/PrivateRoute.tsx
import { type ReactNode } from 'react';
import { Navigate } from 'react-router-dom';
import { useSettings } from '../contexts/SettingsContext';

const PrivateRoute = ({ children }: { children: ReactNode }) => {
  const { isAuthenticated, loading } = useSettings();

  if (loading) {
    // Return a simple div that will be styled by App.css to be a full-screen background.
    // This respects the user's theme (dark/light) from the start.
    return <div className="initial-loading-screen"></div>;
  }

  return isAuthenticated ? children : <Navigate to="/login" />;
};

export default PrivateRoute;
- - types/
- - - index.ts:
// src/types/index.ts

export type Attachment = {
  _id: string; 
  fileName: string;
  gcsObjectName: string;
  mimeType: string;
  size: number;
};

// Represents a file generated by the code interpreter
export type FileOutput = {
  fileName: string;
  mimeType: string;
  url: string; // A direct, signed URL to the file in cloud storage
  gcsObjectName?: string; // Stored in DB, available on loaded chats
};

export type Message = {
  role: 'user' | 'assistant' | 'tool_code_result' | 'tool_code' | 'tool_search_result' | 'tool_search' | 'tool_doc_extract' | 'tool_doc_extract_result' | 'tool_integration' | 'tool_integration_result' | 'tool_geolocation' | 'tool_geolocation_result';
  content: string | null;
  attachments?: Attachment[];
  tool_id?: string;
  state?: 'writing' | 'ready_to_execute' | 'executing' | 'completed' | 'error' | 'searching' | 'searched' | 'analyzing' | null;
  thinking?: string;
  fileOutputs?: FileOutput[];
  isWaiting?: boolean;
  isClientSideTool?: boolean;
  tool_name?: string;
  tool_arguments?: any;
  // --- START OF THE FIX ---
  // Replaced the incomplete inline type with the full GoogleMapsData type.
  integrationData?: GoogleMapsData;
  // --- END OF THE FIX ---
};

// Represents a geographical point with an address for Google Maps
type MapLocation = {
  lat: number;
  lng: number;
  address: string;
};

// Represents the rectangular bounds of a map view
type MapBounds = {
  southwest: { lat: number; lng: number; };
  northeast: { lat: number; lng: number; };
};

/**
 * Represents the data structure for the Google Maps directions integration.
 * This is typically generated by a server-side tool call.
 */
export type GoogleMapsData = {
  type: 'google_maps_route';
  start: MapLocation;
  end: MapLocation;
  bounds: MapBounds;
  polyline: string; // The encoded polyline string from Google Directions API
  distance: { text: string; value: number };
  duration: { text: string; value: number };
  steps: any[];
};
- - utils/
- - - api.ts:
// src/utils/api.ts

export const API_BASE_URL = import.meta.env.VITE_API_URL || 
  (import.meta.env.DEV ? 'http://localhost:3001' : 'https://worksparkaiserver-215678188656.europe-west1.run.app');

/**
 * A wrapper around the native `fetch` function that automatically adds
 * the 'Content-Type' and 'x-auth-token' headers for authenticated JSON requests.
 * @param endpoint The API endpoint (e.g., '/settings')
 * @param options The standard fetch options object
 * @returns A Promise that resolves to the Response object
 */
export const api = async (endpoint: string, options: RequestInit = {}): Promise<Response> => {
  const token = localStorage.getItem('fexo-token');

  const headers = new Headers(options.headers || {});

  // Set default content type if not already provided and there's a body
  if (options.body && !headers.has('Content-Type')) {
    headers.set('Content-Type', 'application/json');
  }

  // Add the auth token to the headers if it exists
  if (token) {
    headers.set('x-auth-token', token);
  }

  const config: RequestInit = {
    ...options,
    headers,
  };

  // Log the request details (will be auto-suppressed in PROD via main.tsx)
  const method = (config.method || 'GET').toString().toUpperCase();
  const hasBody = !!config.body;
  
  // Use console.debug for verbose API logs
  console.debug('[API Request] →', method, `/api${endpoint}`, { hasBody, headers: Object.fromEntries(headers) });

  try {
    const resp = await fetch(`${API_BASE_URL}/api${endpoint}`, config);
    console.debug('[API Response] ←', resp.status, resp.statusText, `/api${endpoint}`);
    return resp;
  } catch (error) {
    console.error('[API Error]', method, endpoint, error);
    throw error;
  }
};

/**
 * A dedicated function for uploading a single file using FormData.
 * @param file The file object to upload.
 * @returns A Promise that resolves to the JSON response from the server.
 */
export const uploadFile = async (file: File): Promise<any> => {
  const formData = new FormData();
  formData.append('file', file); // 'file' must match the key in multer's upload.single('file')

  const token = localStorage.getItem('fexo-token');
  const headers = new Headers();
  if (token) {
    headers.set('x-auth-token', token);
  }

  console.debug('[API Upload] → POST /api/files/upload', file.name);

  const response = await fetch(`${API_BASE_URL}/api/files/upload`, {
    method: 'POST',
    headers: headers, // NOTE: Do NOT set Content-Type, the browser does it for FormData
    body: formData,
  });

  if (!response.ok) {
    const errorData = await response.json().catch(() => ({ error: 'Upload failed' }));
    throw new Error(errorData.error || 'Failed to upload file');
  }

  console.debug('[API Upload] ← Success', file.name);
  return response.json();
};

export default api;
- - - config.ts:
// src/utils/config.ts
// All public config is now provided via Vite environment variables at build time
// No runtime config fetching needed - more secure and faster

export type PublicConfig = {
  googleMapsApiKey?: string;
  stripePublicKey?: string;
  [key: string]: any;
};

export async function fetchPublicConfig(): Promise<PublicConfig> {
  // Return config from Vite environment variables (baked in at build time)
  return {
    googleMapsApiKey: (import.meta as any).env?.VITE_GOOGLE_MAPS_API_KEY || '',
    stripePublicKey: (import.meta as any).env?.VITE_STRIPE_PUBLISHABLE_KEY || '',
  };
}
- - - fileIcons.tsx:
/// <reference types="vite/client" />

// Even with the new JSX transform, explicit type annotations like `JSX.Element`
// require the `JSX` namespace to be in scope. We import it directly here.
import type { JSX } from 'react';
import {
  FiFile, FiFileText, FiImage, FiCode, FiArchive, FiMusic, FiFilm
} from 'react-icons/fi';
import {
  BsFileEarmarkPdf, BsFileEarmarkWord, BsFileEarmarkPpt, BsFileEarmarkSpreadsheet,
  BsMarkdown,
} from 'react-icons/bs';

/**
 * Returns a React Icon component based on the file's MIME type.
 * @param mimeType The MIME type of the file (e.g., 'application/pdf').
 * @returns A JSX.Element representing the file icon.
 */
export const getFileIcon = (mimeType: string): JSX.Element => {
  if (!mimeType) return <FiFile />;

  // Image Types
  if (mimeType.startsWith('image/')) return <FiImage />;

  // Video Types
  if (mimeType.startsWith('video/')) return <FiFilm />;

  // Audio Types
  if (mimeType.startsWith('audio/')) return <FiMusic />;

  // Application & Text Specific Types
  switch (mimeType) {
    // Documents
    case 'application/pdf':
      return <BsFileEarmarkPdf />;
    case 'application/msword':
    case 'application/vnd.openxmlformats-officedocument.wordprocessingml.document':
      return <BsFileEarmarkWord />;
    case 'application/vnd.ms-powerpoint':
    case 'application/vnd.openxmlformats-officedocument.presentationml.presentation':
      return <BsFileEarmarkPpt />;
    
    // Spreadsheets
    case 'application/vnd.ms-excel':
    case 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet':
    case 'text/csv':
      return <BsFileEarmarkSpreadsheet />;

    // Archives
    case 'application/zip':
    case 'application/x-rar-compressed':
    case 'application/x-7z-compressed':
    case 'application/x-tar':
      return <FiArchive />;

    // Code & Markup
    case 'application/javascript':
    case 'text/javascript':
    case 'text/x-python':
    case 'application/x-python-code':
    case 'application/json':
    case 'text/html':
    case 'text/css':
      return <FiCode />;
    case 'text/markdown':
      return <BsMarkdown />;

    // Plain Text
    case 'text/plain':
      return <FiFileText />;

    // Fallback for any other specific type
    default:
      return <FiFile />;
  }
};
- - - navigationHelpers.ts:
// src/utils/navigationHelpers.ts

/**
 * Navigation utility functions for live turn-by-turn guidance
 */

export interface Position {
  lat: number;
  lng: number;
}

export interface NavigationStep {
  instructions: string;
  distance: { text: string; value: number };
  duration?: { text: string; value: number };
  start_location: Position;
  end_location: Position;
  maneuver?: string;
}

/**
 * Calculate distance between two coordinates using Haversine formula
 * Returns distance in meters
 */
export function calculateDistance(pos1: Position, pos2: Position): number {
  const R = 6371e3; // Earth's radius in meters
  const φ1 = (pos1.lat * Math.PI) / 180;
  const φ2 = (pos2.lat * Math.PI) / 180;
  const Δφ = ((pos2.lat - pos1.lat) * Math.PI) / 180;
  const Δλ = ((pos2.lng - pos1.lng) * Math.PI) / 180;

  const a =
    Math.sin(Δφ / 2) * Math.sin(Δφ / 2) +
    Math.cos(φ1) * Math.cos(φ2) * Math.sin(Δλ / 2) * Math.sin(Δλ / 2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

  return R * c;
}

/**
 * Calculate bearing from pos1 to pos2 in degrees (0-360)
 */
export function calculateBearing(pos1: Position, pos2: Position): number {
  const φ1 = (pos1.lat * Math.PI) / 180;
  const φ2 = (pos2.lat * Math.PI) / 180;
  const Δλ = ((pos2.lng - pos1.lng) * Math.PI) / 180;

  const y = Math.sin(Δλ) * Math.cos(φ2);
  const x = Math.cos(φ1) * Math.sin(φ2) - Math.sin(φ1) * Math.cos(φ2) * Math.cos(Δλ);
  const θ = Math.atan2(y, x);
  const bearing = ((θ * 180) / Math.PI + 360) % 360;

  return bearing;
}

/**
 * Format distance for display
 */
export function formatDistance(meters: number): string {
  if (meters < 1000) {
    return `${Math.round(meters)} m`;
  }
  return `${(meters / 1000).toFixed(1)} km`;
}

/**
 * Format duration in seconds to human-readable string
 */
export function formatDuration(seconds: number): string {
  if (seconds < 60) {
    return `${Math.round(seconds)} sec`;
  }
  const minutes = Math.floor(seconds / 60);
  if (minutes < 60) {
    return `${minutes} min`;
  }
  const hours = Math.floor(minutes / 60);
  const remainingMinutes = minutes % 60;
  return remainingMinutes > 0 ? `${hours}h ${remainingMinutes}m` : `${hours}h`;
}

/**
 * Determine turn direction from maneuver string
 */
export function getTurnDirection(maneuver?: string): {
  icon: string;
  text: string;
} {
  if (!maneuver) {
    return { icon: '⬆️', text: 'Continue' };
  }

  const lower = maneuver.toLowerCase();
  
  if (lower.includes('left')) {
    if (lower.includes('slight')) return { icon: '↖️', text: 'Slight left' };
    if (lower.includes('sharp')) return { icon: '↰', text: 'Sharp left' };
    return { icon: '⬅️', text: 'Turn left' };
  }
  
  if (lower.includes('right')) {
    if (lower.includes('slight')) return { icon: '↗️', text: 'Slight right' };
    if (lower.includes('sharp')) return { icon: '↱', text: 'Sharp right' };
    return { icon: '➡️', text: 'Turn right' };
  }
  
  if (lower.includes('u-turn') || lower.includes('uturn')) {
    return { icon: '↩️', text: 'U-turn' };
  }
  
  if (lower.includes('merge')) {
    return { icon: '🔀', text: 'Merge' };
  }
  
  if (lower.includes('roundabout') || lower.includes('rotary')) {
    return { icon: '🔄', text: 'Roundabout' };
  }
  
  if (lower.includes('ramp')) {
    return { icon: '↗️', text: 'Take ramp' };
  }
  
  if (lower.includes('fork')) {
    return { icon: '↕️', text: 'Fork' };
  }

  return { icon: '⬆️', text: 'Continue' };
}

/**
 * Extract clean instruction text from HTML
 */
export function cleanInstruction(htmlInstruction: string): string {
  const div = document.createElement('div');
  div.innerHTML = htmlInstruction;
  return div.textContent || div.innerText || '';
}

/**
 * Find current step based on user's position
 */
export function findCurrentStep(
  userPos: Position,
  steps: NavigationStep[],
  currentStepIndex: number
): number {
  // If we're at the last step, stay there
  if (currentStepIndex >= steps.length - 1) {
    return currentStepIndex;
  }

  // Check if we've passed the current step's end location
  const currentStep = steps[currentStepIndex];
  const distanceToStepEnd = calculateDistance(userPos, currentStep.end_location);
  
  // If within 30 meters of step end, move to next step
  if (distanceToStepEnd < 30) {
    return Math.min(currentStepIndex + 1, steps.length - 1);
  }

  return currentStepIndex;
}

/**
 * Check if user is off route
 * Returns true if user is more than 50 meters from the route
 */
export function isOffRoute(
  userPos: Position,
  currentStep: NavigationStep,
  nextStep?: NavigationStep
): boolean {
  const distanceToStepStart = calculateDistance(userPos, currentStep.start_location);
  const distanceToStepEnd = calculateDistance(userPos, currentStep.end_location);
  
  // Check if we're reasonably close to either the start or end of current step
  if (distanceToStepStart < 50 || distanceToStepEnd < 50) {
    return false;
  }

  // Check next step if available
  if (nextStep) {
    const distanceToNextStart = calculateDistance(userPos, nextStep.start_location);
    if (distanceToNextStart < 50) {
      return false;
    }
  }

  // Calculate perpendicular distance to the line between start and end
  // If user is more than 50m perpendicular to the route, they're off route
  const distanceAlongRoute = distanceToStepEnd;
  return distanceAlongRoute > 50;
}

/**
 * Determine notification trigger distance based on speed
 * Returns distance in meters at which to trigger turn notification
 */
export function getNotificationDistance(speedMps: number): number {
  // At low speeds (walking/slow traffic), notify 50m before
  if (speedMps < 5) return 50;
  
  // At moderate speeds (city driving), notify 100m before
  if (speedMps < 15) return 100;
  
  // At high speeds (highway), notify 300m before
  return 300;
}

/**
 * Calculate estimated time of arrival
 */
export function calculateETA(
  remainingDistance: number,
  averageSpeedMps: number
): Date {
  const remainingSeconds = remainingDistance / (averageSpeedMps || 1);
  return new Date(Date.now() + remainingSeconds * 1000);
}

/**
 * Format ETA for display
 */
export function formatETA(eta: Date): string {
  const hours = eta.getHours();
  const minutes = eta.getMinutes();
  const ampm = hours >= 12 ? 'PM' : 'AM';
  const displayHours = hours % 12 || 12;
  const displayMinutes = minutes.toString().padStart(2, '0');
  return `${displayHours}:${displayMinutes} ${ampm}`;
}

/**
 * Calculate speed from position updates
 */
export function calculateSpeed(
  prevPos: Position,
  currentPos: Position,
  timeDeltaMs: number
): number {
  const distance = calculateDistance(prevPos, currentPos);
  const timeDeltaSec = timeDeltaMs / 1000;
  return timeDeltaSec > 0 ? distance / timeDeltaSec : 0;
}

/**
 * Format speed for display
 */
export function formatSpeed(metersPerSecond: number): string {
  const kmh = metersPerSecond * 3.6;
  return `${Math.round(kmh)} km/h`;
}
- - - scheduler.ts:
import { LocalNotifications } from '@capacitor/local-notifications';
import { Capacitor } from '@capacitor/core';
import api from './api';

export interface ScheduledTask {
  id: string;
  title: string;
  description: string;
  scheduledTime: number;
  createdAt: number;
  status: 'scheduled' | 'completed' | 'cancelled';
  notificationId: number;
}

const STORAGE_KEY = 'fexo_scheduled_tasks';

// --- Helper: Base64 Converter ---
function urlBase64ToUint8Array(base64String: string) {
  try {
    const padding = '='.repeat((4 - base64String.length % 4) % 4);
    const base64 = (base64String + padding)
      .replace(/-/g, '+')
      .replace(/_/g, '/');

    const rawData = window.atob(base64);
    const outputArray = new Uint8Array(rawData.length);

    for (let i = 0; i < rawData.length; ++i) {
      outputArray[i] = rawData.charCodeAt(i);
    }
    return outputArray;
  } catch (e) {
    console.error('[VAPID] Failed to convert VAPID key:', e);
    throw new Error("Invalid VAPID Key format");
  }
}

// --- Persistence ---
export const getTasks = (): ScheduledTask[] => {
  try {
    const stored = localStorage.getItem(STORAGE_KEY);
    return stored ? JSON.parse(stored) : [];
  } catch (e) { return []; }
};

const saveTasks = (tasks: ScheduledTask[]) => {
  localStorage.setItem(STORAGE_KEY, JSON.stringify(tasks));
  window.dispatchEvent(new Event('fexo-tasks-updated'));
};

export const addTask = (task: ScheduledTask) => {
  const tasks = getTasks();
  tasks.push(task);
  saveTasks(tasks);
};

export const updateTaskStatus = (id: string, status: ScheduledTask['status']) => {
  const tasks = getTasks();
  const index = tasks.findIndex(t => t.id === id);
  if (index !== -1) {
    tasks[index].status = status;
    saveTasks(tasks);
  }
};

export const deleteTask = async (id: string) => {
  const tasks = getTasks();
  const taskToDelete = tasks.find(t => t.id === id);
  if (taskToDelete && taskToDelete.status === 'scheduled') {
    try {
      if (Capacitor.isNativePlatform()) {
        await LocalNotifications.cancel({ notifications: [{ id: taskToDelete.notificationId }] });
      }
    } catch (e) { }
  }
  const newTasks = tasks.filter(t => t.id !== id);
  saveTasks(newTasks);
};

export const requestNotificationPermission = async (): Promise<boolean> => {
  try {
    if (Capacitor.isNativePlatform()) {
      const result = await LocalNotifications.requestPermissions();
      return result.display === 'granted';
    } else {
      if (!('Notification' in window)) return false;
      const permission = await Notification.requestPermission();
      return permission === 'granted';
    }
  } catch (e) {
    console.error('Error requesting permissions:', e);
    return false;
  }
};

// --- Server Push Setup ---
const trySetupServerPush = async (title: string, body: string, timestamp: string, taskId: string) => {
  // This group will collapse and hide in production
  console.groupCollapsed('[SCHEDULER] Push Setup');
  
  let vapidKey = import.meta.env.VITE_VAPID_PUBLIC_KEY;
  if (!vapidKey) {
    console.error('❌ Missing VITE_VAPID_PUBLIC_KEY');
    console.groupEnd();
    return;
  }
  vapidKey = vapidKey.trim();

  if (!('serviceWorker' in navigator) || !('PushManager' in window)) {
    console.debug('⚠️ Push Messaging not supported');
    console.groupEnd();
    return;
  }

  try {
    console.debug('Getting SW Registration...');
    let registration = await navigator.serviceWorker.getRegistration();
    
    if (!registration || !registration.active) {
        console.debug('SW not active, registering...');
        await navigator.serviceWorker.register('/sw.js');
        registration = await navigator.serviceWorker.ready;
    }

    let subscription = await registration.pushManager.getSubscription();

    if (!subscription) {
      console.debug('Creating new subscription...');
      const convertedKey = urlBase64ToUint8Array(vapidKey);
      
      subscription = await registration.pushManager.subscribe({
        userVisibleOnly: true,
        applicationServerKey: convertedKey
      });
    }

    console.debug('Sending to backend...');
    const subResponse = await api('/push/subscribe', {
      method: 'POST',
      body: JSON.stringify(subscription)
    });
    
    if(!subResponse.ok) throw new Error(`Backend returned ${subResponse.status}`);

    await api('/push/schedule', {
      method: 'POST',
      body: JSON.stringify({ title, body, timestamp, taskId })
    });

    console.debug('🎉 Push Scheduled');
  } catch (error: any) {
    // Keep errors visible for debugging locally, usually hidden/handled in prod
    console.error('❌ PUSH SETUP FAILED:', error.message || error);
  } finally {
    console.groupEnd();
  }
};

export const scheduleClientNotification = async (
  title: string,
  description: string | undefined,
  scheduleDate: Date
): Promise<{ success: boolean; error?: string }> => {
  try {
    const now = new Date();
    if (scheduleDate.getTime() <= now.getTime()) {
      return { success: false, error: 'Scheduled time must be in the future' };
    }

    const bodyContent = description || `Your task "${title}" starts now.`;
    const notificationId = Math.floor(Math.random() * 1000000);
    const taskId = crypto.randomUUID();

    // Mobile (Native)
    if (Capacitor.isNativePlatform()) {
      const perm = await LocalNotifications.checkPermissions();
      if (perm.display !== 'granted') {
        const request = await LocalNotifications.requestPermissions();
        if (request.display !== 'granted') {
             return { success: false, error: 'Notification permission missing on device.' };
        }
      }
      
      await LocalNotifications.schedule({
        notifications: [{
          title,
          body: bodyContent,
          id: notificationId,
          schedule: { at: scheduleDate },
          sound: undefined,
          smallIcon: 'ic_stat_icon_config_sample',
        }],
      });
    } 
    // Web (PWA)
    else {
      if (!('Notification' in window)) {
        return { success: false, error: 'Notifications not supported.' };
      }

      if (Notification.permission !== 'granted') {
        const permission = await Notification.requestPermission();
        if (permission !== 'granted') {
            return { success: false, error: 'Permission needed. Enable notifications in browser settings.' };
        }
      }

      // 1. Background Push
      trySetupServerPush(title, bodyContent, scheduleDate.toISOString(), taskId);

      // 2. Foreground Fallback
      const delay = scheduleDate.getTime() - Date.now();
      if (delay > 0 && delay < 2147483647) {
        setTimeout(() => {
          const currentTasks = getTasks();
          const task = currentTasks.find(t => t.id === taskId);
          if (task && task.status !== 'completed') {
            new Notification(title, { 
              body: bodyContent, 
              icon: '/worksparkai.svg',
              tag: taskId 
            });
            updateTaskStatus(taskId, 'completed');
            try { new Audio('/notification.mp3').play().catch(() => {}); } catch(e){}
          }
        }, delay);
      }
    }

    addTask({
      id: taskId,
      title,
      description: bodyContent,
      scheduledTime: scheduleDate.getTime(),
      createdAt: Date.now(),
      status: 'scheduled',
      notificationId
    });

    return { success: true };
  } catch (err: any) {
    console.error("[SCHEDULER] Fatal Error:", err);
    return { success: false, error: err.message || 'Unknown scheduling error' };
  }
};
- vite.config.d.ts:
declare const _default: import("vite").UserConfig;
export default _default;
